   1               		.file	"yack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 121               	keylatch:
   1:yack.c        **** /*!
   2:yack.c        ****  
   3:yack.c        ****  @file      yack.c
   4:yack.c        ****  @brief     CW Keyer library
   5:yack.c        ****  @author    Jan Lategahn DK3LJ jan@lategahn.com (C) 2011; modified by Jack Welch AI4SV; modified by
   6:yack.c        ****  
   7:yack.c        ****  @version   0.87
   8:yack.c        ****  
   9:yack.c        ****  This program is free software: you can redistribute it and/or modify
  10:yack.c        ****  it under the terms of the GNU General Public License as published by
  11:yack.c        ****  the Free Software Foundation, either version 3 of the License, or
  12:yack.c        ****  (at your option) any later version.
  13:yack.c        ****  
  14:yack.c        ****  This program is distributed in the hope that it will be useful,
  15:yack.c        ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:yack.c        ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:yack.c        ****  GNU General Public License for more details.
  18:yack.c        ****  
  19:yack.c        ****  You should have received a copy of the GNU General Public License
  20:yack.c        ****  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:yack.c        ****  
  22:yack.c        ****  @date      15.10.2010  - Created
  23:yack.c        ****  @date      03.10.2013  - Last update
  24:yack.c        ****  @date      21.12.2016  - Added additional prosigns and punctuation. Added 2 additional memories fo
  25:yack.c        ****  @date      03.01.2017  - If memory recording is interrupted by command button, keyer now returns t
  26:yack.c        ****                           Memory playback halts immediately on command key instead of looping throu
  27:yack.c        **** 						  Removed playback of recorded message before saving.
  28:yack.c        **** 						  Changed yackstring command to return to command mode instead of normal mode if interrupted 
  29:yack.c        ****  
  30:yack.c        ****  @todo      Make the delay dependent on T/C 1 
  31:yack.c        **** 
  32:yack.c        **** */ 
  33:yack.c        **** 
  34:yack.c        **** 
  35:yack.c        **** #include <avr/io.h> 
  36:yack.c        **** #include <avr/pgmspace.h>
  37:yack.c        **** #include <avr/eeprom.h>
  38:yack.c        **** #include <avr/interrupt.h>
  39:yack.c        **** #include <avr/sleep.h>
  40:yack.c        **** #include <util/delay.h>
  41:yack.c        **** #include <stdint.h>
  42:yack.c        **** #include "yack.h"
  43:yack.c        **** 
  44:yack.c        **** // Forward declaration of private functions
  45:yack.c        **** static      void key( byte mode); 
  46:yack.c        **** static      char morsechar(byte buffer);
  47:yack.c        **** static      void keylatch(void);
  48:yack.c        **** 
  49:yack.c        **** // Enumerations
  50:yack.c        **** 
  51:yack.c        **** enum FSMSTATE { 
  52:yack.c        ****                 IDLE,   //!< Not keyed, waiting for paddle
  53:yack.c        ****                 KEYED,  //!< Keyed, waiting for duration of current element
  54:yack.c        ****                 IEG     //!< In Inter-Element-Gap 
  55:yack.c        ****               };   
  56:yack.c        **** 
  57:yack.c        **** // Module local definitions
  58:yack.c        **** 
  59:yack.c        **** static		byte	yackflags;		// Permanent (stored) status of module flags
  60:yack.c        **** static		byte	volflags=0;		// Temporary working flags (volatile)
  61:yack.c        **** static 		word	ctcvalue;		// Pitch
  62:yack.c        **** static		word	wpmcnt;			// Speed
  63:yack.c        **** static      byte    wpm;            // Real wpm
  64:yack.c        **** static      byte    farnsworth;     // Additional Farnsworth pause
  65:yack.c        **** 
  66:yack.c        **** // EEPROM Data
  67:yack.c        **** 
  68:yack.c        **** byte		magic EEMEM = MAGPAT;	// Needs to contain 'A5' if mem is valid
  69:yack.c        **** byte		flagstor EEMEM = ( IAMBICB | TXKEY | SIDETONE);	//	Defaults	
  70:yack.c        **** word		ctcstor EEMEM = DEFCTC;	// Pitch = 800Hz
  71:yack.c        **** byte		wpmstor EEMEM = DEFWPM;	// 15 WPM
  72:yack.c        **** byte        fwstor  EEMEM = 0; // No farnsworth pause
  73:yack.c        **** word		user1 EEMEM = 0; // User storage
  74:yack.c        **** word		user2 EEMEM = 0; // User storage
  75:yack.c        **** 
  76:yack.c        **** //char		eebuffer1[100] EEMEM = "message 1";
  77:yack.c        **** //char		eebuffer2[100] EEMEM = "message 2";
  78:yack.c        **** char		eebuffer1[100] EEMEM = "message 1"; 
  79:yack.c        **** char		eebuffer2[100] EEMEM = "message 2"; 
  80:yack.c        **** char		eebuffer3[100] EEMEM = "message 3";
  81:yack.c        **** char		eebuffer4[100] EEMEM = "message 4"; 
  82:yack.c        **** 
  83:yack.c        **** // Flash data
  84:yack.c        **** 
  85:yack.c        **** //! Morse code table in Flash
  86:yack.c        **** 
  87:yack.c        **** //! Encoding: Each byte is read from the left. 0 stands for a dot, 1
  88:yack.c        **** //! stands for a dash. After each played element the content is shifted
  89:yack.c        **** //! left. Playback stops when the leftmost bit contains a "1" and the rest
  90:yack.c        **** //! of the bits are all zero.
  91:yack.c        **** //!
  92:yack.c        **** //! Example: A = .-
  93:yack.c        **** //! Encoding: 01100000
  94:yack.c        **** //!           .-
  95:yack.c        **** //!             | This is the stop marker (1 with all trailing zeros)
  96:yack.c        **** 
  97:yack.c        **** const byte morse[] PROGMEM = 
  98:yack.c        **** {
  99:yack.c        **** 	
 100:yack.c        **** 	0b11111100, // 0
 101:yack.c        **** 	0b01111100, // 1
 102:yack.c        **** 	0b00111100, // 2
 103:yack.c        **** 	0b00011100, // 3
 104:yack.c        **** 	0b00001100, // 4
 105:yack.c        **** 	0b00000100, // 5
 106:yack.c        **** 	0b10000100, // 6
 107:yack.c        **** 	0b11000100, // 7
 108:yack.c        **** 	0b11100100, // 8
 109:yack.c        **** 	0b11110100, // 9
 110:yack.c        **** 	0b01100000, // A
 111:yack.c        **** 	0b10001000, // B
 112:yack.c        **** 	0b10101000, // C
 113:yack.c        **** 	0b10010000, // D
 114:yack.c        **** 	0b01000000, // E
 115:yack.c        **** 	0b00101000, // F
 116:yack.c        **** 	0b11010000, // G
 117:yack.c        **** 	0b00001000, // H
 118:yack.c        **** 	0b00100000, // I                                
 119:yack.c        **** 	0b01111000, // J
 120:yack.c        **** 	0b10110000, // K
 121:yack.c        **** 	0b01001000, // L
 122:yack.c        **** 	0b11100000, // M
 123:yack.c        **** 	0b10100000, // N
 124:yack.c        **** 	0b11110000, // O
 125:yack.c        **** 	0b01101000, // P
 126:yack.c        **** 	0b11011000, // Q
 127:yack.c        **** 	0b01010000, // R
 128:yack.c        **** 	0b00010000, // S
 129:yack.c        **** 	0b11000000, // T
 130:yack.c        **** 	0b00110000, // U
 131:yack.c        **** 	0b00011000, // V
 132:yack.c        **** 	0b01110000, // W
 133:yack.c        **** 	0b10011000, // X
 134:yack.c        **** 	0b10111000, // Y
 135:yack.c        **** 	0b11001000, // Z
 136:yack.c        **** 	0b00110010, // ?
 137:yack.c        **** 	0b01010110, // .
 138:yack.c        **** 	0b10010100, // /
 139:yack.c        **** 	0b11101000, // ! (American Morse version, commonly used in ham circles)
 140:yack.c        **** 	0b11001110, // ,
 141:yack.c        **** 	0b11100010, // :
 142:yack.c        **** 	0b10101010, // ;
 143:yack.c        **** 	0b01001010, // "
 144:yack.c        **** 	0b00010011, // $
 145:yack.c        **** 	0b01111010, // ' (Apostrophe)
 146:yack.c        **** 	0b10110100, // ( or [ (also prosign KN)
 147:yack.c        ****     0b10110110, // ) or ]
 148:yack.c        **** 	0b10000110, // - (Hyphen or single dash)
 149:yack.c        **** 	0b01101010, // @
 150:yack.c        **** 	0b00110110, // _ (Underline)
 151:yack.c        **** 	0b01010010, // Paragaraph break symbol
 152:yack.c        **** 	0b10001100, // = and BT
 153:yack.c        **** 	0b00010110, // SK
 154:yack.c        **** 	0b01010100, // + and AR
 155:yack.c        **** 	0b10001011, // BK
 156:yack.c        **** 	0b01000100, // AS
 157:yack.c        **** 	0b10101100, // KA (also ! in alternate Continental Morse)
 158:yack.c        **** 	0b00010100, // VE
 159:yack.c        **** 	0b01011000  // AA
 160:yack.c        **** };
 161:yack.c        **** 
 162:yack.c        **** 
 163:yack.c        **** // The special characters at the end of the above table can not be decoded
 164:yack.c        **** // without a small table to define their content. # stands for SK, $ for AR
 165:yack.c        **** 
 166:yack.c        **** // To add new characters, add them in the code table above at the end and below
 167:yack.c        **** // Do not forget to increase the legth of the array..
 168:yack.c        **** 
 169:yack.c        **** const char spechar[24] PROGMEM = "?./!,:;~$^()-@_|=#+*%&<>";
 170:yack.c        **** 
 171:yack.c        **** 
 172:yack.c        **** 
 173:yack.c        **** // Functions
 174:yack.c        **** 
 175:yack.c        **** // ***************************************************************************
 176:yack.c        **** // Control functions
 177:yack.c        **** // ***************************************************************************
 178:yack.c        **** 
 179:yack.c        **** void yackreset (void)
 180:yack.c        **** /*! 
 181:yack.c        ****  @brief     Sets all yack parameters to standard values
 182:yack.c        **** 
 183:yack.c        ****  This function resets all YACK EEPROM settings to their default values as 
 184:yack.c        ****  stored in the .h file. It sets the dirty flag and calls the save routine
 185:yack.c        ****  to write the data into EEPROM immediately.
 186:yack.c        **** */
 187:yack.c        **** {
 188:yack.c        **** 
 189:yack.c        **** 	ctcvalue=DEFCTC; // Initialize to 800 Hz
 190:yack.c        ****     wpm=DEFWPM; // Init to default speed
 191:yack.c        **** 	wpmcnt=(1200/YACKBEAT)/DEFWPM; // default speed
 192:yack.c        ****     farnsworth=0; // No Farnsworth gap
 193:yack.c        **** 	yackflags = FLAGDEFAULT;  
 194:yack.c        **** 
 195:yack.c        **** 	volflags |= DIRTYFLAG;
 196:yack.c        **** 	yacksave(); // Store them in EEPROM
 197:yack.c        **** 
 198:yack.c        **** }
 199:yack.c        **** 
 200:yack.c        **** 
 201:yack.c        **** void yackinit (void)
 202:yack.c        **** /*! 
 203:yack.c        ****  @brief     Initializes the YACK library
 204:yack.c        ****  
 205:yack.c        ****  This function initializes the keyer hardware according to configurations in the .h file.
 206:yack.c        ****  Then it attempts to read saved configuration settings from EEPROM. If not possible, it
 207:yack.c        ****  will reset all values to their defaults.
 208:yack.c        ****  This function must be called once before the remaining fuctions can be used.
 209:yack.c        **** */
 210:yack.c        **** {
 211:yack.c        **** 	
 212:yack.c        **** 	byte magval;
 213:yack.c        **** 	
 214:yack.c        **** 	// Configure DDR. Make OUT and ST output ports
 215:yack.c        **** 	SETBIT (OUTDDR,OUTPIN);    
 216:yack.c        **** 	SETBIT (STDDR,STPIN);
 217:yack.c        ****     SETBIT (CMDDDR,CMDPIN);
 218:yack.c        **** 	
 219:yack.c        **** 	// Raise internal pullups for all inputs
 220:yack.c        **** 	SETBIT (KEYPORT,DITPIN);  
 221:yack.c        **** 	SETBIT (KEYPORT,DAHPIN);
 222:yack.c        **** 	SETBIT (BTNPORT,BTNPIN);
 223:yack.c        **** 	
 224:yack.c        **** 	magval = eeprom_read_byte(&magic); // Retrieve magic value
 225:yack.c        **** 	
 226:yack.c        **** 	if (magval == MAGPAT) // Is memory valid
 227:yack.c        **** 	{
 228:yack.c        **** 		ctcvalue = eeprom_read_word(&ctcstor); // Retrieve last ctc setting
 229:yack.c        **** 		wpm = eeprom_read_byte(&wpmstor); // Retrieve last wpm setting
 230:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate speed
 231:yack.c        **** 		farnsworth = eeprom_read_byte(&fwstor); // Retrieve last wpm setting	
 232:yack.c        **** 		yackflags = eeprom_read_byte(&flagstor); // Retrieve last flags	
 233:yack.c        **** 	}
 234:yack.c        **** 	else
 235:yack.c        **** 	{
 236:yack.c        **** 		yackreset();
 237:yack.c        **** 	}	
 238:yack.c        **** 	
 239:yack.c        **** 	yackinhibit(OFF);
 240:yack.c        **** 
 241:yack.c        **** #ifdef POWERSAVE
 242:yack.c        ****     
 243:yack.c        ****     PCMSK |= PWRWAKE;    // Define which keys wake us up
 244:yack.c        ****     GIMSK |= (1<<PCIE);  // Enable pin change interrupt
 245:yack.c        ****     
 246:yack.c        **** #endif
 247:yack.c        ****     
 248:yack.c        ****     // Initialize timer1 to serve as the system heartbeat
 249:yack.c        ****     // CK runs at 1MHz. Prescaling by 64 makes that 15625 Hz.
 250:yack.c        ****     // Counting 78 cycles of that generates an overflow every 5ms
 251:yack.c        ****     
 252:yack.c        ****     OCR1C = 78; // 77 counts per cycle
 253:yack.c        ****     TCCR1 |= (1<<CTC1) | 0b00000111 ; // Clear Timer on match, prescale ck by 64
 254:yack.c        ****     OCR1A = 1; // CTC mode does not create an overflow so we use OCR1A
 255:yack.c        ****     
 256:yack.c        **** }
 257:yack.c        **** 
 258:yack.c        **** #ifdef POWERSAVE
 259:yack.c        **** 
 260:yack.c        **** ISR(PCINT0_vect)
 261:yack.c        **** /*! 
 262:yack.c        ****  @brief     A dummy pin change interrupt
 263:yack.c        ****  
 264:yack.c        ****  This function is called whenever the system is in sleep mode and there is a level change on one of
 265:yack.c        ****  we are monitoring (dit, dah and the command key). As all handling is already taken care of by poll
 266:yack.c        ****  routines, there is nothing we need to do here.
 267:yack.c        ****  */
 268:yack.c        **** {
 269:yack.c        ****     // Nothing to do here. All we want is to wake up..
 270:yack.c        **** }
 271:yack.c        **** 
 272:yack.c        **** 
 273:yack.c        **** void yackpower(byte n)
 274:yack.c        **** /*! 
 275:yack.c        ****  @brief     Manages the power saving mode
 276:yack.c        ****  
 277:yack.c        ****  This is called in yackbeat intervals with either a TRUE or FALSE as parameter. Whenever the
 278:yack.c        ****  parameter is TRUE a beat counter is advanced until the timeout level is reached. When timeout
 279:yack.c        ****  is reached, the chip shuts down and will only wake up again when issued a level change interrupt o
 280:yack.c        ****  either of the input pins.
 281:yack.c        ****  
 282:yack.c        ****  When the parameter is FALSE, the counter is reset.
 283:yack.c        ****  
 284:yack.c        ****  @param n   TRUE: OK to sleep, FALSE: Can not sleep now
 285:yack.c        ****  
 286:yack.c        **** */
 287:yack.c        **** 
 288:yack.c        **** {
 289:yack.c        ****     static uint32_t shdntimer=0;
 290:yack.c        ****     
 291:yack.c        ****     if (n) // True = we could go to sleep
 292:yack.c        ****     {
 293:yack.c        ****         if(shdntimer++ == YACKSECS(PSTIME))
 294:yack.c        ****         {
 295:yack.c        ****             shdntimer=0; // So we do not go to sleep right after waking up..
 296:yack.c        **** 
 297:yack.c        ****             set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 298:yack.c        ****             sleep_bod_disable();
 299:yack.c        ****             sleep_enable();
 300:yack.c        ****             sei();
 301:yack.c        ****             sleep_cpu();
 302:yack.c        ****             cli();
 303:yack.c        ****             
 304:yack.c        ****             // There is no technical reason to CLI here but it avoids hitting the ISR every time
 305:yack.c        ****             // the paddles are touched. If the remaining code needs the interrupts this is OK to re
 306:yack.c        ****             
 307:yack.c        ****         }
 308:yack.c        ****         
 309:yack.c        ****     }
 310:yack.c        ****     else // Passed parameter is FALSE
 311:yack.c        ****     {
 312:yack.c        ****         shdntimer=0;
 313:yack.c        ****     }
 314:yack.c        **** 
 315:yack.c        **** }
 316:yack.c        **** 
 317:yack.c        **** #endif
 318:yack.c        **** 
 319:yack.c        **** 
 320:yack.c        **** 
 321:yack.c        **** void yacksave (void)
 322:yack.c        **** /*! 
 323:yack.c        ****  @brief     Saves all permanent settings to EEPROM
 324:yack.c        ****  
 325:yack.c        ****  To save EEPROM write cycles, writing only happens when the flag DIRTYFLAG is set.
 326:yack.c        ****  After writing the flag is cleared
 327:yack.c        ****  
 328:yack.c        ****  @callergraph
 329:yack.c        ****  
 330:yack.c        ****  */
 331:yack.c        **** {
 332:yack.c        **** 	
 333:yack.c        **** 	if(volflags & DIRTYFLAG) // Dirty flag set?
 334:yack.c        **** 	{	
 335:yack.c        **** 		
 336:yack.c        **** 		eeprom_write_byte(&magic, MAGPAT);
 337:yack.c        **** 		eeprom_write_word(&ctcstor, ctcvalue);
 338:yack.c        **** 		eeprom_write_byte(&wpmstor, wpm);
 339:yack.c        **** 		eeprom_write_byte(&flagstor, yackflags);
 340:yack.c        ****         eeprom_write_byte(&fwstor, farnsworth);
 341:yack.c        **** 		
 342:yack.c        **** 		volflags &= ~DIRTYFLAG; // Clear the dirty flag
 343:yack.c        **** 	}
 344:yack.c        **** 	
 345:yack.c        **** }
 346:yack.c        **** 
 347:yack.c        **** 
 348:yack.c        **** 
 349:yack.c        **** void yackinhibit (byte mode)
 350:yack.c        **** /*! 
 351:yack.c        ****  @brief     Inhibits keying during command phases
 352:yack.c        ****  
 353:yack.c        ****  This function is used to inhibit and re-enable TX keying (if configured) and enforce the internal 
 354:yack.c        ****  sidetone oscillator to be active so that the user can communicate with the keyer.
 355:yack.c        ****  
 356:yack.c        ****  @param mode   ON inhibits keying, OFF re-enables keying 
 357:yack.c        ****  
 358:yack.c        ****  */
 359:yack.c        **** {
 360:yack.c        **** 	
 361:yack.c        **** 	if (mode)
 362:yack.c        **** 	{
 363:yack.c        ****         SETBIT(CMDPORT,CMDPIN); // Show the command mode light if inhibit is active
 364:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 365:yack.c        **** 		volflags |= SIDETONE;
 366:yack.c        **** 	}
 367:yack.c        **** 	
 368:yack.c        **** 	else
 369:yack.c        **** 		
 370:yack.c        **** 	{
 371:yack.c        ****         CLEARBIT(CMDPORT,CMDPIN); // Stop the command mode light if inhibit is inactive
 372:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 373:yack.c        **** 		volflags |= (yackflags & (TXKEY | SIDETONE));
 374:yack.c        ****         key(UP);
 375:yack.c        **** 	}
 376:yack.c        **** 	
 377:yack.c        **** }
 378:yack.c        **** 
 379:yack.c        **** 
 380:yack.c        **** 
 381:yack.c        **** word yackuser (byte func, byte nr, word content)
 382:yack.c        **** /*! 
 383:yack.c        ****  @brief     Saves user defined settings
 384:yack.c        ****  
 385:yack.c        ****  The routine using this library is given the opportunity to save up to two 16 bit sized
 386:yack.c        ****  values in EEPROM. In case of the sample main function this is used to store the beacon interval 
 387:yack.c        ****  timer value. The routine is not otherwise used by the library.
 388:yack.c        ****  
 389:yack.c        ****  @param func    States if the data is retrieved (READ) or written (WRITE) to EEPROM
 390:yack.c        ****  @param nr      1 or 2 (Number of user storage to access)
 391:yack.c        ****  @param content The 16 bit word to write. Not used in read mode.
 392:yack.c        ****  @return        The content of the retrieved value in read mode.
 393:yack.c        ****  
 394:yack.c        ****  */
 395:yack.c        **** {
 396:yack.c        **** 	
 397:yack.c        ****     
 398:yack.c        **** 	if (func == READ)
 399:yack.c        **** 	{
 400:yack.c        **** 		if (nr == 1) 
 401:yack.c        **** 			return (eeprom_read_word(&user1));
 402:yack.c        **** 		else if (nr == 2)
 403:yack.c        **** 			return (eeprom_read_word(&user2));
 404:yack.c        **** 	}
 405:yack.c        **** 	
 406:yack.c        **** 	if (func == WRITE)
 407:yack.c        **** 	{
 408:yack.c        ****         
 409:yack.c        **** 		if (nr == 1)
 410:yack.c        **** 			eeprom_write_word(&user1, content);
 411:yack.c        **** 		else if (nr == 2)
 412:yack.c        **** 			eeprom_write_word(&user2, content);
 413:yack.c        **** 	}
 414:yack.c        **** 
 415:yack.c        ****     return (FALSE);
 416:yack.c        ****     
 417:yack.c        **** }
 418:yack.c        **** 
 419:yack.c        **** 
 420:yack.c        **** 
 421:yack.c        **** word yackwpm(void)
 422:yack.c        **** /*! 
 423:yack.c        ****  @brief     Retrieves the current WPM speed
 424:yack.c        ****  
 425:yack.c        ****  This function delivers the current WPM speed. 
 426:yack.c        **** 
 427:yack.c        ****  @return        Current speed in WPM
 428:yack.c        ****  
 429:yack.c        ****  */
 430:yack.c        **** {
 431:yack.c        ****     
 432:yack.c        ****     return wpm; 
 433:yack.c        ****     
 434:yack.c        **** }
 435:yack.c        **** 
 436:yack.c        **** 
 437:yack.c        **** void yackspeed (byte dir, byte mode)
 438:yack.c        **** /*! 
 439:yack.c        ****  @brief     Increases or decreases the current WPM speed
 440:yack.c        ****  
 441:yack.c        ****  The amount of increase or decrease is in amounts of wpmcnt. Those are close to real
 442:yack.c        ****  WPM in a 10ms heartbeat but can significantly differ at higher heartbeat speeds.
 443:yack.c        ****  
 444:yack.c        ****  @param dir     UP (faster) or DOWN (slower)
 445:yack.c        ****  
 446:yack.c        ****  */
 447:yack.c        **** {
 448:yack.c        ****     
 449:yack.c        ****     if (mode == FARNSWORTH)
 450:yack.c        ****     {
 451:yack.c        ****         if ((dir == UP) && (farnsworth > 0))
 452:yack.c        ****             farnsworth--;
 453:yack.c        ****         
 454:yack.c        ****         if ((dir == DOWN) && (farnsworth < MAXFARN))
 455:yack.c        ****             farnsworth++;
 456:yack.c        ****     }
 457:yack.c        ****     else // WPMSPEED
 458:yack.c        ****     {
 459:yack.c        ****         if ((dir == UP) && (wpm < MAXWPM))
 460:yack.c        ****             wpm++;
 461:yack.c        ****         
 462:yack.c        ****         if ((dir == DOWN) && (wpm > MINWPM))
 463:yack.c        ****             wpm--;
 464:yack.c        ****         
 465:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate beats
 466:yack.c        **** 
 467:yack.c        **** 	}
 468:yack.c        **** 	
 469:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 470:yack.c        ****     
 471:yack.c        ****     yackplay(DIT);
 472:yack.c        ****     yackdelay(IEGLEN);	// Inter Element gap  
 473:yack.c        ****     yackplay(DAH);
 474:yack.c        ****     yackdelay(ICGLEN);	// Inter Character gap  
 475:yack.c        ****     yackfarns(); // Additional Farnsworth delay
 476:yack.c        ****     
 477:yack.c        **** }
 478:yack.c        **** 
 479:yack.c        **** 
 480:yack.c        **** 
 481:yack.c        **** void yackbeat (void)
 482:yack.c        **** /*! 
 483:yack.c        ****  @brief     Heartbeat delay
 484:yack.c        ****  
 485:yack.c        ****  Several functions in the keyer are timing dependent. The most prominent example is the
 486:yack.c        ****  yackiambic function that implements the IAMBIC keyer finite state machine.
 487:yack.c        ****  The same expects to be called in intervals of YACKBEAT milliseconds. How this is 
 488:yack.c        ****  implemented is left to the user. In a more complex application this would be done
 489:yack.c        ****  using an interrupt or a timer. For simpler cases this is a busy wait routine
 490:yack.c        ****  that delays exactly YACKBEAT ms.
 491:yack.c        ****  
 492:yack.c        ****  */
 493:yack.c        **** {
 494:yack.c        ****     while((TIFR & (1<<OCF1A)) == 0); // Wait for Timeout
 495:yack.c        ****     TIFR |= (1<<OCF1A);                // Reset output compare flag
 496:yack.c        **** }
 497:yack.c        **** 
 498:yack.c        **** 
 499:yack.c        **** 
 500:yack.c        **** void yackpitch (byte dir)
 501:yack.c        **** /*! 
 502:yack.c        ****  @brief     Increases or decreases the sidetone pitch
 503:yack.c        ****  
 504:yack.c        ****  Changes are done not in Hz but in ctc control values. This is to avoid extensive 
 505:yack.c        ****  calculations at runtime. As is all calculations are done by the preprocessor.
 506:yack.c        ****  
 507:yack.c        ****  @param dir     UP or DOWN
 508:yack.c        ****  
 509:yack.c        ****  */
 510:yack.c        **** {
 511:yack.c        **** 	if (dir == UP)
 512:yack.c        **** 		ctcvalue--;
 513:yack.c        **** 	if (dir == DOWN)
 514:yack.c        **** 		ctcvalue++;
 515:yack.c        **** 	
 516:yack.c        **** 	if (ctcvalue < MAXCTC)
 517:yack.c        **** 		ctcvalue = MAXCTC;
 518:yack.c        **** 	
 519:yack.c        **** 	if (ctcvalue > MINCTC)
 520:yack.c        **** 		ctcvalue = MINCTC;
 521:yack.c        **** 	
 522:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 523:yack.c        **** 	
 524:yack.c        **** }
 525:yack.c        **** 
 526:yack.c        **** 
 527:yack.c        **** 
 528:yack.c        **** 
 529:yack.c        **** void yacktune (void)
 530:yack.c        **** /*! 
 531:yack.c        ****  @brief     Activates Tuning mode
 532:yack.c        ****  
 533:yack.c        ****  This produces a solid keydown for TUNEDURATION seconds. After this the TX is unkeyed.
 534:yack.c        ****  The same can be achieved by presing either the DIT or the DAH contact or the control key.
 535:yack.c        ****  
 536:yack.c        **** */
 537:yack.c        **** {
 538:yack.c        **** 	word timer = YACKSECS(TUNEDURATION);
 539:yack.c        **** 	
 540:yack.c        **** 	key(DOWN);
 541:yack.c        **** 	
 542:yack.c        **** 	while(timer && (KEYINP & (1<<DITPIN)) && (KEYINP & (1<<DAHPIN)) && !yackctrlkey(TRUE) )
 543:yack.c        **** 	{
 544:yack.c        **** 		timer--;
 545:yack.c        **** 		yackbeat();
 546:yack.c        **** 	}
 547:yack.c        **** 	
 548:yack.c        **** 	key(UP);
 549:yack.c        **** }
 550:yack.c        **** 
 551:yack.c        **** 
 552:yack.c        **** 
 553:yack.c        **** 
 554:yack.c        **** void yackmode (byte mode)
 555:yack.c        **** /*! 
 556:yack.c        ****  @brief     Sets the keyer mode (e.g. IAMBIC A)
 557:yack.c        ****  
 558:yack.c        ****  This allows to set the content of the two mode bits in yackflags. Currently only
 559:yack.c        ****  two modes are supported, IAMBIC A and IAMBIC B.
 560:yack.c        ****  
 561:yack.c        ****  @param mode    IAMBICA or IAMBICB
 562:yack.c        ****  @return    TRUE is all was OK, FALSE if configuration lock prevented changes
 563:yack.c        ****  
 564:yack.c        ****  */
 565:yack.c        **** {
 566:yack.c        **** 
 567:yack.c        **** 	yackflags &= ~MODE;
 568:yack.c        **** 	yackflags |= mode;
 569:yack.c        **** 	
 570:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 571:yack.c        **** 
 572:yack.c        **** }
 573:yack.c        **** 
 574:yack.c        **** 
 575:yack.c        **** byte yackflag(byte flag)
 576:yack.c        **** /*! 
 577:yack.c        ****  @brief     Query feature flags
 578:yack.c        ****  
 579:yack.c        ****  @param flag A byte which indicate which flags are to be queried 
 580:yack.c        ****  @return     0 if the flag(s) were clear, >0 if flag(s) were set
 581:yack.c        ****  
 582:yack.c        ****  */
 583:yack.c        **** {
 584:yack.c        ****     return yackflags & flag;
 585:yack.c        **** }
 586:yack.c        **** 
 587:yack.c        **** 
 588:yack.c        **** 
 589:yack.c        **** void yacktoggle(byte flag)
 590:yack.c        **** /*! 
 591:yack.c        ****  @brief     Toggle feature flags
 592:yack.c        ****  
 593:yack.c        ****  When passed one (or more) flags, this routine flips the according bit in yackflags and
 594:yack.c        ****  thereby enables or disables the corresponding feature.
 595:yack.c        ****  
 596:yack.c        ****  @param flag    A byte where any bit to toggle is set e.g. SIDETONE 
 597:yack.c        ****  @return    TRUE if all was OK, FALSE if configuration lock prevented changes
 598:yack.c        ****  
 599:yack.c        ****  */
 600:yack.c        **** {
 601:yack.c        ****     
 602:yack.c        ****     yackflags ^= flag;      // Toggle the feature bit
 603:yack.c        ****     volflags |= DIRTYFLAG;  // Set the dirty flag	
 604:yack.c        **** 
 605:yack.c        **** }
 606:yack.c        **** 
 607:yack.c        **** 
 608:yack.c        **** 
 609:yack.c        **** 
 610:yack.c        **** void yackerror (void)
 611:yack.c        **** /*! 
 612:yack.c        ****  @brief     Creates a series of 8 dits
 613:yack.c        ****  
 614:yack.c        ****  The error prosign (8 dits) can not be encoded in our coding table. A call to this
 615:yack.c        ****  function produces it..
 616:yack.c        ****  
 617:yack.c        ****  */
 618:yack.c        **** {
 619:yack.c        **** 	byte i;
 620:yack.c        **** 	
 621:yack.c        **** 	for (i=0;i<8;i++)
 622:yack.c        **** 	{
 623:yack.c        **** 		yackplay(DIT);
 624:yack.c        **** 		yackdelay(DITLEN);
 625:yack.c        **** 	}
 626:yack.c        **** 	yackdelay(DAHLEN);
 627:yack.c        **** 	
 628:yack.c        **** }
 629:yack.c        **** 
 630:yack.c        **** 
 631:yack.c        **** 
 632:yack.c        **** 
 633:yack.c        **** // ***************************************************************************
 634:yack.c        **** // CW Playback related functions
 635:yack.c        **** // ***************************************************************************
 636:yack.c        **** 
 637:yack.c        **** static void key(byte mode) 
 638:yack.c        **** /*! 
 639:yack.c        ****  @brief     Keys the transmitter and produces a sidetone
 640:yack.c        ****  
 641:yack.c        ****  .. but only if the corresponding functions (TXKEY and SIDETONE) have been set in
 642:yack.c        ****  the feature register. This function also handles a request to invert the keyer line
 643:yack.c        ****  if necessary (TXINV bit).
 644:yack.c        ****  
 645:yack.c        ****  This is a private function.
 646:yack.c        **** 
 647:yack.c        ****  @param mode    UP or DOWN
 648:yack.c        ****  
 649:yack.c        ****  */
 650:yack.c        **** {
 651:yack.c        **** 	
 652:yack.c        ****     if (mode == DOWN) 
 653:yack.c        ****     {
 654:yack.c        ****         if (volflags & SIDETONE) // Are we generating a Sidetone?
 655:yack.c        ****         {
 656:yack.c        ****             OCR0A = ctcvalue;		// Then switch on the Sidetone generator
 657:yack.c        ****             OCR0B = ctcvalue;
 658:yack.c        ****             
 659:yack.c        ****             // Activate CTC mode
 660:yack.c        ****             TCCR0A |= (1<<COM0B0 | 1<<WGM01);
 661:yack.c        ****             
 662:yack.c        ****             // Configure prescaler
 663:yack.c        ****             TCCR0B = 1<<CS01;
 664:yack.c        ****         }
 665:yack.c        ****         
 666:yack.c        ****         if (volflags & TXKEY) // Are we keying the TX?
 667:yack.c        ****         {
 668:yack.c        ****             if (yackflags & TXINV) // Do we need to invert keying?
 669:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 670:yack.c        ****             else
 671:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 672:yack.c        ****         }
 673:yack.c        **** 
 674:yack.c        ****     }
 675:yack.c        ****     
 676:yack.c        ****     if (mode == UP) 
 677:yack.c        ****     {
 678:yack.c        **** 
 679:yack.c        ****         if (volflags & SIDETONE) // Sidetone active?
 680:yack.c        ****         {
 681:yack.c        ****             TCCR0A = 0;
 682:yack.c        ****             TCCR0B = 0;
 683:yack.c        ****         }
 684:yack.c        ****         
 685:yack.c        ****         if (volflags & TXKEY) // Are we keying the TX?
 686:yack.c        ****         {
 687:yack.c        ****             if (yackflags & TXINV) // Do we need to invert keying?
 688:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 689:yack.c        ****             else
 690:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 691:yack.c        ****         }
 692:yack.c        **** 
 693:yack.c        ****     }
 694:yack.c        ****     
 695:yack.c        **** }
 696:yack.c        **** 
 697:yack.c        **** 
 698:yack.c        **** 
 699:yack.c        **** void yackfarns(void)
 700:yack.c        **** /*! 
 701:yack.c        ****  @brief     Produces an additional waiting delay for farnsworth mode.
 702:yack.c        ****  
 703:yack.c        ****  */
 704:yack.c        **** {
 705:yack.c        **** 	
 706:yack.c        ****     word i=farnsworth;
 707:yack.c        **** 	
 708:yack.c        **** 	while (i--)
 709:yack.c        **** 	{
 710:yack.c        ****     	yackdelay(1);
 711:yack.c        **** 	}
 712:yack.c        **** 	
 713:yack.c        **** }
 714:yack.c        **** 
 715:yack.c        **** 
 716:yack.c        **** 
 717:yack.c        **** void yackdelay(byte n)
 718:yack.c        **** /*! 
 719:yack.c        ****  @brief     Produces an active waiting delay for n dot counts
 720:yack.c        ****  
 721:yack.c        ****  This is used during the playback functions where active waiting is needed
 722:yack.c        ****  
 723:yack.c        ****  @param n   number of dot durations to delay (dependent on current keying speed!
 724:yack.c        ****  
 725:yack.c        ****  */
 726:yack.c        **** {
 727:yack.c        **** 	
 728:yack.c        **** 	byte i=n;
 729:yack.c        **** 	byte x;
 730:yack.c        **** 	
 731:yack.c        **** 	while (i--)
 732:yack.c        **** 	{
 733:yack.c        **** 		x=wpmcnt;
 734:yack.c        **** 		while (x--)    
 735:yack.c        **** 			yackbeat();
 736:yack.c        **** 	}
 737:yack.c        **** 	
 738:yack.c        **** }
 739:yack.c        **** 
 740:yack.c        **** 
 741:yack.c        **** 
 742:yack.c        **** 
 743:yack.c        **** void yackplay(byte i) 
 744:yack.c        **** /*! 
 745:yack.c        ****  @brief     Key the TX / Sidetone for the duration of a dit or a dah
 746:yack.c        ****  
 747:yack.c        ****  @param i   DIT or DAH
 748:yack.c        ****  
 749:yack.c        ****  */
 750:yack.c        **** {
 751:yack.c        **** 	
 752:yack.c        ****     key(DOWN); 
 753:yack.c        **** 
 754:yack.c        **** #ifdef POWERSAVE
 755:yack.c        ****     
 756:yack.c        ****     yackpower(FALSE); // Avoid powerdowns when keying
 757:yack.c        ****     
 758:yack.c        **** #endif
 759:yack.c        ****     
 760:yack.c        **** 	switch (i)
 761:yack.c        **** 	{
 762:yack.c        **** 		case DAH:
 763:yack.c        **** 			yackdelay(DAHLEN);
 764:yack.c        **** 			break;
 765:yack.c        **** 			
 766:yack.c        **** 		case DIT:
 767:yack.c        **** 			yackdelay(DITLEN);
 768:yack.c        **** 			break;
 769:yack.c        **** 	}
 770:yack.c        ****     
 771:yack.c        ****     key(UP);
 772:yack.c        **** 	
 773:yack.c        **** }
 774:yack.c        **** 
 775:yack.c        **** 
 776:yack.c        **** 
 777:yack.c        **** 
 778:yack.c        **** void yackchar(char c)
 779:yack.c        **** /*! 
 780:yack.c        ****  @brief     Send a character in morse code
 781:yack.c        ****  
 782:yack.c        ****  This function translates a character passed as parameter into morse code using the 
 783:yack.c        ****  translation table in Flash memory. It then keys transmitter / sidetone with the characters
 784:yack.c        ****  elements and adds all necessary gaps (as if the character was part of a longer word).
 785:yack.c        ****  
 786:yack.c        ****  If the character can not be translated, nothing is sent.
 787:yack.c        ****  
 788:yack.c        ****  If a space is received, an interword gap is sent.
 789:yack.c        ****   
 790:yack.c        ****  @param c   The character to send
 791:yack.c        ****  
 792:yack.c        **** */
 793:yack.c        **** 
 794:yack.c        **** 
 795:yack.c        **** {
 796:yack.c        **** 	byte	code=0x80; // 0x80 is an empty morse character (just eoc bit set)
 797:yack.c        **** 	byte 	i; // a counter
 798:yack.c        **** 	
 799:yack.c        **** 	// First we need to map the actual character to the encoded morse sequence in
 800:yack.c        **** 	// the array "morse"
 801:yack.c        **** 	if(c>='0' && c<='9') // Is it a numerical digit?
 802:yack.c        **** 		code = pgm_read_byte(&morse[c-'0']); // Find it in the beginning of array
 803:yack.c        ****     
 804:yack.c        **** 	if(c>='a' && c<='z') // Is it a character?
 805:yack.c        **** 		code = pgm_read_byte(&morse[c-'a'+10]); // Find it from position 10
 806:yack.c        **** 	
 807:yack.c        **** 	if(c>='A' && c<='Z') // Is it a character in upper case?
 808:yack.c        **** 		code = pgm_read_byte(&morse[c-'A'+10]); // Same as above
 809:yack.c        **** 	
 810:yack.c        **** 	// Last we need to handle special characters. There is a small char
 811:yack.c        **** 	// array "spechar" which contains the characters for the morse elements
 812:yack.c        **** 	// at the end of the "morse" array (see there!)
 813:yack.c        **** 	for(i=0;i<sizeof(spechar);i++) // Read through the array
 814:yack.c        **** 		if (c == pgm_read_byte(&spechar[i])) // Does it contain our character
 815:yack.c        **** 			code = pgm_read_byte(&morse[i+36]); // Map it to morse code
 816:yack.c        **** 	
 817:yack.c        **** 	if(c==' ') // Do they want us to transmit a space (a gap of 7 dots)
 818:yack.c        **** 		yackdelay(IWGLEN-ICGLEN); // ICG was already played after previous char
 819:yack.c        **** 	else
 820:yack.c        **** 	{
 821:yack.c        ****   		while (code != 0x80) // Stop when EOC bit has reached MSB
 822:yack.c        ****   		{
 823:yack.c        **** 			if (yackctrlkey(FALSE)) // Stop playing if someone pushes key
 824:yack.c        **** 				return;
 825:yack.c        **** 			
 826:yack.c        ****      		if (code & 0x80) 	// MSB set ?
 827:yack.c        ****        			yackplay(DAH);      // ..then play a dash
 828:yack.c        ****      		else				// MSB cleared ?
 829:yack.c        ****        			yackplay(DIT);		// .. then play a dot
 830:yack.c        **** 			
 831:yack.c        ****      		yackdelay(IEGLEN);	// Inter Element gap  
 832:yack.c        ****             
 833:yack.c        ****      		code = code << 1;	// Shift code on position left (to next element)
 834:yack.c        ****   		}
 835:yack.c        **** 		
 836:yack.c        ****   		yackdelay(ICGLEN - IEGLEN); // IEG was already played after element
 837:yack.c        **** 
 838:yack.c        ****         yackfarns(); // Insert another gap for farnsworth keying
 839:yack.c        **** 
 840:yack.c        **** 	}
 841:yack.c        **** 	
 842:yack.c        **** }
 843:yack.c        **** 
 844:yack.c        **** 
 845:yack.c        **** 
 846:yack.c        **** void yackstring(const char *p)
 847:yack.c        **** /*! 
 848:yack.c        ****  @brief     Sends a 0-terminated string in CW which resides in Flash
 849:yack.c        ****  
 850:yack.c        ****  Reads character by character from flash, translates into CW and keys the transmitter
 851:yack.c        ****  and/or sidetone depending on feature bit settings.
 852:yack.c        ****  
 853:yack.c        ****  @param p   Pointer to string location in FLASH 
 854:yack.c        ****  
 855:yack.c        ****  */
 856:yack.c        **** {
 857:yack.c        **** 	
 858:yack.c        **** 	char c;
 859:yack.c        **** 	
 860:yack.c        **** 	while ((c = pgm_read_byte(p++))&& !(yackctrlkey(TRUE)) )
 861:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 862:yack.c        **** 		yackchar(c);            // Play the read character
 863:yack.c        **** 								// abort now if someone presses command key
 864:yack.c        **** 	
 865:yack.c        **** }
 866:yack.c        **** 
 867:yack.c        **** 
 868:yack.c        **** 
 869:yack.c        **** void yacknumber(word n)
 870:yack.c        **** /*! 
 871:yack.c        ****  @brief     Sends a number in CW
 872:yack.c        ****  
 873:yack.c        ****  Transforms a number up to 65535 into its digits and sends them in CW
 874:yack.c        ****  
 875:yack.c        ****  @param n   The number to send
 876:yack.c        ****  
 877:yack.c        ****  */
 878:yack.c        **** 
 879:yack.c        **** {
 880:yack.c        ****     
 881:yack.c        ****     char buffer[5];
 882:yack.c        ****     byte i = 0;
 883:yack.c        **** 	
 884:yack.c        **** 	while (n) // Until nothing left or control key pressed
 885:yack.c        **** 	{
 886:yack.c        **** 		buffer[i++] = n%10+'0'; // Store rest of division by 10
 887:yack.c        **** 		n /= 10;                // Divide by 10
 888:yack.c        **** 	}
 889:yack.c        **** 	
 890:yack.c        ****     while (i)
 891:yack.c        ****     {
 892:yack.c        **** 		if (yackctrlkey(TRUE)) {break;}
 893:yack.c        ****         yackchar(buffer[--i]);
 894:yack.c        ****     }
 895:yack.c        ****     
 896:yack.c        ****     yackchar (' ');
 897:yack.c        ****     
 898:yack.c        **** }
 899:yack.c        **** 
 900:yack.c        **** 
 901:yack.c        **** 
 902:yack.c        **** // ***************************************************************************
 903:yack.c        **** // CW Keying related functions
 904:yack.c        **** // ***************************************************************************
 905:yack.c        **** 
 906:yack.c        **** 
 907:yack.c        **** static void keylatch(void)
 908:yack.c        **** /*! 
 909:yack.c        ****  @brief     Latches the status of the DIT and DAH paddles
 910:yack.c        ****  
 911:yack.c        ****  If either DIT or DAH are keyed, this function sets the corresponding bit in 
 912:yack.c        ****  volflags. This is used by the IAMBIC keyer to determine which element needs to 
 913:yack.c        ****  be sounded next.
 914:yack.c        ****  
 915:yack.c        ****  This is a private function.
 916:yack.c        **** 
 917:yack.c        ****  */
 918:yack.c        **** {
 123               	.LM0:
 124               	.LFBB1:
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 0 */
 128               	.L__stack_usage = 0
 919:yack.c        **** 	
 920:yack.c        **** 	byte	swap;	 // Status of swap flag
 921:yack.c        **** 	
 922:yack.c        **** 	swap    = ( yackflags & PDLSWAP);
 130               	.LM1:
 131 0000 8091 0000 		lds r24,yackflags
 132 0004 8078      		andi r24,lo8(-128)
 923:yack.c        **** 	
 924:yack.c        **** 	if (!( KEYINP & (1<<DITPIN)))
 134               	.LM2:
 135 0006 B399      		sbic 0x16,3
 136 0008 00C0      		rjmp .L2
 925:yack.c        **** 		volflags |= (swap?DAHLATCH:DITLATCH);
 138               	.LM3:
 139 000a 8111      		cpse r24,__zero_reg__
 140 000c 00C0      		rjmp .L6
 141 000e 91E0      		ldi r25,lo8(1)
 142 0010 00C0      		rjmp .L3
 143               	.L6:
 144 0012 92E0      		ldi r25,lo8(2)
 145               	.L3:
 147               	.LM4:
 148 0014 2091 0000 		lds r18,volflags
 149 0018 922B      		or r25,r18
 150 001a 9093 0000 		sts volflags,r25
 151               	.L2:
 926:yack.c        **** 	
 927:yack.c        **** 	if (!( KEYINP & (1<<DAHPIN)))
 153               	.LM5:
 154 001e B499      		sbic 0x16,4
 155 0020 00C0      		rjmp .L1
 928:yack.c        **** 		volflags |= (swap?DITLATCH:DAHLATCH);
 157               	.LM6:
 158 0022 8111      		cpse r24,__zero_reg__
 159 0024 00C0      		rjmp .L7
 160 0026 82E0      		ldi r24,lo8(2)
 161 0028 00C0      		rjmp .L5
 162               	.L7:
 163 002a 81E0      		ldi r24,lo8(1)
 164               	.L5:
 166               	.LM7:
 167 002c 9091 0000 		lds r25,volflags
 168 0030 892B      		or r24,r25
 169 0032 8093 0000 		sts volflags,r24
 170               	.L1:
 171 0036 0895      		ret
 176               	.Lscope1:
 179               	key.part.0:
 637:yack.c        **** /*! 
 181               	.LM8:
 182               	.LFBB2:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 679:yack.c        ****         {
 188               	.LM9:
 189 0038 8091 0000 		lds r24,volflags
 190 003c 84FF      		sbrs r24,4
 191 003e 00C0      		rjmp .L10
 681:yack.c        ****             TCCR0B = 0;
 193               	.LM10:
 194 0040 1ABC      		out 0x2a,__zero_reg__
 682:yack.c        ****         }
 196               	.LM11:
 197 0042 13BE      		out 0x33,__zero_reg__
 198               	.L10:
 685:yack.c        ****         {
 200               	.LM12:
 201 0044 8091 0000 		lds r24,volflags
 202 0048 85FF      		sbrs r24,5
 203 004a 00C0      		rjmp .L9
 687:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 205               	.LM13:
 206 004c 8091 0000 		lds r24,yackflags
 207 0050 86FF      		sbrs r24,6
 208 0052 00C0      		rjmp .L12
 688:yack.c        ****             else
 210               	.LM14:
 211 0054 C59A      		sbi 0x18,5
 212 0056 0895      		ret
 213               	.L12:
 690:yack.c        ****         }
 215               	.LM15:
 216 0058 C598      		cbi 0x18,5
 217               	.L9:
 218 005a 0895      		ret
 220               	.Lscope2:
 223               	yackinhibit.part.3:
 349:yack.c        **** /*! 
 225               	.LM16:
 226               	.LFBB3:
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
 371:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 232               	.LM17:
 233 005c C098      		cbi 0x18,0
 373:yack.c        ****         key(UP);
 235               	.LM18:
 236 005e 8091 0000 		lds r24,yackflags
 237 0062 982F      		mov r25,r24
 238 0064 9073      		andi r25,lo8(48)
 239 0066 8091 0000 		lds r24,volflags
 240 006a 8F7C      		andi r24,lo8(-49)
 241 006c 892B      		or r24,r25
 242 006e 8093 0000 		sts volflags,r24
 243               	.LBB23:
 244               	.LBB24:
 245 0072 00C0      		rjmp key.part.0
 246               	.LBE24:
 247               	.LBE23:
 249               	.Lscope3:
 252               	key.constprop.4:
 637:yack.c        **** /*! 
 254               	.LM19:
 255               	.LFBB4:
 256               	/* prologue: function */
 257               	/* frame size = 0 */
 258               	/* stack size = 0 */
 259               	.L__stack_usage = 0
 654:yack.c        ****         {
 261               	.LM20:
 262 0074 8091 0000 		lds r24,volflags
 263 0078 84FF      		sbrs r24,4
 264 007a 00C0      		rjmp .L21
 656:yack.c        ****             OCR0B = ctcvalue;
 266               	.LM21:
 267 007c 8091 0000 		lds r24,ctcvalue
 268 0080 89BD      		out 0x29,r24
 657:yack.c        ****             
 270               	.LM22:
 271 0082 8091 0000 		lds r24,ctcvalue
 272 0086 88BD      		out 0x28,r24
 660:yack.c        ****             
 274               	.LM23:
 275 0088 8AB5      		in r24,0x2a
 276 008a 8261      		ori r24,lo8(18)
 277 008c 8ABD      		out 0x2a,r24
 663:yack.c        ****         }
 279               	.LM24:
 280 008e 82E0      		ldi r24,lo8(2)
 281 0090 83BF      		out 0x33,r24
 282               	.L21:
 666:yack.c        ****         {
 284               	.LM25:
 285 0092 8091 0000 		lds r24,volflags
 286 0096 85FF      		sbrs r24,5
 287 0098 00C0      		rjmp .L20
 668:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 289               	.LM26:
 290 009a 8091 0000 		lds r24,yackflags
 291 009e 86FF      		sbrs r24,6
 292 00a0 00C0      		rjmp .L23
 669:yack.c        ****             else
 294               	.LM27:
 295 00a2 C598      		cbi 0x18,5
 296 00a4 0895      		ret
 297               	.L23:
 671:yack.c        ****         }
 299               	.LM28:
 300 00a6 C59A      		sbi 0x18,5
 301               	.L20:
 302 00a8 0895      		ret
 304               	.Lscope4:
 306               	.global	__vector_2
 308               	__vector_2:
 268:yack.c        ****     // Nothing to do here. All we want is to wake up..
 310               	.LM29:
 311               	.LFBB5:
 312 00aa 1F92      		push r1
 313 00ac 0F92      		push r0
 314 00ae 0FB6      		in r0,__SREG__
 315 00b0 0F92      		push r0
 316 00b2 1124      		clr __zero_reg__
 317               	/* prologue: Signal */
 318               	/* frame size = 0 */
 319               	/* stack size = 3 */
 320               	.L__stack_usage = 3
 321               	/* epilogue start */
 270:yack.c        **** 
 323               	.LM30:
 324 00b4 0F90      		pop r0
 325 00b6 0FBE      		out __SREG__,r0
 326 00b8 0F90      		pop r0
 327 00ba 1F90      		pop r1
 328 00bc 1895      		reti
 330               	.Lscope5:
 333               	.global	yackpower
 335               	yackpower:
 288:yack.c        ****     static uint32_t shdntimer=0;
 337               	.LM31:
 338               	.LFBB6:
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 0 */
 342               	.L__stack_usage = 0
 291:yack.c        ****     {
 344               	.LM32:
 345 00be 8823      		tst r24
 346 00c0 01F0      		breq .L32
 293:yack.c        ****         {
 348               	.LM33:
 349 00c2 8091 0000 		lds r24,shdntimer.2031
 350 00c6 9091 0000 		lds r25,shdntimer.2031+1
 351 00ca A091 0000 		lds r26,shdntimer.2031+2
 352 00ce B091 0000 		lds r27,shdntimer.2031+3
 353 00d2 8037      		cpi r24,112
 354 00d4 27E1      		ldi r18,23
 355 00d6 9207      		cpc r25,r18
 356 00d8 A105      		cpc r26,__zero_reg__
 357 00da B105      		cpc r27,__zero_reg__
 358 00dc 01F0      		breq .L33
 359 00de 0196      		adiw r24,1
 360 00e0 A11D      		adc r26,__zero_reg__
 361 00e2 B11D      		adc r27,__zero_reg__
 362 00e4 8093 0000 		sts shdntimer.2031,r24
 363 00e8 9093 0000 		sts shdntimer.2031+1,r25
 364 00ec A093 0000 		sts shdntimer.2031+2,r26
 365 00f0 B093 0000 		sts shdntimer.2031+3,r27
 366 00f4 0895      		ret
 367               	.L33:
 368               	.LBB28:
 369               	.LBB29:
 295:yack.c        **** 
 371               	.LM34:
 372 00f6 1092 0000 		sts shdntimer.2031,__zero_reg__
 373 00fa 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 374 00fe 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 375 0102 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 297:yack.c        ****             sleep_bod_disable();
 377               	.LM35:
 378 0106 85B7      		in r24,0x35
 379 0108 877E      		andi r24,lo8(-25)
 380 010a 8061      		ori r24,lo8(16)
 381 010c 85BF      		out 0x35,r24
 382               	.LBB30:
 298:yack.c        ****             sleep_enable();
 384               	.LM36:
 385               	/* #APP */
 386               	 ;  298 "yack.c" 1
 387 010e 85B7      		in r24, 53
 388 0110 8468      		ori r24, 132
 389 0112 85BF      		out 53, r24
 390 0114 8B7F      		andi r24, -5
 391 0116 85BF      		out 53, r24
 392               	 ;  0 "" 2
 393               	/* #NOAPP */
 394               	.LBE30:
 299:yack.c        ****             sei();
 396               	.LM37:
 397 0118 85B7      		in r24,0x35
 398 011a 8062      		ori r24,lo8(32)
 399 011c 85BF      		out 0x35,r24
 300:yack.c        ****             sleep_cpu();
 401               	.LM38:
 402               	/* #APP */
 403               	 ;  300 "yack.c" 1
 404 011e 7894      		sei
 405               	 ;  0 "" 2
 301:yack.c        ****             cli();
 407               	.LM39:
 408               	 ;  301 "yack.c" 1
 409 0120 8895      		sleep
 410               		
 411               	 ;  0 "" 2
 302:yack.c        ****             
 413               	.LM40:
 414               	 ;  302 "yack.c" 1
 415 0122 F894      		cli
 416               	 ;  0 "" 2
 417               	/* #NOAPP */
 418 0124 0895      		ret
 419               	.L32:
 420               	.LBE29:
 421               	.LBE28:
 312:yack.c        ****     }
 423               	.LM41:
 424 0126 1092 0000 		sts shdntimer.2031,__zero_reg__
 425 012a 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 426 012e 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 427 0132 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 428 0136 0895      		ret
 433               	.Lscope6:
 435               	.global	yacksave
 437               	yacksave:
 331:yack.c        **** 	
 439               	.LM42:
 440               	.LFBB7:
 441               	/* prologue: function */
 442               	/* frame size = 0 */
 443               	/* stack size = 0 */
 444               	.L__stack_usage = 0
 333:yack.c        **** 	{	
 446               	.LM43:
 447 0138 8091 0000 		lds r24,volflags
 448 013c 82FF      		sbrs r24,2
 449 013e 00C0      		rjmp .L35
 450               	.LBB33:
 451               	.LBB34:
 336:yack.c        **** 		eeprom_write_word(&ctcstor, ctcvalue);
 453               	.LM44:
 454 0140 65EA      		ldi r22,lo8(-91)
 455 0142 80E0      		ldi r24,lo8(magic)
 456 0144 90E0      		ldi r25,hi8(magic)
 457 0146 00D0      		rcall eeprom_write_byte
 337:yack.c        **** 		eeprom_write_byte(&wpmstor, wpm);
 459               	.LM45:
 460 0148 6091 0000 		lds r22,ctcvalue
 461 014c 7091 0000 		lds r23,ctcvalue+1
 462 0150 80E0      		ldi r24,lo8(ctcstor)
 463 0152 90E0      		ldi r25,hi8(ctcstor)
 464 0154 00D0      		rcall eeprom_write_word
 338:yack.c        **** 		eeprom_write_byte(&flagstor, yackflags);
 466               	.LM46:
 467 0156 6091 0000 		lds r22,wpm
 468 015a 80E0      		ldi r24,lo8(wpmstor)
 469 015c 90E0      		ldi r25,hi8(wpmstor)
 470 015e 00D0      		rcall eeprom_write_byte
 339:yack.c        ****         eeprom_write_byte(&fwstor, farnsworth);
 472               	.LM47:
 473 0160 6091 0000 		lds r22,yackflags
 474 0164 80E0      		ldi r24,lo8(flagstor)
 475 0166 90E0      		ldi r25,hi8(flagstor)
 476 0168 00D0      		rcall eeprom_write_byte
 340:yack.c        **** 		
 478               	.LM48:
 479 016a 6091 0000 		lds r22,farnsworth
 480 016e 80E0      		ldi r24,lo8(fwstor)
 481 0170 90E0      		ldi r25,hi8(fwstor)
 482 0172 00D0      		rcall eeprom_write_byte
 342:yack.c        **** 	}
 484               	.LM49:
 485 0174 8091 0000 		lds r24,volflags
 486 0178 8B7F      		andi r24,lo8(-5)
 487 017a 8093 0000 		sts volflags,r24
 488               	.L35:
 489 017e 0895      		ret
 490               	.LBE34:
 491               	.LBE33:
 493               	.Lscope7:
 495               	.global	yackreset
 497               	yackreset:
 187:yack.c        **** 
 499               	.LM50:
 500               	.LFBB8:
 501               	/* prologue: function */
 502               	/* frame size = 0 */
 503               	/* stack size = 0 */
 504               	.L__stack_usage = 0
 189:yack.c        ****     wpm=DEFWPM; // Init to default speed
 506               	.LM51:
 507 0180 8DE4      		ldi r24,lo8(77)
 508 0182 90E0      		ldi r25,0
 509 0184 9093 0000 		sts ctcvalue+1,r25
 510 0188 8093 0000 		sts ctcvalue,r24
 190:yack.c        **** 	wpmcnt=(1200/YACKBEAT)/DEFWPM; // default speed
 512               	.LM52:
 513 018c 8FE0      		ldi r24,lo8(15)
 514 018e 8093 0000 		sts wpm,r24
 191:yack.c        ****     farnsworth=0; // No Farnsworth gap
 516               	.LM53:
 517 0192 80E1      		ldi r24,lo8(16)
 518 0194 90E0      		ldi r25,0
 519 0196 9093 0000 		sts wpmcnt+1,r25
 520 019a 8093 0000 		sts wpmcnt,r24
 192:yack.c        **** 	yackflags = FLAGDEFAULT;  
 522               	.LM54:
 523 019e 1092 0000 		sts farnsworth,__zero_reg__
 193:yack.c        **** 
 525               	.LM55:
 526 01a2 84E3      		ldi r24,lo8(52)
 527 01a4 8093 0000 		sts yackflags,r24
 195:yack.c        **** 	yacksave(); // Store them in EEPROM
 529               	.LM56:
 530 01a8 8091 0000 		lds r24,volflags
 531 01ac 8460      		ori r24,lo8(4)
 532 01ae 8093 0000 		sts volflags,r24
 196:yack.c        **** 
 534               	.LM57:
 535 01b2 00C0      		rjmp yacksave
 537               	.Lscope8:
 539               	.global	yackinit
 541               	yackinit:
 210:yack.c        **** 	
 543               	.LM58:
 544               	.LFBB9:
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 0 */
 548               	.L__stack_usage = 0
 215:yack.c        **** 	SETBIT (STDDR,STPIN);
 550               	.LM59:
 551 01b4 BD9A      		sbi 0x17,5
 216:yack.c        ****     SETBIT (CMDDDR,CMDPIN);
 553               	.LM60:
 554 01b6 B99A      		sbi 0x17,1
 217:yack.c        **** 	
 556               	.LM61:
 557 01b8 B89A      		sbi 0x17,0
 220:yack.c        **** 	SETBIT (KEYPORT,DAHPIN);
 559               	.LM62:
 560 01ba C39A      		sbi 0x18,3
 221:yack.c        **** 	SETBIT (BTNPORT,BTNPIN);
 562               	.LM63:
 563 01bc C49A      		sbi 0x18,4
 222:yack.c        **** 	
 565               	.LM64:
 566 01be C29A      		sbi 0x18,2
 224:yack.c        **** 	
 568               	.LM65:
 569 01c0 80E0      		ldi r24,lo8(magic)
 570 01c2 90E0      		ldi r25,hi8(magic)
 571 01c4 00D0      		rcall eeprom_read_byte
 226:yack.c        **** 	{
 573               	.LM66:
 574 01c6 853A      		cpi r24,lo8(-91)
 575 01c8 01F4      		brne .L42
 228:yack.c        **** 		wpm = eeprom_read_byte(&wpmstor); // Retrieve last wpm setting
 577               	.LM67:
 578 01ca 80E0      		ldi r24,lo8(ctcstor)
 579 01cc 90E0      		ldi r25,hi8(ctcstor)
 580 01ce 00D0      		rcall eeprom_read_word
 581 01d0 9093 0000 		sts ctcvalue+1,r25
 582 01d4 8093 0000 		sts ctcvalue,r24
 229:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate speed
 584               	.LM68:
 585 01d8 80E0      		ldi r24,lo8(wpmstor)
 586 01da 90E0      		ldi r25,hi8(wpmstor)
 587 01dc 00D0      		rcall eeprom_read_byte
 588 01de 8093 0000 		sts wpm,r24
 230:yack.c        **** 		farnsworth = eeprom_read_byte(&fwstor); // Retrieve last wpm setting	
 590               	.LM69:
 591 01e2 682F      		mov r22,r24
 592 01e4 70E0      		ldi r23,0
 593 01e6 80EF      		ldi r24,lo8(-16)
 594 01e8 90E0      		ldi r25,0
 595 01ea 00D0      		rcall __divmodhi4
 596 01ec 7093 0000 		sts wpmcnt+1,r23
 597 01f0 6093 0000 		sts wpmcnt,r22
 231:yack.c        **** 		yackflags = eeprom_read_byte(&flagstor); // Retrieve last flags	
 599               	.LM70:
 600 01f4 80E0      		ldi r24,lo8(fwstor)
 601 01f6 90E0      		ldi r25,hi8(fwstor)
 602 01f8 00D0      		rcall eeprom_read_byte
 603 01fa 8093 0000 		sts farnsworth,r24
 232:yack.c        **** 	}
 605               	.LM71:
 606 01fe 80E0      		ldi r24,lo8(flagstor)
 607 0200 90E0      		ldi r25,hi8(flagstor)
 608 0202 00D0      		rcall eeprom_read_byte
 609 0204 8093 0000 		sts yackflags,r24
 610 0208 00C0      		rjmp .L43
 611               	.L42:
 236:yack.c        **** 	}	
 613               	.LM72:
 614 020a 00D0      		rcall yackreset
 615               	.L43:
 616               	.LBB35:
 617               	.LBB36:
 618 020c 00D0      		rcall yackinhibit.part.3
 619               	.LBE36:
 620               	.LBE35:
 243:yack.c        ****     GIMSK |= (1<<PCIE);  // Enable pin change interrupt
 622               	.LM73:
 623 020e 85B3      		in r24,0x15
 624 0210 8C61      		ori r24,lo8(28)
 625 0212 85BB      		out 0x15,r24
 244:yack.c        ****     
 627               	.LM74:
 628 0214 8BB7      		in r24,0x3b
 629 0216 8062      		ori r24,lo8(32)
 630 0218 8BBF      		out 0x3b,r24
 252:yack.c        ****     TCCR1 |= (1<<CTC1) | 0b00000111 ; // Clear Timer on match, prescale ck by 64
 632               	.LM75:
 633 021a 8EE4      		ldi r24,lo8(78)
 634 021c 8DBD      		out 0x2d,r24
 253:yack.c        ****     OCR1A = 1; // CTC mode does not create an overflow so we use OCR1A
 636               	.LM76:
 637 021e 80B7      		in r24,0x30
 638 0220 8768      		ori r24,lo8(-121)
 639 0222 80BF      		out 0x30,r24
 254:yack.c        ****     
 641               	.LM77:
 642 0224 81E0      		ldi r24,lo8(1)
 643 0226 8EBD      		out 0x2e,r24
 644 0228 0895      		ret
 646               	.Lscope9:
 649               	.global	yackinhibit
 651               	yackinhibit:
 359:yack.c        **** 	
 653               	.LM78:
 654               	.LFBB10:
 655               	/* prologue: function */
 656               	/* frame size = 0 */
 657               	/* stack size = 0 */
 658               	.L__stack_usage = 0
 361:yack.c        **** 	{
 660               	.LM79:
 661 022a 8823      		tst r24
 662 022c 01F0      		breq .L45
 363:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 664               	.LM80:
 665 022e C09A      		sbi 0x18,0
 365:yack.c        **** 	}
 667               	.LM81:
 668 0230 8091 0000 		lds r24,volflags
 669 0234 8F7C      		andi r24,lo8(-49)
 670 0236 8061      		ori r24,lo8(16)
 671 0238 8093 0000 		sts volflags,r24
 672 023c 0895      		ret
 673               	.L45:
 674 023e 00C0      		rjmp yackinhibit.part.3
 676               	.Lscope10:
 681               	.global	yackuser
 683               	yackuser:
 395:yack.c        **** 	
 685               	.LM82:
 686               	.LFBB11:
 687               	/* prologue: function */
 688               	/* frame size = 0 */
 689               	/* stack size = 0 */
 690               	.L__stack_usage = 0
 691 0240 962F      		mov r25,r22
 398:yack.c        **** 	{
 693               	.LM83:
 694 0242 8130      		cpi r24,lo8(1)
 695 0244 01F4      		brne .L49
 400:yack.c        **** 			return (eeprom_read_word(&user1));
 697               	.LM84:
 698 0246 6130      		cpi r22,lo8(1)
 699 0248 01F4      		brne .L50
 401:yack.c        **** 		else if (nr == 2)
 701               	.LM85:
 702 024a 80E0      		ldi r24,lo8(user1)
 703 024c 90E0      		ldi r25,hi8(user1)
 704 024e 00C0      		rjmp .L57
 705               	.L50:
 402:yack.c        **** 			return (eeprom_read_word(&user2));
 707               	.LM86:
 708 0250 6230      		cpi r22,lo8(2)
 709 0252 01F4      		brne .L51
 403:yack.c        **** 	}
 711               	.LM87:
 712 0254 80E0      		ldi r24,lo8(user2)
 713 0256 90E0      		ldi r25,hi8(user2)
 714               	.L57:
 715 0258 00C0      		rjmp eeprom_read_word
 716               	.L49:
 406:yack.c        **** 	{
 718               	.LM88:
 719 025a 8230      		cpi r24,lo8(2)
 720 025c 01F4      		brne .L51
 721 025e BA01      		movw r22,r20
 409:yack.c        **** 			eeprom_write_word(&user1, content);
 723               	.LM89:
 724 0260 9130      		cpi r25,lo8(1)
 725 0262 01F4      		brne .L52
 410:yack.c        **** 		else if (nr == 2)
 727               	.LM90:
 728 0264 80E0      		ldi r24,lo8(user1)
 729 0266 90E0      		ldi r25,hi8(user1)
 730 0268 00C0      		rjmp .L56
 731               	.L52:
 411:yack.c        **** 			eeprom_write_word(&user2, content);
 733               	.LM91:
 734 026a 9230      		cpi r25,lo8(2)
 735 026c 01F4      		brne .L51
 412:yack.c        **** 	}
 737               	.LM92:
 738 026e 80E0      		ldi r24,lo8(user2)
 739 0270 90E0      		ldi r25,hi8(user2)
 740               	.L56:
 741 0272 00D0      		rcall eeprom_write_word
 742               	.L51:
 417:yack.c        **** 
 744               	.LM93:
 745 0274 80E0      		ldi r24,0
 746 0276 90E0      		ldi r25,0
 747 0278 0895      		ret
 749               	.Lscope11:
 751               	.global	yackwpm
 753               	yackwpm:
 430:yack.c        ****     
 755               	.LM94:
 756               	.LFBB12:
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 0 */
 760               	.L__stack_usage = 0
 432:yack.c        ****     
 762               	.LM95:
 763 027a 8091 0000 		lds r24,wpm
 434:yack.c        **** 
 765               	.LM96:
 766 027e 90E0      		ldi r25,0
 767 0280 0895      		ret
 769               	.Lscope12:
 771               	.global	yackbeat
 773               	yackbeat:
 493:yack.c        ****     while((TIFR & (1<<OCF1A)) == 0); // Wait for Timeout
 775               	.LM97:
 776               	.LFBB13:
 777               	/* prologue: function */
 778               	/* frame size = 0 */
 779               	/* stack size = 0 */
 780               	.L__stack_usage = 0
 781               	.L60:
 494:yack.c        ****     TIFR |= (1<<OCF1A);                // Reset output compare flag
 783               	.LM98:
 784 0282 08B6      		in __tmp_reg__,0x38
 785 0284 06FE      		sbrs __tmp_reg__,6
 786 0286 00C0      		rjmp .L60
 495:yack.c        **** }
 788               	.LM99:
 789 0288 88B7      		in r24,0x38
 790 028a 8064      		ori r24,lo8(64)
 791 028c 88BF      		out 0x38,r24
 792 028e 0895      		ret
 794               	.Lscope13:
 797               	.global	yackpitch
 799               	yackpitch:
 510:yack.c        **** 	if (dir == UP)
 801               	.LM100:
 802               	.LFBB14:
 803               	/* prologue: function */
 804               	/* frame size = 0 */
 805               	/* stack size = 0 */
 806               	.L__stack_usage = 0
 807 0290 2091 0000 		lds r18,ctcvalue
 808 0294 3091 0000 		lds r19,ctcvalue+1
 511:yack.c        **** 		ctcvalue--;
 810               	.LM101:
 811 0298 8130      		cpi r24,lo8(1)
 812 029a 01F4      		brne .L64
 512:yack.c        **** 	if (dir == DOWN)
 814               	.LM102:
 815 029c 2150      		subi r18,1
 816 029e 3109      		sbc r19,__zero_reg__
 817 02a0 00C0      		rjmp .L68
 818               	.L64:
 513:yack.c        **** 		ctcvalue++;
 820               	.LM103:
 821 02a2 8230      		cpi r24,lo8(2)
 822 02a4 01F4      		brne .L65
 514:yack.c        **** 	
 824               	.LM104:
 825 02a6 2F5F      		subi r18,-1
 826 02a8 3F4F      		sbci r19,-1
 827               	.L68:
 828 02aa 3093 0000 		sts ctcvalue+1,r19
 829 02ae 2093 0000 		sts ctcvalue,r18
 830               	.L65:
 516:yack.c        **** 		ctcvalue = MAXCTC;
 832               	.LM105:
 833 02b2 8091 0000 		lds r24,ctcvalue
 834 02b6 9091 0000 		lds r25,ctcvalue+1
 835 02ba 8897      		sbiw r24,40
 836 02bc 00F4      		brsh .L66
 517:yack.c        **** 	
 838               	.LM106:
 839 02be 88E2      		ldi r24,lo8(40)
 840 02c0 90E0      		ldi r25,0
 841 02c2 9093 0000 		sts ctcvalue+1,r25
 842 02c6 8093 0000 		sts ctcvalue,r24
 843               	.L66:
 519:yack.c        **** 		ctcvalue = MINCTC;
 845               	.LM107:
 846 02ca 8091 0000 		lds r24,ctcvalue
 847 02ce 9091 0000 		lds r25,ctcvalue+1
 848 02d2 8C39      		cpi r24,-100
 849 02d4 9105      		cpc r25,__zero_reg__
 850 02d6 00F0      		brlo .L67
 520:yack.c        **** 	
 852               	.LM108:
 853 02d8 8BE9      		ldi r24,lo8(-101)
 854 02da 90E0      		ldi r25,0
 855 02dc 9093 0000 		sts ctcvalue+1,r25
 856 02e0 8093 0000 		sts ctcvalue,r24
 857               	.L67:
 522:yack.c        **** 	
 859               	.LM109:
 860 02e4 8091 0000 		lds r24,volflags
 861 02e8 8460      		ori r24,lo8(4)
 862 02ea 8093 0000 		sts volflags,r24
 863 02ee 0895      		ret
 865               	.Lscope14:
 868               	.global	yackmode
 870               	yackmode:
 565:yack.c        **** 
 872               	.LM110:
 873               	.LFBB15:
 874               	/* prologue: function */
 875               	/* frame size = 0 */
 876               	/* stack size = 0 */
 877               	.L__stack_usage = 0
 568:yack.c        **** 	
 879               	.LM111:
 880 02f0 9091 0000 		lds r25,yackflags
 881 02f4 937F      		andi r25,lo8(-13)
 882 02f6 892B      		or r24,r25
 883 02f8 8093 0000 		sts yackflags,r24
 570:yack.c        **** 
 885               	.LM112:
 886 02fc 8091 0000 		lds r24,volflags
 887 0300 8460      		ori r24,lo8(4)
 888 0302 8093 0000 		sts volflags,r24
 889 0306 0895      		ret
 891               	.Lscope15:
 894               	.global	yackflag
 896               	yackflag:
 583:yack.c        ****     return yackflags & flag;
 898               	.LM113:
 899               	.LFBB16:
 900               	/* prologue: function */
 901               	/* frame size = 0 */
 902               	/* stack size = 0 */
 903               	.L__stack_usage = 0
 584:yack.c        **** }
 905               	.LM114:
 906 0308 9091 0000 		lds r25,yackflags
 585:yack.c        **** 
 908               	.LM115:
 909 030c 8923      		and r24,r25
 910 030e 0895      		ret
 912               	.Lscope16:
 915               	.global	yacktoggle
 917               	yacktoggle:
 600:yack.c        ****     
 919               	.LM116:
 920               	.LFBB17:
 921               	/* prologue: function */
 922               	/* frame size = 0 */
 923               	/* stack size = 0 */
 924               	.L__stack_usage = 0
 602:yack.c        ****     volflags |= DIRTYFLAG;  // Set the dirty flag	
 926               	.LM117:
 927 0310 9091 0000 		lds r25,yackflags
 928 0314 8927      		eor r24,r25
 929 0316 8093 0000 		sts yackflags,r24
 603:yack.c        **** 
 931               	.LM118:
 932 031a 8091 0000 		lds r24,volflags
 933 031e 8460      		ori r24,lo8(4)
 934 0320 8093 0000 		sts volflags,r24
 935 0324 0895      		ret
 937               	.Lscope17:
 940               	.global	yackdelay
 942               	yackdelay:
 726:yack.c        **** 	
 944               	.LM119:
 945               	.LFBB18:
 946 0326 CF93      		push r28
 947 0328 DF93      		push r29
 948               	/* prologue: function */
 949               	/* frame size = 0 */
 950               	/* stack size = 2 */
 951               	.L__stack_usage = 2
 952 032a C82F      		mov r28,r24
 953               	.L73:
 731:yack.c        **** 	{
 955               	.LM120:
 956 032c CC23      		tst r28
 957 032e 01F0      		breq .L77
 733:yack.c        **** 		while (x--)    
 959               	.LM121:
 960 0330 D091 0000 		lds r29,wpmcnt
 961               	.L74:
 734:yack.c        **** 			yackbeat();
 963               	.LM122:
 964 0334 DD23      		tst r29
 965 0336 01F0      		breq .L78
 735:yack.c        **** 	}
 967               	.LM123:
 968 0338 00D0      		rcall yackbeat
 969 033a D150      		subi r29,lo8(-(-1))
 970 033c 00C0      		rjmp .L74
 971               	.L78:
 972 033e C150      		subi r28,lo8(-(-1))
 973 0340 00C0      		rjmp .L73
 974               	.L77:
 975               	/* epilogue start */
 738:yack.c        **** 
 977               	.LM124:
 978 0342 DF91      		pop r29
 979 0344 CF91      		pop r28
 980 0346 0895      		ret
 982               	.Lscope18:
 984               	.global	yackfarns
 986               	yackfarns:
 704:yack.c        **** 	
 988               	.LM125:
 989               	.LFBB19:
 990 0348 CF93      		push r28
 991 034a DF93      		push r29
 992               	/* prologue: function */
 993               	/* frame size = 0 */
 994               	/* stack size = 2 */
 995               	.L__stack_usage = 2
 706:yack.c        **** 	
 997               	.LM126:
 998 034c C091 0000 		lds r28,farnsworth
 999 0350 D0E0      		ldi r29,0
 1000               	.L80:
 708:yack.c        **** 	{
 1002               	.LM127:
 1003 0352 2097      		sbiw r28,0
 1004 0354 01F0      		breq .L82
 710:yack.c        **** 	}
 1006               	.LM128:
 1007 0356 81E0      		ldi r24,lo8(1)
 1008 0358 00D0      		rcall yackdelay
 1009 035a 2197      		sbiw r28,1
 1010 035c 00C0      		rjmp .L80
 1011               	.L82:
 1012               	/* epilogue start */
 713:yack.c        **** 
 1014               	.LM129:
 1015 035e DF91      		pop r29
 1016 0360 CF91      		pop r28
 1017 0362 0895      		ret
 1019               	.Lscope19:
 1022               	.global	yackplay
 1024               	yackplay:
 750:yack.c        **** 	
 1026               	.LM130:
 1027               	.LFBB20:
 1028 0364 CF93      		push r28
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               	/* stack size = 1 */
 1032               	.L__stack_usage = 1
 1033 0366 C82F      		mov r28,r24
 752:yack.c        **** 
 1035               	.LM131:
 1036 0368 00D0      		rcall key.constprop.4
 1037               	.LBB37:
 1038               	.LBB38:
 312:yack.c        ****     }
 1040               	.LM132:
 1041 036a 1092 0000 		sts shdntimer.2031,__zero_reg__
 1042 036e 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 1043 0372 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 1044 0376 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 1045               	.LBE38:
 1046               	.LBE37:
 760:yack.c        **** 	{
 1048               	.LM133:
 1049 037a C130      		cpi r28,lo8(1)
 1050 037c 01F0      		breq .L85
 1051 037e C230      		cpi r28,lo8(2)
 1052 0380 01F4      		brne .L84
 763:yack.c        **** 			break;
 1054               	.LM134:
 1055 0382 83E0      		ldi r24,lo8(3)
 1056 0384 00C0      		rjmp .L87
 1057               	.L85:
 767:yack.c        **** 			break;
 1059               	.LM135:
 1060 0386 81E0      		ldi r24,lo8(1)
 1061               	.L87:
 1062 0388 00D0      		rcall yackdelay
 1063               	.L84:
 1064               	/* epilogue start */
 773:yack.c        **** 
 1066               	.LM136:
 1067 038a CF91      		pop r28
 1068               	.LBB39:
 1069               	.LBB40:
 1070 038c 00C0      		rjmp key.part.0
 1071               	.LBE40:
 1072               	.LBE39:
 1074               	.Lscope20:
 1078               	.global	yackspeed
 1080               	yackspeed:
 447:yack.c        ****     
 1082               	.LM137:
 1083               	.LFBB21:
 1084               	/* prologue: function */
 1085               	/* frame size = 0 */
 1086               	/* stack size = 0 */
 1087               	.L__stack_usage = 0
 449:yack.c        ****     {
 1089               	.LM138:
 1090 038e 6130      		cpi r22,lo8(1)
 1091 0390 01F4      		brne .L89
 451:yack.c        ****             farnsworth--;
 1093               	.LM139:
 1094 0392 8130      		cpi r24,lo8(1)
 1095 0394 01F4      		brne .L90
 451:yack.c        ****             farnsworth--;
 1097               	.LM140:
 1098 0396 8091 0000 		lds r24,farnsworth
 1099 039a 8823      		tst r24
 1100 039c 01F0      		breq .L92
 452:yack.c        ****         
 1102               	.LM141:
 1103 039e 8150      		subi r24,lo8(-(-1))
 1104 03a0 00C0      		rjmp .L103
 1105               	.L90:
 454:yack.c        ****             farnsworth++;
 1107               	.LM142:
 1108 03a2 8230      		cpi r24,lo8(2)
 1109 03a4 01F4      		brne .L92
 454:yack.c        ****             farnsworth++;
 1111               	.LM143:
 1112 03a6 8091 0000 		lds r24,farnsworth
 1113 03aa 8F3F      		cpi r24,lo8(-1)
 1114 03ac 01F0      		breq .L92
 455:yack.c        ****     }
 1116               	.LM144:
 1117 03ae 8F5F      		subi r24,lo8(-(1))
 1118               	.L103:
 1119 03b0 8093 0000 		sts farnsworth,r24
 1120 03b4 00C0      		rjmp .L92
 1121               	.L89:
 1122 03b6 9091 0000 		lds r25,wpm
 459:yack.c        ****             wpm++;
 1124               	.LM145:
 1125 03ba 8130      		cpi r24,lo8(1)
 1126 03bc 01F4      		brne .L93
 459:yack.c        ****             wpm++;
 1128               	.LM146:
 1129 03be 9233      		cpi r25,lo8(50)
 1130 03c0 00F4      		brsh .L95
 460:yack.c        ****         
 1132               	.LM147:
 1133 03c2 9F5F      		subi r25,lo8(-(1))
 1134 03c4 00C0      		rjmp .L102
 1135               	.L93:
 462:yack.c        ****             wpm--;
 1137               	.LM148:
 1138 03c6 8230      		cpi r24,lo8(2)
 1139 03c8 01F4      		brne .L95
 462:yack.c        ****             wpm--;
 1141               	.LM149:
 1142 03ca 9630      		cpi r25,lo8(6)
 1143 03cc 00F0      		brlo .L95
 463:yack.c        ****         
 1145               	.LM150:
 1146 03ce 9150      		subi r25,lo8(-(-1))
 1147               	.L102:
 1148 03d0 9093 0000 		sts wpm,r25
 1149               	.L95:
 465:yack.c        **** 
 1151               	.LM151:
 1152 03d4 6091 0000 		lds r22,wpm
 1153 03d8 70E0      		ldi r23,0
 1154 03da 80EF      		ldi r24,lo8(-16)
 1155 03dc 90E0      		ldi r25,0
 1156 03de 00D0      		rcall __divmodhi4
 1157 03e0 7093 0000 		sts wpmcnt+1,r23
 1158 03e4 6093 0000 		sts wpmcnt,r22
 1159               	.L92:
 469:yack.c        ****     
 1161               	.LM152:
 1162 03e8 8091 0000 		lds r24,volflags
 1163 03ec 8460      		ori r24,lo8(4)
 1164 03ee 8093 0000 		sts volflags,r24
 471:yack.c        ****     yackdelay(IEGLEN);	// Inter Element gap  
 1166               	.LM153:
 1167 03f2 81E0      		ldi r24,lo8(1)
 1168 03f4 00D0      		rcall yackplay
 472:yack.c        ****     yackplay(DAH);
 1170               	.LM154:
 1171 03f6 81E0      		ldi r24,lo8(1)
 1172 03f8 00D0      		rcall yackdelay
 473:yack.c        ****     yackdelay(ICGLEN);	// Inter Character gap  
 1174               	.LM155:
 1175 03fa 82E0      		ldi r24,lo8(2)
 1176 03fc 00D0      		rcall yackplay
 474:yack.c        ****     yackfarns(); // Additional Farnsworth delay
 1178               	.LM156:
 1179 03fe 83E0      		ldi r24,lo8(3)
 1180 0400 00D0      		rcall yackdelay
 475:yack.c        ****     
 1182               	.LM157:
 1183 0402 00C0      		rjmp yackfarns
 1185               	.Lscope21:
 1187               	.global	yackerror
 1189               	yackerror:
 618:yack.c        **** 	byte i;
 1191               	.LM158:
 1192               	.LFBB22:
 1193 0404 CF93      		push r28
 1194               	/* prologue: function */
 1195               	/* frame size = 0 */
 1196               	/* stack size = 1 */
 1197               	.L__stack_usage = 1
 618:yack.c        **** 	byte i;
 1199               	.LM159:
 1200 0406 C8E0      		ldi r28,lo8(8)
 1201               	.L105:
 623:yack.c        **** 		yackdelay(DITLEN);
 1203               	.LM160:
 1204 0408 81E0      		ldi r24,lo8(1)
 1205 040a 00D0      		rcall yackplay
 624:yack.c        **** 	}
 1207               	.LM161:
 1208 040c 81E0      		ldi r24,lo8(1)
 1209 040e 00D0      		rcall yackdelay
 1210 0410 C150      		subi r28,lo8(-(-1))
 621:yack.c        **** 	{
 1212               	.LM162:
 1213 0412 01F4      		brne .L105
 626:yack.c        **** 	
 1215               	.LM163:
 1216 0414 83E0      		ldi r24,lo8(3)
 1217               	/* epilogue start */
 628:yack.c        **** 
 1219               	.LM164:
 1220 0416 CF91      		pop r28
 626:yack.c        **** 	
 1222               	.LM165:
 1223 0418 00C0      		rjmp yackdelay
 1225               	.Lscope22:
 1228               	.global	yackctrlkey
 1230               	yackctrlkey:
 929:yack.c        **** 	
 930:yack.c        **** }
 931:yack.c        **** 
 932:yack.c        **** 
 933:yack.c        **** 
 934:yack.c        **** byte yackctrlkey(byte mode)
 935:yack.c        **** /*! 
 936:yack.c        ****  @brief     Scans for the Control key
 937:yack.c        ****  
 938:yack.c        ****  This function is regularly called at different points in the program. In a normal case
 939:yack.c        ****  it terminates instantly. When the command key is found to be closed, the routine idles
 940:yack.c        ****  until it is released again and returns a TRUE return value.
 941:yack.c        ****  
 942:yack.c        ****  If, during the period where the contact was closed one of the paddles was closed too,
 943:yack.c        ****  the wpm speed is changed and the keypress not interpreted as a Control request. 
 944:yack.c        **** 
 945:yack.c        ****  @param mode    TRUE if caller has taken care of command key press, FALSE if not
 946:yack.c        ****  @return        TRUE if a press of the command key is not yet handled. 
 947:yack.c        ****  
 948:yack.c        ****  @callergraph
 949:yack.c        ****  
 950:yack.c        ****  */
 951:yack.c        **** {
 1232               	.LM166:
 1233               	.LFBB23:
 1234 041a CF93      		push r28
 1235 041c DF93      		push r29
 1236               	/* prologue: function */
 1237               	/* frame size = 0 */
 1238               	/* stack size = 2 */
 1239               	.L__stack_usage = 2
 1240 041e D82F      		mov r29,r24
 952:yack.c        **** 	
 953:yack.c        **** 	byte volbfr;
 954:yack.c        **** 	
 955:yack.c        ****     volbfr = volflags; // Remember current volatile settings
 1242               	.LM167:
 1243 0420 C091 0000 		lds r28,volflags
 956:yack.c        ****     
 957:yack.c        **** 	if (!(BTNINP & (1<<BTNPIN))) // If command button is pressed
 1245               	.LM168:
 1246 0424 B299      		sbic 0x16,2
 1247 0426 00C0      		rjmp .L108
 958:yack.c        **** 	{
 959:yack.c        ****         
 960:yack.c        ****         volbfr |= CKLATCH; // Set control key latch
 1249               	.LM169:
 1250 0428 C860      		ori r28,lo8(8)
 961:yack.c        **** 		
 962:yack.c        **** 		// Apparently the control key has been pressed. To avoid bouncing
 963:yack.c        **** 		// We will now wait a short while and then busy wait until the key is
 964:yack.c        **** 		// released.
 965:yack.c        **** 		// Should we find that someone is keying the paddle, let him change
 966:yack.c        **** 		// the speed and pretend ctrl was never pressed in the first place..
 967:yack.c        **** 
 968:yack.c        **** 		yackinhibit(ON); // Stop keying, switch on sidetone.
 1252               	.LM170:
 1253 042a 81E0      		ldi r24,lo8(1)
 1254 042c 00D0      		rcall yackinhibit
 1255               	.LBB41:
 1256               	.LBB42:
 1258               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1260               	.LM171:
 1261 042e 83ED      		ldi r24,lo8(12499)
 1262 0430 90E3      		ldi r25,hi8(12499)
 1263 0432 0197      	1:	sbiw r24,1
 1264 0434 01F4      		brne 1b
 1265 0436 00C0      		rjmp .
 1266 0438 0000      		nop
 1267               	.L111:
 1268               	.LBE42:
 1269               	.LBE41:
 1271               	.Ltext2:
 969:yack.c        **** 		
 970:yack.c        **** 		_delay_ms(50);
 971:yack.c        **** 		
 972:yack.c        **** 		while(!(BTNINP & (1<<BTNPIN))) // Busy wait for release
 1273               	.LM172:
 1274 043a B299      		sbic 0x16,2
 1275 043c 00C0      		rjmp .L116
 973:yack.c        **** 		{
 974:yack.c        ****             
 975:yack.c        **** 			if (!( KEYINP & (1<<DITPIN))) // Someone pressing DIT paddle
 1277               	.LM173:
 1278 043e B399      		sbic 0x16,3
 1279 0440 00C0      		rjmp .L110
 976:yack.c        **** 			{
 977:yack.c        **** 				yackspeed(DOWN,WPMSPEED);
 1281               	.LM174:
 1282 0442 60E0      		ldi r22,0
 1283 0444 82E0      		ldi r24,lo8(2)
 1284 0446 00D0      		rcall yackspeed
 978:yack.c        ****                 volbfr &= ~(CKLATCH); // Ignore that control key was pressed
 1286               	.LM175:
 1287 0448 C77F      		andi r28,lo8(-9)
 979:yack.c        ****                 CLEARBIT(CMDPORT,CMDPIN); // Stop the command mode light since we're ignoring contr
 1289               	.LM176:
 1290 044a C098      		cbi 0x18,0
 1291               	.L110:
 980:yack.c        **** 			}	
 981:yack.c        **** 			
 982:yack.c        **** 			if (!( KEYINP & (1<<DAHPIN))) // Someone pressing DAH paddle
 1293               	.LM177:
 1294 044c B499      		sbic 0x16,4
 1295 044e 00C0      		rjmp .L111
 983:yack.c        **** 			{
 984:yack.c        **** 				yackspeed(UP,WPMSPEED);
 1297               	.LM178:
 1298 0450 60E0      		ldi r22,0
 1299 0452 81E0      		ldi r24,lo8(1)
 1300 0454 00D0      		rcall yackspeed
 985:yack.c        ****                 volbfr &= ~(CKLATCH);
 1302               	.LM179:
 1303 0456 C77F      		andi r28,lo8(-9)
 986:yack.c        ****                 CLEARBIT(CMDPORT,CMDPIN); // Stop the command mode light since we're ignoring contr
 1305               	.LM180:
 1306 0458 C098      		cbi 0x18,0
 1307 045a 00C0      		rjmp .L111
 1308               	.L116:
 1309               	.LBB43:
 1310               	.LBB44:
 1312               	.Ltext3:
 1314               	.LM181:
 1315 045c 83ED      		ldi r24,lo8(12499)
 1316 045e 90E3      		ldi r25,hi8(12499)
 1317 0460 0197      	1:	sbiw r24,1
 1318 0462 01F4      		brne 1b
 1319 0464 00C0      		rjmp .
 1320 0466 0000      		nop
 1321               	.LBE44:
 1322               	.LBE43:
 1324               	.Ltext4:
 987:yack.c        **** 			}	
 988:yack.c        **** 			
 989:yack.c        **** 		}
 990:yack.c        ****         
 991:yack.c        **** 		_delay_ms(50); // Trailing edge debounce
 992:yack.c        **** 		
 993:yack.c        ****         yacksave();	// In case we had a speed change	
 1326               	.LM182:
 1327 0468 00D0      		rcall yacksave
 1328               	.L108:
 994:yack.c        **** 		
 995:yack.c        **** 	}
 996:yack.c        **** 
 997:yack.c        ****     volflags = volbfr; // Restore previous state
 998:yack.c        **** 
 999:yack.c        ****     if (mode==TRUE) // Does caller want us to reset latch?
 1330               	.LM183:
 1331 046a D130      		cpi r29,lo8(1)
 1332 046c 01F0      		breq .L113
 997:yack.c        **** 
 1334               	.LM184:
 1335 046e C093 0000 		sts volflags,r28
 1336 0472 00C0      		rjmp .L114
 1337               	.L113:
1000:yack.c        ****     {
1001:yack.c        ****         volflags &= ~(CKLATCH);
 1339               	.LM185:
 1340 0474 8C2F      		mov r24,r28
 1341 0476 877F      		andi r24,lo8(-9)
 1342 0478 8093 0000 		sts volflags,r24
 1343               	.L114:
1002:yack.c        ****     }
1003:yack.c        ****     
1004:yack.c        ****     //yacksave(); // In case we had a speed change (Does NOT work if command is here - moved immedi
1005:yack.c        ****     
1006:yack.c        **** 	return((volbfr&CKLATCH)!=0); // Tell caller if we had a ctrl button press
1007:yack.c        **** 	
1008:yack.c        **** }
 1345               	.LM186:
 1346 047c C3FB      		bst r28,3
 1347 047e 8827      		clr r24
 1348 0480 80F9      		bld r24,0
 1349               	/* epilogue start */
 1350 0482 DF91      		pop r29
 1351 0484 CF91      		pop r28
 1352 0486 0895      		ret
 1357               	.Lscope23:
 1359               	.global	yacktune
 1361               	yacktune:
 537:yack.c        **** 	word timer = YACKSECS(TUNEDURATION);
 1363               	.LM187:
 1364               	.LFBB24:
 1365 0488 CF93      		push r28
 1366 048a DF93      		push r29
 1367               	/* prologue: function */
 1368               	/* frame size = 0 */
 1369               	/* stack size = 2 */
 1370               	.L__stack_usage = 2
 540:yack.c        **** 	
 1372               	.LM188:
 1373 048c 00D0      		rcall key.constprop.4
 1374 048e C0EA      		ldi r28,lo8(-96)
 1375 0490 DFE0      		ldi r29,lo8(15)
 1376               	.L118:
 542:yack.c        **** 	{
 1378               	.LM189:
 1379 0492 B399      		sbic 0x16,3
 1380 0494 00C0      		rjmp .L128
 1381               	.L119:
 1382               	/* epilogue start */
 549:yack.c        **** 
 1384               	.LM190:
 1385 0496 DF91      		pop r29
 1386 0498 CF91      		pop r28
 1387               	.LBB45:
 1388               	.LBB46:
 1389 049a 00C0      		rjmp key.part.0
 1390               	.L128:
 1391               	.LBE46:
 1392               	.LBE45:
 542:yack.c        **** 	{
 1394               	.LM191:
 1395 049c B49B      		sbis 0x16,4
 1396 049e 00C0      		rjmp .L119
 542:yack.c        **** 	{
 1398               	.LM192:
 1399 04a0 81E0      		ldi r24,lo8(1)
 1400 04a2 00D0      		rcall yackctrlkey
 1401 04a4 8111      		cpse r24,__zero_reg__
 1402 04a6 00C0      		rjmp .L119
 545:yack.c        **** 	}
 1404               	.LM193:
 1405 04a8 00D0      		rcall yackbeat
 1406 04aa 2197      		sbiw r28,1
 542:yack.c        **** 	{
 1408               	.LM194:
 1409 04ac 01F4      		brne .L118
 1410 04ae 00C0      		rjmp .L119
 1412               	.Lscope24:
 1415               	.global	yackchar
 1417               	yackchar:
 795:yack.c        **** 	byte	code=0x80; // 0x80 is an empty morse character (just eoc bit set)
 1419               	.LM195:
 1420               	.LFBB25:
 1421 04b0 CF93      		push r28
 1422               	/* prologue: function */
 1423               	/* frame size = 0 */
 1424               	/* stack size = 1 */
 1425               	.L__stack_usage = 1
 801:yack.c        **** 		code = pgm_read_byte(&morse[c-'0']); // Find it in the beginning of array
 1427               	.LM196:
 1428 04b2 90ED      		ldi r25,lo8(-48)
 1429 04b4 980F      		add r25,r24
 1430 04b6 9A30      		cpi r25,lo8(10)
 1431 04b8 00F4      		brsh .L141
 1432               	.LBB47:
 802:yack.c        ****     
 1434               	.LM197:
 1435 04ba E82F      		mov r30,r24
 1436 04bc F0E0      		ldi r31,0
 1437 04be E050      		subi r30,lo8(-(morse-48))
 1438 04c0 F040      		sbci r31,hi8(-(morse-48))
 1439               	/* #APP */
 1440               	 ;  802 "yack.c" 1
 1441 04c2 C491      		lpm r28, Z
 1442               		
 1443               	 ;  0 "" 2
 1444               	/* #NOAPP */
 1445 04c4 00C0      		rjmp .L130
 1446               	.L141:
 1447               	.LBE47:
 796:yack.c        **** 	byte 	i; // a counter
 1449               	.LM198:
 1450 04c6 C0E8      		ldi r28,lo8(-128)
 1451               	.L130:
 804:yack.c        **** 		code = pgm_read_byte(&morse[c-'a'+10]); // Find it from position 10
 1453               	.LM199:
 1454 04c8 9FE9      		ldi r25,lo8(-97)
 1455 04ca 980F      		add r25,r24
 1456 04cc 9A31      		cpi r25,lo8(26)
 1457 04ce 00F4      		brsh .L131
 1458               	.LBB48:
 805:yack.c        **** 	
 1460               	.LM200:
 1461 04d0 E82F      		mov r30,r24
 1462 04d2 F0E0      		ldi r31,0
 1463 04d4 E050      		subi r30,lo8(-(morse-87))
 1464 04d6 F040      		sbci r31,hi8(-(morse-87))
 1465               	/* #APP */
 1466               	 ;  805 "yack.c" 1
 1467 04d8 C491      		lpm r28, Z
 1468               		
 1469               	 ;  0 "" 2
 1470               	/* #NOAPP */
 1471               	.L131:
 1472               	.LBE48:
 807:yack.c        **** 		code = pgm_read_byte(&morse[c-'A'+10]); // Same as above
 1474               	.LM201:
 1475 04da 9FEB      		ldi r25,lo8(-65)
 1476 04dc 980F      		add r25,r24
 1477 04de 9A31      		cpi r25,lo8(26)
 1478 04e0 00F4      		brsh .L132
 1479               	.LBB49:
 808:yack.c        **** 	
 1481               	.LM202:
 1482 04e2 E82F      		mov r30,r24
 1483 04e4 F0E0      		ldi r31,0
 1484 04e6 E050      		subi r30,lo8(-(morse-55))
 1485 04e8 F040      		sbci r31,hi8(-(morse-55))
 1486               	/* #APP */
 1487               	 ;  808 "yack.c" 1
 1488 04ea C491      		lpm r28, Z
 1489               		
 1490               	 ;  0 "" 2
 1491               	/* #NOAPP */
 1492               	.L132:
 1493               	.LBE49:
 796:yack.c        **** 	byte 	i; // a counter
 1495               	.LM203:
 1496 04ec 20E0      		ldi r18,0
 1497 04ee 30E0      		ldi r19,0
 1498               	.L134:
 1499               	.LBB50:
 814:yack.c        **** 			code = pgm_read_byte(&morse[i+36]); // Map it to morse code
 1501               	.LM204:
 1502 04f0 F901      		movw r30,r18
 1503 04f2 E050      		subi r30,lo8(-(spechar))
 1504 04f4 F040      		sbci r31,hi8(-(spechar))
 1505               	/* #APP */
 1506               	 ;  814 "yack.c" 1
 1507 04f6 E491      		lpm r30, Z
 1508               		
 1509               	 ;  0 "" 2
 1510               	/* #NOAPP */
 1511               	.LBE50:
 1512 04f8 8E13      		cpse r24,r30
 1513 04fa 00C0      		rjmp .L133
 1514               	.LBB51:
 815:yack.c        **** 	
 1516               	.LM205:
 1517 04fc F901      		movw r30,r18
 1518 04fe E050      		subi r30,lo8(-(morse+36))
 1519 0500 F040      		sbci r31,hi8(-(morse+36))
 1520               	/* #APP */
 1521               	 ;  815 "yack.c" 1
 1522 0502 C491      		lpm r28, Z
 1523               		
 1524               	 ;  0 "" 2
 1525               	/* #NOAPP */
 1526               	.L133:
 1527 0504 2F5F      		subi r18,-1
 1528 0506 3F4F      		sbci r19,-1
 1529               	.LBE51:
 813:yack.c        **** 		if (c == pgm_read_byte(&spechar[i])) // Does it contain our character
 1531               	.LM206:
 1532 0508 2831      		cpi r18,24
 1533 050a 3105      		cpc r19,__zero_reg__
 1534 050c 01F4      		brne .L134
 817:yack.c        **** 		yackdelay(IWGLEN-ICGLEN); // ICG was already played after previous char
 1536               	.LM207:
 1537 050e 8032      		cpi r24,lo8(32)
 1538 0510 01F4      		brne .L136
 818:yack.c        **** 	else
 1540               	.LM208:
 1541 0512 84E0      		ldi r24,lo8(4)
 1542               	/* epilogue start */
 842:yack.c        **** 
 1544               	.LM209:
 1545 0514 CF91      		pop r28
 818:yack.c        **** 	else
 1547               	.LM210:
 1548 0516 00C0      		rjmp yackdelay
 1549               	.L140:
 823:yack.c        **** 				return;
 1551               	.LM211:
 1552 0518 80E0      		ldi r24,0
 1553 051a 00D0      		rcall yackctrlkey
 1554 051c 8111      		cpse r24,__zero_reg__
 1555 051e 00C0      		rjmp .L129
 826:yack.c        ****        			yackplay(DAH);      // ..then play a dash
 1557               	.LM212:
 1558 0520 C7FF      		sbrs r28,7
 1559 0522 00C0      		rjmp .L138
 827:yack.c        ****      		else				// MSB cleared ?
 1561               	.LM213:
 1562 0524 82E0      		ldi r24,lo8(2)
 1563               	.L143:
 829:yack.c        **** 			
 1565               	.LM214:
 1566 0526 00D0      		rcall yackplay
 831:yack.c        ****             
 1568               	.LM215:
 1569 0528 81E0      		ldi r24,lo8(1)
 1570 052a 00D0      		rcall yackdelay
 833:yack.c        ****   		}
 1572               	.LM216:
 1573 052c CC0F      		lsl r28
 1574               	.L136:
 821:yack.c        ****   		{
 1576               	.LM217:
 1577 052e C038      		cpi r28,lo8(-128)
 1578 0530 01F4      		brne .L140
 1579 0532 00C0      		rjmp .L144
 1580               	.L138:
 829:yack.c        **** 			
 1582               	.LM218:
 1583 0534 81E0      		ldi r24,lo8(1)
 1584 0536 00C0      		rjmp .L143
 1585               	.L144:
 836:yack.c        **** 
 1587               	.LM219:
 1588 0538 82E0      		ldi r24,lo8(2)
 1589 053a 00D0      		rcall yackdelay
 1590               	/* epilogue start */
 842:yack.c        **** 
 1592               	.LM220:
 1593 053c CF91      		pop r28
 838:yack.c        **** 
 1595               	.LM221:
 1596 053e 00C0      		rjmp yackfarns
 1597               	.L129:
 1598               	/* epilogue start */
 842:yack.c        **** 
 1600               	.LM222:
 1601 0540 CF91      		pop r28
 1602 0542 0895      		ret
 1607               	.Lscope25:
 1610               	.global	yackstring
 1612               	yackstring:
 856:yack.c        **** 	
 1614               	.LM223:
 1615               	.LFBB26:
 1616 0544 1F93      		push r17
 1617 0546 CF93      		push r28
 1618 0548 DF93      		push r29
 1619               	/* prologue: function */
 1620               	/* frame size = 0 */
 1621               	/* stack size = 3 */
 1622               	.L__stack_usage = 3
 1623 054a EC01      		movw r28,r24
 1624               	.L146:
 1625               	.LBB52:
 860:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 1627               	.LM224:
 1628 054c FE01      		movw r30,r28
 1629               	/* #APP */
 1630               	 ;  860 "yack.c" 1
 1631 054e 1491      		lpm r17, Z
 1632               		
 1633               	 ;  0 "" 2
 1634               	/* #NOAPP */
 1635               	.LBE52:
 1636 0550 1123      		tst r17
 1637 0552 01F0      		breq .L145
 860:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 1639               	.LM225:
 1640 0554 81E0      		ldi r24,lo8(1)
 1641 0556 00D0      		rcall yackctrlkey
 1642 0558 2196      		adiw r28,1
 1643 055a 8111      		cpse r24,__zero_reg__
 1644 055c 00C0      		rjmp .L145
 862:yack.c        **** 								// abort now if someone presses command key
 1646               	.LM226:
 1647 055e 812F      		mov r24,r17
 1648 0560 00D0      		rcall yackchar
 1649 0562 00C0      		rjmp .L146
 1650               	.L145:
 1651               	/* epilogue start */
 865:yack.c        **** 
 1653               	.LM227:
 1654 0564 DF91      		pop r29
 1655 0566 CF91      		pop r28
 1656 0568 1F91      		pop r17
 1657 056a 0895      		ret
 1662               	.Lscope26:
 1665               	.global	yacknumber
 1667               	yacknumber:
 879:yack.c        ****     
 1669               	.LM228:
 1670               	.LFBB27:
 1671 056c 1F93      		push r17
 1672 056e CF93      		push r28
 1673 0570 DF93      		push r29
 1674 0572 00D0      		rcall .
 1675 0574 00D0      		rcall .
 1676 0576 1F92      		push __zero_reg__
 1677 0578 CDB7      		in r28,__SP_L__
 1678 057a DEB7      		in r29,__SP_H__
 1679               	/* prologue: function */
 1680               	/* frame size = 5 */
 1681               	/* stack size = 8 */
 1682               	.L__stack_usage = 8
 882:yack.c        **** 	
 1684               	.LM229:
 1685 057c 10E0      		ldi r17,0
 886:yack.c        **** 		n /= 10;                // Divide by 10
 1687               	.LM230:
 1688 057e 2AE0      		ldi r18,lo8(10)
 1689 0580 30E0      		ldi r19,0
 1690               	.L151:
 884:yack.c        **** 	{
 1692               	.LM231:
 1693 0582 0097      		sbiw r24,0
 1694 0584 01F0      		breq .L153
 886:yack.c        **** 		n /= 10;                // Divide by 10
 1696               	.LM232:
 1697 0586 E1E0      		ldi r30,lo8(1)
 1698 0588 F0E0      		ldi r31,0
 1699 058a EC0F      		add r30,r28
 1700 058c FD1F      		adc r31,r29
 1701 058e E10F      		add r30,r17
 1702 0590 F11D      		adc r31,__zero_reg__
 1703 0592 B901      		movw r22,r18
 1704 0594 00D0      		rcall __udivmodhi4
 1705 0596 805D      		subi r24,lo8(-(48))
 1706 0598 8083      		st Z,r24
 887:yack.c        **** 	}
 1708               	.LM233:
 1709 059a CB01      		movw r24,r22
 886:yack.c        **** 		n /= 10;                // Divide by 10
 1711               	.LM234:
 1712 059c 1F5F      		subi r17,lo8(-(1))
 1713 059e 00C0      		rjmp .L151
 1714               	.L155:
 892:yack.c        ****         yackchar(buffer[--i]);
 1716               	.LM235:
 1717 05a0 81E0      		ldi r24,lo8(1)
 1718 05a2 00D0      		rcall yackctrlkey
 1719 05a4 8111      		cpse r24,__zero_reg__
 1720 05a6 00C0      		rjmp .L156
 893:yack.c        ****     }
 1722               	.LM236:
 1723 05a8 1150      		subi r17,lo8(-(-1))
 1724 05aa E1E0      		ldi r30,lo8(1)
 1725 05ac F0E0      		ldi r31,0
 1726 05ae EC0F      		add r30,r28
 1727 05b0 FD1F      		adc r31,r29
 1728 05b2 E10F      		add r30,r17
 1729 05b4 F11D      		adc r31,__zero_reg__
 1730 05b6 8081      		ld r24,Z
 1731 05b8 00D0      		rcall yackchar
 1732               	.L153:
 890:yack.c        ****     {
 1734               	.LM237:
 1735 05ba 1111      		cpse r17,__zero_reg__
 1736 05bc 00C0      		rjmp .L155
 1737               	.L156:
 896:yack.c        ****     
 1739               	.LM238:
 1740 05be 80E2      		ldi r24,lo8(32)
 1741               	/* epilogue start */
 898:yack.c        **** 
 1743               	.LM239:
 1744 05c0 0F90      		pop __tmp_reg__
 1745 05c2 0F90      		pop __tmp_reg__
 1746 05c4 0F90      		pop __tmp_reg__
 1747 05c6 0F90      		pop __tmp_reg__
 1748 05c8 0F90      		pop __tmp_reg__
 1749 05ca DF91      		pop r29
 1750 05cc CF91      		pop r28
 1751 05ce 1F91      		pop r17
 896:yack.c        ****     
 1753               	.LM240:
 1754 05d0 00C0      		rjmp yackchar
 1759               	.Lscope27:
 1762               	.global	yackiambic
 1764               	yackiambic:
1009:yack.c        **** 
1010:yack.c        **** 
1011:yack.c        **** 
1012:yack.c        **** static char morsechar(byte buffer)
1013:yack.c        **** /*! 
1014:yack.c        ****  @brief     Reverse maps a combination of dots and dashes to a character
1015:yack.c        ****  
1016:yack.c        ****  This routine is passed a sequence of dots and dashes in the format we use for morse
1017:yack.c        ****  character encoding (see top of this file). It looks up the corresponding character in
1018:yack.c        ****  the Flash table and returns it to the caller. 
1019:yack.c        ****  
1020:yack.c        ****  This is a private function.
1021:yack.c        ****  
1022:yack.c        ****  @param buffer    A character in YACK CW notation
1023:yack.c        ****  @return          The mapped character or /0 if no match was found  
1024:yack.c        ****  
1025:yack.c        ****  */
1026:yack.c        **** {
1027:yack.c        **** 	byte i;
1028:yack.c        **** 	
1029:yack.c        **** 	for(i=0;i<sizeof(morse);i++)
1030:yack.c        **** 	{
1031:yack.c        **** 		
1032:yack.c        **** 		if (pgm_read_byte(&morse[i]) == buffer)
1033:yack.c        **** 		{
1034:yack.c        **** 			if (i < 10) return ('0' + i); 		// First 10 chars are digits
1035:yack.c        **** 			if (i < 36) return ('A' + i - 10); 	// Then follow letters
1036:yack.c        **** 			return (pgm_read_byte(&spechar[i - 36])); // Then special chars
1037:yack.c        **** 		}
1038:yack.c        **** 		
1039:yack.c        **** 	}
1040:yack.c        **** 	
1041:yack.c        **** 	return '\0';
1042:yack.c        **** }
1043:yack.c        **** 
1044:yack.c        **** 
1045:yack.c        **** 
1046:yack.c        **** void yackmessage(byte function, byte msgnr)
1047:yack.c        **** /*! 
1048:yack.c        ****  @brief     Handles EEPROM stored CW messages (macros)
1049:yack.c        ****  
1050:yack.c        ****  When called in RECORD mode, the function records a message up to 100 characters and stores it in 
1051:yack.c        ****  EEPROM. The routine stops recording when timing out after DEFTIMEOUT seconds. Recording
1052:yack.c        ****  can be aborted using the control key. If more than 100 characters are recorded, the error prosign
1053:yack.c        ****  is sounded and recording starts from the beginning. After recording and timing out the message is 
1054:yack.c        ****  back once before it is stored. To erase a message, do not key one.
1055:yack.c        ****  
1056:yack.c        ****  When called in PLAY mode, the message is just played back. Playback can be aborted using the comma
1057:yack.c        ****  key.
1058:yack.c        ****  
1059:yack.c        ****  @param     function    RECORD or PLAY
1060:yack.c        ****  @param     msgnr       1 or 2 or 3 or 4
1061:yack.c        ****  @return    TRUE if all OK, FALSE if lock prevented message recording
1062:yack.c        ****  
1063:yack.c        ****  */
1064:yack.c        **** {
1065:yack.c        **** 	unsigned char	rambuffer[RBSIZE];  // Storage for the message
1066:yack.c        **** 	unsigned char	c;					// Work character
1067:yack.c        **** 	
1068:yack.c        **** 	word			extimer = 0;		// Detects end of message (10 sec)
1069:yack.c        **** 	
1070:yack.c        **** 	byte 			i = 0;       		// Pointer into RAM buffer
1071:yack.c        **** 	byte 			n;					// Generic counter
1072:yack.c        **** 	
1073:yack.c        **** 	if (function == RECORD)
1074:yack.c        **** 	{
1075:yack.c        **** 
1076:yack.c        **** 		extimer = YACKSECS(DEFTIMEOUT);	// 5 Second until message end
1077:yack.c        **** 	   	while(extimer--)	// Continue until we waited 10 seconds
1078:yack.c        ****    		{
1079:yack.c        **** 			if (yackctrlkey(TRUE)) return;
1080:yack.c        **** 			
1081:yack.c        **** 			if ((c = yackiambic(ON))) // Check for a character from the key
1082:yack.c        **** 			{
1083:yack.c        **** 				rambuffer[i++] = c; // Add that character to our buffer
1084:yack.c        **** 				extimer = YACKSECS(DEFTIMEOUT); // Reset End of message timer
1085:yack.c        **** 			}
1086:yack.c        **** 			
1087:yack.c        **** 			if (i>=RBSIZE) // End of buffer reached?
1088:yack.c        **** 			{
1089:yack.c        **** 				yackerror();
1090:yack.c        **** 				i = 0;
1091:yack.c        **** 			}
1092:yack.c        **** 			
1093:yack.c        **** 			yackbeat(); // 10 ms heartbeat
1094:yack.c        **** 		}	
1095:yack.c        **** 		
1096:yack.c        **** 		// Extimer has expired. Message has ended
1097:yack.c        **** 		
1098:yack.c        **** 		if(i) // Was anything received at all?
1099:yack.c        **** 		{
1100:yack.c        **** 			rambuffer[--i] = 0; // Add a \0 end marker over last space
1101:yack.c        **** 			
1102:yack.c        **** 			// Replay the message
1103:yack.c        **** 			//for (n=0;n<i;n++){
1104:yack.c        **** 			//	if (yackctrlkey(TRUE)) {return;} //Break to command mode without saving if command key presse
1105:yack.c        **** 			//	yackchar(rambuffer[n]);
1106:yack.c        **** 	        //    }
1107:yack.c        **** 			
1108:yack.c        **** 			// Store it in EEPROM
1109:yack.c        **** 			if (msgnr == 1)
1110:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer1,RBSIZE);
1111:yack.c        **** 			if (msgnr == 2)
1112:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer2,RBSIZE);
1113:yack.c        **** 			if (msgnr == 3)
1114:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer3,RBSIZE);
1115:yack.c        **** 			if (msgnr == 4)
1116:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer4,RBSIZE);
1117:yack.c        **** 		}
1118:yack.c        **** 		else
1119:yack.c        **** 			yackerror();
1120:yack.c        **** 	}
1121:yack.c        **** 	
1122:yack.c        **** 	
1123:yack.c        **** 	if (function == PLAY)
1124:yack.c        **** 	{
1125:yack.c        **** 		// Retrieve the message from EEPROM
1126:yack.c        **** 		if (msgnr == 1)
1127:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer1,RBSIZE);
1128:yack.c        **** 		if (msgnr == 2)
1129:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer2,RBSIZE);
1130:yack.c        **** 		if (msgnr == 3)
1131:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer3,RBSIZE);
1132:yack.c        **** 		if (msgnr == 4)
1133:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer4,RBSIZE);
1134:yack.c        **** 		
1135:yack.c        **** 		// Replay the message
1136:yack.c        **** 		for (n=0;(c=rambuffer[n]);n++){ // Read until end of message
1137:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
1138:yack.c        **** 			yackchar(c); // play it back 
1139:yack.c        **** 		}
1140:yack.c        **** 	}
1141:yack.c        **** }
1142:yack.c        **** 
1143:yack.c        **** char yackiambic(byte ctrl)
1144:yack.c        **** /*! 
1145:yack.c        ****  @brief     Finite state machine for the IAMBIC keyer
1146:yack.c        ****  
1147:yack.c        ****  If IAMBIC (squeeze) keying is requested, this routine, which usually terminates
1148:yack.c        ****  immediately needs to be called in regular intervals of YACKBEAT milliseconds.
1149:yack.c        ****  
1150:yack.c        ****  This can happen though an outside busy waiting loop or a counter mechanism.
1151:yack.c        ****  
1152:yack.c        ****  @param ctrl    ON if the keyer should recognize when a word ends. OFF if not.
1153:yack.c        ****  @return        The character if one was recognized, /0 if not
1154:yack.c        ****  
1155:yack.c        ****  */
1156:yack.c        **** {
 1766               	.LM241:
 1767               	.LFBB28:
 1768 05d2 CF93      		push r28
 1769               	/* prologue: function */
 1770               	/* frame size = 0 */
 1771               	/* stack size = 1 */
 1772               	.L__stack_usage = 1
1157:yack.c        **** 	
1158:yack.c        **** 	static enum FSMSTATE	fsms = IDLE;	// FSM state indicator
1159:yack.c        **** 	static 		word		timer;			// A countdown timer
1160:yack.c        **** 	static		byte		lastsymbol;		// The last symbol sent
1161:yack.c        **** 	static		byte		buffer = 0;		// A place to store a sent char
1162:yack.c        **** 	static		byte		bcntr = 0;		// Number of elements sent
1163:yack.c        **** 	static		byte		iwgflag = 0;	// Flag: Are we in interword gap?
1164:yack.c        ****     static      byte        ultimem = 0;    // Buffer for last keying status
1165:yack.c        **** 				char		retchar;		// The character to return to caller
1166:yack.c        **** 	
1167:yack.c        **** 	// This routine is called every YACKBEAT ms. It starts with idle mode where
1168:yack.c        **** 	// the morse key is polled. Once a contact close is sensed, the TX key is 
1169:yack.c        **** 	// closed, the sidetone oscillator is fired up and the FSM progresses
1170:yack.c        **** 	// to the next state (KEYED). There it waits for the timer to expire, 
1171:yack.c        **** 	// afterwards progressing to IEG (Inter Element Gap).
1172:yack.c        **** 	// Once the IEG has completed, processing returns to the IDLE state.
1173:yack.c        **** 	
1174:yack.c        **** 	// If the FSM remains in idle state long enough (one dash time), the
1175:yack.c        **** 	// character is assumed to be complete and a decoding is attempted. If
1176:yack.c        **** 	// succesful, the ascii code of the character is returned to the caller
1177:yack.c        **** 	
1178:yack.c        **** 	// If the FSM remains in idle state for another 4 dot times (7 dot times 
1179:yack.c        **** 	// altogether), we assume that the word has ended. A space char
1180:yack.c        **** 	// is transmitted in this case.
1181:yack.c        **** 	
1182:yack.c        **** 	if (timer) timer--; // Count down
 1774               	.LM242:
 1775 05d4 2091 0000 		lds r18,timer.2200
 1776 05d8 3091 0000 		lds r19,timer.2200+1
 1777 05dc 2115      		cp r18,__zero_reg__
 1778 05de 3105      		cpc r19,__zero_reg__
 1779 05e0 01F0      		breq .L158
 1781               	.LM243:
 1782 05e2 2150      		subi r18,1
 1783 05e4 3109      		sbc r19,__zero_reg__
 1784 05e6 3093 0000 		sts timer.2200+1,r19
 1785 05ea 2093 0000 		sts timer.2200,r18
 1786               	.L158:
1183:yack.c        **** 	
1184:yack.c        **** 	if (ctrl == OFF) iwgflag = 0; // No space detection
 1788               	.LM244:
 1789 05ee 8111      		cpse r24,__zero_reg__
 1790 05f0 00C0      		rjmp .L159
 1792               	.LM245:
 1793 05f2 1092 0000 		sts iwgflag.2204,__zero_reg__
 1794               	.L159:
1185:yack.c        **** 	
1186:yack.c        **** 	switch (fsms)
 1796               	.LM246:
 1797 05f6 8091 0000 		lds r24,fsms.2199
 1798 05fa 8130      		cpi r24,lo8(1)
 1799 05fc 01F4      		brne .+2
 1800 05fe 00C0      		rjmp .L161
 1801 0600 00F0      		brlo .L162
 1802 0602 8230      		cpi r24,lo8(2)
 1803 0604 01F4      		brne .+2
 1804 0606 00C0      		rjmp .L163
 1805 0608 00C0      		rjmp .L197
 1806               	.L162:
1187:yack.c        **** 	{
1188:yack.c        **** 			
1189:yack.c        **** 		case IDLE:
1190:yack.c        **** 			
1191:yack.c        **** 			keylatch();
 1808               	.LM247:
 1809 060a 00D0      		rcall keylatch
1192:yack.c        ****            
1193:yack.c        **** #ifdef POWERSAVE            
1194:yack.c        ****             
1195:yack.c        ****             yackpower(TRUE); // OK to go to sleep when here.
 1811               	.LM248:
 1812 060c 81E0      		ldi r24,lo8(1)
 1813 060e 00D0      		rcall yackpower
1196:yack.c        **** 
1197:yack.c        **** #endif            
1198:yack.c        ****             
1199:yack.c        ****             // Handle latching logic for various keyer modes
1200:yack.c        ****             switch (yackflags & MODE)
 1815               	.LM249:
 1816 0610 8091 0000 		lds r24,yackflags
 1817 0614 8C70      		andi r24,lo8(12)
 1818 0616 8430      		cpi r24,lo8(4)
 1819 0618 01F0      		breq .L165
 1820 061a 00F4      		brsh .L166
 1821 061c 8823      		tst r24
 1822 061e 01F0      		breq .L165
 1823 0620 00C0      		rjmp .L164
 1824               	.L166:
 1825 0622 8830      		cpi r24,lo8(8)
 1826 0624 01F0      		breq .L167
 1827 0626 8C30      		cpi r24,lo8(12)
 1828 0628 01F0      		breq .L168
 1829 062a 00C0      		rjmp .L164
 1830               	.L165:
1201:yack.c        ****             {
1202:yack.c        ****                 case IAMBICA:
1203:yack.c        ****                 case IAMBICB:
1204:yack.c        ****                     // When the paddle keys are squeezed, we need to ensure that
1205:yack.c        ****                     // dots and dashes are alternating. To do that, whe delete
1206:yack.c        ****                     // any latched paddle of the same kind that we just sent.
1207:yack.c        ****                     // However, we only do this ONCE
1208:yack.c        ****                     
1209:yack.c        ****                     volflags &= ~lastsymbol;
 1832               	.LM250:
 1833 062c 8091 0000 		lds r24,lastsymbol.2201
 1834 0630 8095      		com r24
 1835 0632 9091 0000 		lds r25,volflags
 1836 0636 8923      		and r24,r25
 1837 0638 8093 0000 		sts volflags,r24
1210:yack.c        ****                     lastsymbol = 0;
 1839               	.LM251:
 1840 063c 1092 0000 		sts lastsymbol.2201,__zero_reg__
1211:yack.c        ****                     break;                    
 1842               	.LM252:
 1843 0640 00C0      		rjmp .L164
 1844               	.L167:
1212:yack.c        ****                  
1213:yack.c        ****                 case ULTIMATIC:
1214:yack.c        ****                     // Ultimatic logic: The last paddle to be active will be repeated indefinitely
1215:yack.c        ****                     // In case the keyer is squeezed right out of idle mode, we just send a DAH 
1216:yack.c        ****                     if ((volflags & SQUEEZED) == SQUEEZED) // Squeezed?
 1846               	.LM253:
 1847 0642 8091 0000 		lds r24,volflags
 1848 0646 982F      		mov r25,r24
 1849 0648 9370      		andi r25,lo8(3)
 1850 064a 9330      		cpi r25,lo8(3)
 1851 064c 01F4      		brne .L169
1217:yack.c        ****                     {
1218:yack.c        ****                         if (ultimem)
 1853               	.LM254:
 1854 064e 9091 0000 		lds r25,ultimem.2205
 1855 0652 9923      		tst r25
 1856 0654 01F0      		breq .L198
1219:yack.c        ****                           volflags &= ~ultimem; // Opposite symbol from last one
 1858               	.LM255:
 1859 0656 9095      		com r25
 1860 0658 8923      		and r24,r25
 1861 065a 00C0      		rjmp .L199
 1862               	.L169:
1220:yack.c        ****                         else
1221:yack.c        ****                           volflags &= ~DITLATCH; // Reset the DIT latch
1222:yack.c        ****                     }
1223:yack.c        ****                     else
1224:yack.c        ****                     {
1225:yack.c        ****                         ultimem = volflags & SQUEEZED; // Remember the last single key
 1864               	.LM256:
 1865 065c 9093 0000 		sts ultimem.2205,r25
 1866 0660 00C0      		rjmp .L164
 1867               	.L168:
1226:yack.c        ****                     }
1227:yack.c        **** 
1228:yack.c        ****                     break;
1229:yack.c        ****                             
1230:yack.c        ****                 case DAHPRIO:            
1231:yack.c        ****                     // If both paddles pressed, DAH is given priority
1232:yack.c        ****                     if ((volflags & SQUEEZED) == SQUEEZED)
 1869               	.LM257:
 1870 0662 8091 0000 		lds r24,volflags
 1871 0666 982F      		mov r25,r24
 1872 0668 9370      		andi r25,lo8(3)
 1873 066a 9330      		cpi r25,lo8(3)
 1874 066c 01F4      		brne .L164
 1875               	.L198:
1233:yack.c        ****                     {
1234:yack.c        ****                         volflags &= ~DITLATCH; // Reset the DIT latch
 1877               	.LM258:
 1878 066e 8E7F      		andi r24,lo8(-2)
 1879               	.L199:
 1880 0670 8093 0000 		sts volflags,r24
 1881               	.L164:
1235:yack.c        ****                     }
1236:yack.c        ****                     break;
1237:yack.c        ****             }        
1238:yack.c        ****             
1239:yack.c        ****             
1240:yack.c        **** 			// The following handles the inter-character gap. When there are
1241:yack.c        **** 			// three (default) dot lengths of space after an element, the
1242:yack.c        **** 			// character is complete and can be returned to caller
1243:yack.c        **** 			if (timer == 0 && bcntr != 0) // Have we idled for 3 dots
 1883               	.LM259:
 1884 0674 8091 0000 		lds r24,timer.2200
 1885 0678 9091 0000 		lds r25,timer.2200+1
 1886 067c 892B      		or r24,r25
 1887 067e 01F0      		breq .+2
 1888 0680 00C0      		rjmp .L171
 1890               	.LM260:
 1891 0682 8091 0000 		lds r24,bcntr.2203
 1892 0686 8823      		tst r24
 1893 0688 01F4      		brne .+2
 1894 068a 00C0      		rjmp .L172
1244:yack.c        **** 				// and is there something to decode?
1245:yack.c        **** 			{
1246:yack.c        **** 				buffer = buffer << 1;	  // Make space for the termination bit
1247:yack.c        **** 				buffer |= 1;			  // The 1 on the right signals end
1248:yack.c        **** 				buffer = buffer << (7-bcntr); // Shift to left justify
 1896               	.LM261:
 1897 068c 9091 0000 		lds r25,buffer.2202
 1898 0690 990F      		lsl r25
 1899 0692 9160      		ori r25,lo8(1)
 1900 0694 27E0      		ldi r18,lo8(7)
 1901 0696 30E0      		ldi r19,0
 1902 0698 281B      		sub r18,r24
 1903 069a 3109      		sbc r19,__zero_reg__
 1904 069c 00C0      		rjmp 2f
 1905               		1:
 1906 069e 990F      		lsl r25
 1907               		2:
 1908 06a0 2A95      		dec r18
 1909 06a2 02F4      		brpl 1b
 1910 06a4 20E0      		ldi r18,0
 1911 06a6 30E0      		ldi r19,0
 1912               	.L177:
 1913 06a8 822F      		mov r24,r18
 1914               	.LBB61:
 1915               	.LBB62:
 1916               	.LBB63:
1032:yack.c        **** 		{
 1918               	.LM262:
 1919 06aa F901      		movw r30,r18
 1920 06ac E050      		subi r30,lo8(-(morse))
 1921 06ae F040      		sbci r31,hi8(-(morse))
 1922               	/* #APP */
 1923               	 ;  1032 "yack.c" 1
 1924 06b0 E491      		lpm r30, Z
 1925               		
 1926               	 ;  0 "" 2
 1927               	/* #NOAPP */
 1928               	.LBE63:
 1929 06b2 9E13      		cpse r25,r30
 1930 06b4 00C0      		rjmp .L173
1034:yack.c        **** 			if (i < 36) return ('A' + i - 10); 	// Then follow letters
 1932               	.LM263:
 1933 06b6 2A30      		cpi r18,lo8(10)
 1934 06b8 00F4      		brsh .L174
 1935 06ba 805D      		subi r24,lo8(-(48))
 1936 06bc 00C0      		rjmp .L175
 1937               	.L174:
1035:yack.c        **** 			return (pgm_read_byte(&spechar[i - 36])); // Then special chars
 1939               	.LM264:
 1940 06be 2432      		cpi r18,lo8(36)
 1941 06c0 00F4      		brsh .L176
 1942 06c2 895C      		subi r24,lo8(-(55))
 1943 06c4 00C0      		rjmp .L175
 1944               	.L176:
 1945               	.LBB64:
1036:yack.c        **** 		}
 1947               	.LM265:
 1948 06c6 F901      		movw r30,r18
 1949 06c8 E050      		subi r30,lo8(-(spechar-36))
 1950 06ca F040      		sbci r31,hi8(-(spechar-36))
 1951               	/* #APP */
 1952               	 ;  1036 "yack.c" 1
 1953 06cc 8491      		lpm r24, Z
 1954               		
 1955               	 ;  0 "" 2
 1956               	/* #NOAPP */
 1957 06ce 00C0      		rjmp .L175
 1958               	.L173:
 1959 06d0 2F5F      		subi r18,-1
 1960 06d2 3F4F      		sbci r19,-1
 1961               	.LBE64:
1029:yack.c        **** 	{
 1963               	.LM266:
 1964 06d4 2C33      		cpi r18,60
 1965 06d6 3105      		cpc r19,__zero_reg__
 1966 06d8 01F4      		brne .L177
1041:yack.c        **** }
 1968               	.LM267:
 1969 06da 80E0      		ldi r24,0
 1970               	.L175:
 1971               	.LBE62:
 1972               	.LBE61:
1249:yack.c        **** 				retchar = morsechar(buffer); // Attempt decoding
1250:yack.c        **** 				buffer = bcntr = 0;			// Clear buffer
 1974               	.LM268:
 1975 06dc 1092 0000 		sts bcntr.2203,__zero_reg__
 1976 06e0 1092 0000 		sts buffer.2202,__zero_reg__
1251:yack.c        **** 				timer = (IWGLEN - ICGLEN) * wpmcnt;	// If 4 further dots of gap,
 1978               	.LM269:
 1979 06e4 2091 0000 		lds r18,wpmcnt
 1980 06e8 3091 0000 		lds r19,wpmcnt+1
 1981 06ec 220F      		lsl r18
 1982 06ee 331F      		rol r19
 1983 06f0 220F      		lsl r18
 1984 06f2 331F      		rol r19
 1985 06f4 3093 0000 		sts timer.2200+1,r19
 1986 06f8 2093 0000 		sts timer.2200,r18
1252:yack.c        **** 				// this might be a Word gap.
1253:yack.c        **** 				iwgflag = 1;                // Signal we are waiting for IWG                          
 1988               	.LM270:
 1989 06fc 91E0      		ldi r25,lo8(1)
 1990 06fe 9093 0000 		sts iwgflag.2204,r25
1254:yack.c        **** 				return (retchar);			// and return decoded char
 1992               	.LM271:
 1993 0702 00C0      		rjmp .L160
 1994               	.L172:
1255:yack.c        **** 			}
1256:yack.c        **** 			
1257:yack.c        **** 			// This handles the Inter-word gap. Already 3 dots have been
1258:yack.c        **** 			// waited for, if 4 more follow, interpret this as a word end
1259:yack.c        **** 			if (timer == 0 && iwgflag) // Have we idled for 4+3 = 7 dots?
 1996               	.LM272:
 1997 0704 8091 0000 		lds r24,iwgflag.2204
 1998 0708 8823      		tst r24
 1999 070a 01F0      		breq .L171
1260:yack.c        **** 			{
1261:yack.c        **** 				iwgflag = 0;   // Clear Interword Gap flag
 2001               	.LM273:
 2002 070c 1092 0000 		sts iwgflag.2204,__zero_reg__
1262:yack.c        **** 				return (' ');  // And return a space
 2004               	.LM274:
 2005 0710 80E2      		ldi r24,lo8(32)
 2006 0712 00C0      		rjmp .L160
 2007               	.L171:
1263:yack.c        **** 			}
1264:yack.c        **** 			
1265:yack.c        **** 			// Now evaluate the latch and determine what to send next
1266:yack.c        **** 			if ( volflags & (DITLATCH | DAHLATCH)) // Anything in the latch?
 2009               	.LM275:
 2010 0714 C091 0000 		lds r28,volflags
 2011 0718 8C2F      		mov r24,r28
 2012 071a 8370      		andi r24,lo8(3)
 2013 071c 01F4      		brne .+2
 2014 071e 00C0      		rjmp .L197
1267:yack.c        **** 			{
1268:yack.c        **** 				iwgflag = 0; // No interword gap if dit or dah
 2016               	.LM276:
 2017 0720 1092 0000 		sts iwgflag.2204,__zero_reg__
1269:yack.c        ****                 bcntr++;	// Count that we will send something now
 2019               	.LM277:
 2020 0724 8091 0000 		lds r24,bcntr.2203
 2021 0728 8F5F      		subi r24,lo8(-(1))
 2022 072a 8093 0000 		sts bcntr.2203,r24
1270:yack.c        **** 				buffer = buffer << 1; // Make space for the new character
 2024               	.LM278:
 2025 072e 2091 0000 		lds r18,buffer.2202
 2026 0732 220F      		lsl r18
 2027 0734 2093 0000 		sts buffer.2202,r18
 2028 0738 8091 0000 		lds r24,wpmcnt
 2029 073c 9091 0000 		lds r25,wpmcnt+1
1271:yack.c        **** 				
1272:yack.c        **** 				if (volflags & DITLATCH) // Is it a dit?
 2031               	.LM279:
 2032 0740 C0FF      		sbrs r28,0
 2033 0742 00C0      		rjmp .L179
1273:yack.c        **** 				{
1274:yack.c        **** 					timer	= DITLEN * wpmcnt; // Duration = one dot time
 2035               	.LM280:
 2036 0744 9093 0000 		sts timer.2200+1,r25
 2037 0748 8093 0000 		sts timer.2200,r24
1275:yack.c        **** 					lastsymbol = DITLATCH; // Remember what we sent
 2039               	.LM281:
 2040 074c 81E0      		ldi r24,lo8(1)
 2041 074e 8093 0000 		sts lastsymbol.2201,r24
 2042 0752 00C0      		rjmp .L180
 2043               	.L179:
1276:yack.c        **** 				}
1277:yack.c        **** 				else // must be a DAH then..
1278:yack.c        **** 				{
1279:yack.c        **** 					timer	= DAHLEN * wpmcnt; // Duration = one dash time
 2045               	.LM282:
 2046 0754 63E0      		ldi r22,lo8(3)
 2047 0756 70E0      		ldi r23,0
 2048 0758 00D0      		rcall __mulhi3
 2049 075a 9093 0000 		sts timer.2200+1,r25
 2050 075e 8093 0000 		sts timer.2200,r24
1280:yack.c        **** 					lastsymbol = DAHLATCH; // Remember
 2052               	.LM283:
 2053 0762 82E0      		ldi r24,lo8(2)
 2054 0764 8093 0000 		sts lastsymbol.2201,r24
1281:yack.c        **** 					buffer |= 1; // set LSB to remember dash
 2056               	.LM284:
 2057 0768 2160      		ori r18,lo8(1)
 2058 076a 2093 0000 		sts buffer.2202,r18
 2059               	.L180:
1282:yack.c        **** 				}
1283:yack.c        **** 				
1284:yack.c        **** 				key(DOWN); // Switch on the side tone and TX
 2061               	.LM285:
 2062 076e 00D0      		rcall key.constprop.4
1285:yack.c        **** 				volflags &= ~(DITLATCH | DAHLATCH); // Reset both latches
 2064               	.LM286:
 2065 0770 CC7F      		andi r28,lo8(-4)
 2066 0772 C093 0000 		sts volflags,r28
1286:yack.c        **** 				
1287:yack.c        **** 				fsms 	= KEYED; // Change FSM state
 2068               	.LM287:
 2069 0776 81E0      		ldi r24,lo8(1)
 2070 0778 00C0      		rjmp .L200
 2071               	.L161:
 2072               	.LBB65:
 2073               	.LBB66:
 312:yack.c        ****     }
 2075               	.LM288:
 2076 077a 1092 0000 		sts shdntimer.2031,__zero_reg__
 2077 077e 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 2078 0782 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 2079 0786 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 2080               	.LBE66:
 2081               	.LBE65:
1288:yack.c        **** 			}
1289:yack.c        **** 			
1290:yack.c        **** 			break;
1291:yack.c        **** 			
1292:yack.c        **** 		case KEYED:
1293:yack.c        **** 
1294:yack.c        **** #ifdef POWERSAVE
1295:yack.c        ****  			
1296:yack.c        ****             yackpower(FALSE); // can not go to sleep when keyed
1297:yack.c        **** 
1298:yack.c        **** #endif
1299:yack.c        ****             
1300:yack.c        **** 			if ((yackflags & MODE) == IAMBICB) // If we are in IAMBIC B mode
 2083               	.LM289:
 2084 078a 8091 0000 		lds r24,yackflags
 2085 078e 8C70      		andi r24,lo8(12)
 2086 0790 8430      		cpi r24,lo8(4)
 2087 0792 01F4      		brne .L181
1301:yack.c        **** 				keylatch();                      // then latch here already 
 2089               	.LM290:
 2090 0794 00D0      		rcall keylatch
 2091               	.L181:
1302:yack.c        **** 			
1303:yack.c        **** 			if(timer == 0) // Done with sounding our element?
 2093               	.LM291:
 2094 0796 8091 0000 		lds r24,timer.2200
 2095 079a 9091 0000 		lds r25,timer.2200+1
 2096 079e 892B      		or r24,r25
 2097 07a0 01F4      		brne .L197
 2098               	.LBB67:
 2099               	.LBB68:
 2100 07a2 00D0      		rcall key.part.0
 2101               	.LBE68:
 2102               	.LBE67:
1304:yack.c        **** 			{
1305:yack.c        **** 				key(UP); // Then cancel the side tone
1306:yack.c        **** 				timer	= IEGLEN * wpmcnt; // One dot time for the gap
 2104               	.LM292:
 2105 07a4 8091 0000 		lds r24,wpmcnt
 2106 07a8 9091 0000 		lds r25,wpmcnt+1
 2107 07ac 9093 0000 		sts timer.2200+1,r25
 2108 07b0 8093 0000 		sts timer.2200,r24
1307:yack.c        **** 				fsms	= IEG; // Change FSM state
 2110               	.LM293:
 2111 07b4 82E0      		ldi r24,lo8(2)
 2112               	.L200:
 2113 07b6 8093 0000 		sts fsms.2199,r24
 2114 07ba 00C0      		rjmp .L197
 2115               	.L163:
1308:yack.c        **** 			}
1309:yack.c        **** 			
1310:yack.c        **** 			break;
1311:yack.c        **** 			
1312:yack.c        **** 			
1313:yack.c        **** 		case IEG:
1314:yack.c        **** 			
1315:yack.c        **** 			keylatch();	// Latch any paddle movements (both A and B)
 2117               	.LM294:
 2118 07bc 00D0      		rcall keylatch
1316:yack.c        **** 			
1317:yack.c        **** 			if(timer == 0) // End of gap reached?
 2120               	.LM295:
 2121 07be 8091 0000 		lds r24,timer.2200
 2122 07c2 9091 0000 		lds r25,timer.2200+1
 2123 07c6 892B      		or r24,r25
 2124 07c8 01F4      		brne .L197
1318:yack.c        **** 			{
1319:yack.c        **** 				fsms	= IDLE; // Change FSM state
 2126               	.LM296:
 2127 07ca 1092 0000 		sts fsms.2199,__zero_reg__
1320:yack.c        **** 				// The following timer determines what the IDLE state
1321:yack.c        ****                 // accepts as character. Anything longer than 2 dots as gap will be
1322:yack.c        ****                 // accepted for a character end.
1323:yack.c        **** 				timer	= (ICGLEN - IEGLEN -1) * wpmcnt; 
 2129               	.LM297:
 2130 07ce 8091 0000 		lds r24,wpmcnt
 2131 07d2 9091 0000 		lds r25,wpmcnt+1
 2132 07d6 9093 0000 		sts timer.2200+1,r25
 2133 07da 8093 0000 		sts timer.2200,r24
 2134               	.L197:
1324:yack.c        **** 			}
1325:yack.c        **** 			break;
1326:yack.c        **** 			
1327:yack.c        **** 	}
1328:yack.c        **** 	
1329:yack.c        **** 	return '\0'; // Nothing to return if not returned in above routine
 2136               	.LM298:
 2137 07de 80E0      		ldi r24,0
 2138               	.L160:
 2139               	/* epilogue start */
1330:yack.c        **** 	
1331:yack.c        **** }
 2141               	.LM299:
 2142 07e0 CF91      		pop r28
 2143 07e2 0895      		ret
 2157               	.Lscope28:
 2161               	.global	yackmessage
 2163               	yackmessage:
1064:yack.c        **** 	unsigned char	rambuffer[RBSIZE];  // Storage for the message
 2165               	.LM300:
 2166               	.LFBB29:
 2167 07e4 EF92      		push r14
 2168 07e6 FF92      		push r15
 2169 07e8 0F93      		push r16
 2170 07ea 1F93      		push r17
 2171 07ec CF93      		push r28
 2172 07ee DF93      		push r29
 2173 07f0 CDB7      		in r28,__SP_L__
 2174 07f2 DEB7      		in r29,__SP_H__
 2175 07f4 C456      		subi r28,100
 2176 07f6 D109      		sbc r29,__zero_reg__
 2177 07f8 0FB6      		in __tmp_reg__,__SREG__
 2178 07fa F894      		cli
 2179 07fc DEBF      		out __SP_H__,r29
 2180 07fe 0FBE      		out __SREG__,__tmp_reg__
 2181 0800 CDBF      		out __SP_L__,r28
 2182               	/* prologue: function */
 2183               	/* frame size = 100 */
 2184               	/* stack size = 106 */
 2185               	.L__stack_usage = 106
 2186 0802 062F      		mov r16,r22
1073:yack.c        **** 	{
 2188               	.LM301:
 2189 0804 8130      		cpi r24,lo8(1)
 2190 0806 01F0      		breq .+2
 2191 0808 00C0      		rjmp .L202
 2192 080a 10E0      		ldi r17,0
 2193 080c 98EE      		ldi r25,lo8(-24)
 2194 080e E92E      		mov r14,r25
 2195 0810 93E0      		ldi r25,lo8(3)
 2196 0812 F92E      		mov r15,r25
 2197               	.L207:
1079:yack.c        **** 			
 2199               	.LM302:
 2200 0814 81E0      		ldi r24,lo8(1)
 2201 0816 00D0      		rcall yackctrlkey
 2202 0818 8111      		cpse r24,__zero_reg__
 2203 081a 00C0      		rjmp .L201
1081:yack.c        **** 			{
 2205               	.LM303:
 2206 081c 81E0      		ldi r24,lo8(1)
 2207 081e 00D0      		rcall yackiambic
 2208 0820 8111      		cpse r24,__zero_reg__
 2209 0822 00C0      		rjmp .L204
1077:yack.c        ****    		{
 2211               	.LM304:
 2212 0824 81E0      		ldi r24,1
 2213 0826 E81A      		sub r14,r24
 2214 0828 F108      		sbc r15,__zero_reg__
 2215 082a 00C0      		rjmp .L205
 2216               	.L204:
1083:yack.c        **** 				extimer = YACKSECS(DEFTIMEOUT); // Reset End of message timer
 2218               	.LM305:
 2219 082c E1E0      		ldi r30,lo8(1)
 2220 082e F0E0      		ldi r31,0
 2221 0830 EC0F      		add r30,r28
 2222 0832 FD1F      		adc r31,r29
 2223 0834 E10F      		add r30,r17
 2224 0836 F11D      		adc r31,__zero_reg__
 2225 0838 8083      		st Z,r24
 2226 083a 1F5F      		subi r17,lo8(-(1))
1084:yack.c        **** 			}
 2228               	.LM306:
 2229 083c 88EE      		ldi r24,lo8(-24)
 2230 083e E82E      		mov r14,r24
 2231 0840 83E0      		ldi r24,lo8(3)
 2232 0842 F82E      		mov r15,r24
 2233               	.L205:
1087:yack.c        **** 			{
 2235               	.LM307:
 2236 0844 1436      		cpi r17,lo8(100)
 2237 0846 00F0      		brlo .L206
1089:yack.c        **** 				i = 0;
 2239               	.LM308:
 2240 0848 00D0      		rcall yackerror
1090:yack.c        **** 			}
 2242               	.LM309:
 2243 084a 10E0      		ldi r17,0
 2244               	.L206:
1093:yack.c        **** 		}	
 2246               	.LM310:
 2247 084c 00D0      		rcall yackbeat
1077:yack.c        ****    		{
 2249               	.LM311:
 2250 084e E114      		cp r14,__zero_reg__
 2251 0850 F104      		cpc r15,__zero_reg__
 2252 0852 01F4      		brne .L207
1098:yack.c        **** 		{
 2254               	.LM312:
 2255 0854 1123      		tst r17
 2256 0856 01F0      		breq .L208
1100:yack.c        **** 			
 2258               	.LM313:
 2259 0858 1150      		subi r17,lo8(-(-1))
 2260 085a E1E0      		ldi r30,lo8(1)
 2261 085c F0E0      		ldi r31,0
 2262 085e EC0F      		add r30,r28
 2263 0860 FD1F      		adc r31,r29
 2264 0862 E10F      		add r30,r17
 2265 0864 F11D      		adc r31,__zero_reg__
 2266 0866 1082      		st Z,__zero_reg__
1109:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer1,RBSIZE);
 2268               	.LM314:
 2269 0868 0130      		cpi r16,lo8(1)
 2270 086a 01F4      		brne .L209
1110:yack.c        **** 			if (msgnr == 2)
 2272               	.LM315:
 2273 086c 44E6      		ldi r20,lo8(100)
 2274 086e 50E0      		ldi r21,0
 2275 0870 60E0      		ldi r22,lo8(eebuffer1)
 2276 0872 70E0      		ldi r23,hi8(eebuffer1)
 2277 0874 00C0      		rjmp .L222
 2278               	.L209:
1111:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer2,RBSIZE);
 2280               	.LM316:
 2281 0876 0230      		cpi r16,lo8(2)
 2282 0878 01F4      		brne .L211
1112:yack.c        **** 			if (msgnr == 3)
 2284               	.LM317:
 2285 087a 44E6      		ldi r20,lo8(100)
 2286 087c 50E0      		ldi r21,0
 2287 087e 60E0      		ldi r22,lo8(eebuffer2)
 2288 0880 70E0      		ldi r23,hi8(eebuffer2)
 2289               	.L222:
 2290 0882 CE01      		movw r24,r28
 2291 0884 0196      		adiw r24,1
 2292 0886 00D0      		rcall eeprom_write_block
 2293 0888 00C0      		rjmp .L201
 2294               	.L211:
1113:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer3,RBSIZE);
 2296               	.LM318:
 2297 088a 0330      		cpi r16,lo8(3)
 2298 088c 01F4      		brne .L212
1114:yack.c        **** 			if (msgnr == 4)
 2300               	.LM319:
 2301 088e 44E6      		ldi r20,lo8(100)
 2302 0890 50E0      		ldi r21,0
 2303 0892 60E0      		ldi r22,lo8(eebuffer3)
 2304 0894 70E0      		ldi r23,hi8(eebuffer3)
 2305 0896 00C0      		rjmp .L222
 2306               	.L212:
1115:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer4,RBSIZE);
 2308               	.LM320:
 2309 0898 0430      		cpi r16,lo8(4)
 2310 089a 01F4      		brne .L201
1116:yack.c        **** 		}
 2312               	.LM321:
 2313 089c 44E6      		ldi r20,lo8(100)
 2314 089e 50E0      		ldi r21,0
 2315 08a0 60E0      		ldi r22,lo8(eebuffer4)
 2316 08a2 70E0      		ldi r23,hi8(eebuffer4)
 2317 08a4 00C0      		rjmp .L222
 2318               	.L208:
1119:yack.c        **** 	}
 2320               	.LM322:
 2321 08a6 00D0      		rcall yackerror
 2322 08a8 00C0      		rjmp .L201
 2323               	.L202:
1123:yack.c        **** 	{
 2325               	.LM323:
 2326 08aa 8230      		cpi r24,lo8(2)
 2327 08ac 01F4      		brne .L201
1126:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer1,RBSIZE);
 2329               	.LM324:
 2330 08ae 6130      		cpi r22,lo8(1)
 2331 08b0 01F4      		brne .L213
1127:yack.c        **** 		if (msgnr == 2)
 2333               	.LM325:
 2334 08b2 44E6      		ldi r20,lo8(100)
 2335 08b4 50E0      		ldi r21,0
 2336 08b6 60E0      		ldi r22,lo8(eebuffer1)
 2337 08b8 70E0      		ldi r23,hi8(eebuffer1)
 2338 08ba 00C0      		rjmp .L221
 2339               	.L213:
1128:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer2,RBSIZE);
 2341               	.LM326:
 2342 08bc 6230      		cpi r22,lo8(2)
 2343 08be 01F4      		brne .L215
1129:yack.c        **** 		if (msgnr == 3)
 2345               	.LM327:
 2346 08c0 44E6      		ldi r20,lo8(100)
 2347 08c2 50E0      		ldi r21,0
 2348 08c4 60E0      		ldi r22,lo8(eebuffer2)
 2349 08c6 70E0      		ldi r23,hi8(eebuffer2)
 2350 08c8 00C0      		rjmp .L221
 2351               	.L215:
1130:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer3,RBSIZE);
 2353               	.LM328:
 2354 08ca 6330      		cpi r22,lo8(3)
 2355 08cc 01F4      		brne .L216
1131:yack.c        **** 		if (msgnr == 4)
 2357               	.LM329:
 2358 08ce 44E6      		ldi r20,lo8(100)
 2359 08d0 50E0      		ldi r21,0
 2360 08d2 60E0      		ldi r22,lo8(eebuffer3)
 2361 08d4 70E0      		ldi r23,hi8(eebuffer3)
 2362 08d6 00C0      		rjmp .L221
 2363               	.L216:
1132:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer4,RBSIZE);
 2365               	.LM330:
 2366 08d8 6430      		cpi r22,lo8(4)
 2367 08da 01F4      		brne .L214
1133:yack.c        **** 		
 2369               	.LM331:
 2370 08dc 44E6      		ldi r20,lo8(100)
 2371 08de 50E0      		ldi r21,0
 2372 08e0 60E0      		ldi r22,lo8(eebuffer4)
 2373 08e2 70E0      		ldi r23,hi8(eebuffer4)
 2374               	.L221:
 2375 08e4 CE01      		movw r24,r28
 2376 08e6 0196      		adiw r24,1
 2377 08e8 00D0      		rcall eeprom_read_block
 2378               	.L214:
1090:yack.c        **** 			}
 2380               	.LM332:
 2381 08ea 10E0      		ldi r17,0
 2382               	.L217:
1136:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
 2384               	.LM333:
 2385 08ec E1E0      		ldi r30,lo8(1)
 2386 08ee F0E0      		ldi r31,0
 2387 08f0 EC0F      		add r30,r28
 2388 08f2 FD1F      		adc r31,r29
 2389 08f4 E10F      		add r30,r17
 2390 08f6 F11D      		adc r31,__zero_reg__
 2391 08f8 0081      		ld r16,Z
 2392 08fa 0023      		tst r16
 2393 08fc 01F0      		breq .L201
1137:yack.c        **** 			yackchar(c); // play it back 
 2395               	.LM334:
 2396 08fe 80E0      		ldi r24,0
 2397 0900 00D0      		rcall yackctrlkey
 2398 0902 8111      		cpse r24,__zero_reg__
 2399 0904 00C0      		rjmp .L201
1138:yack.c        **** 		}
 2401               	.LM335:
 2402 0906 802F      		mov r24,r16
 2403 0908 00D0      		rcall yackchar
1136:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
 2405               	.LM336:
 2406 090a 1F5F      		subi r17,lo8(-(1))
 2407 090c 00C0      		rjmp .L217
 2408               	.L201:
 2409               	/* epilogue start */
1141:yack.c        **** 
 2411               	.LM337:
 2412 090e CC59      		subi r28,-100
 2413 0910 DF4F      		sbci r29,-1
 2414 0912 0FB6      		in __tmp_reg__,__SREG__
 2415 0914 F894      		cli
 2416 0916 DEBF      		out __SP_H__,r29
 2417 0918 0FBE      		out __SREG__,__tmp_reg__
 2418 091a CDBF      		out __SP_L__,r28
 2419 091c DF91      		pop r29
 2420 091e CF91      		pop r28
 2421 0920 1F91      		pop r17
 2422 0922 0F91      		pop r16
 2423 0924 FF90      		pop r15
 2424 0926 EF90      		pop r14
 2425 0928 0895      		ret
 2432               	.Lscope29:
 2433               		.local	buffer.2202
 2434               		.comm	buffer.2202,1,1
 2435               		.local	bcntr.2203
 2436               		.comm	bcntr.2203,1,1
 2437               		.local	ultimem.2205
 2438               		.comm	ultimem.2205,1,1
 2439               		.local	lastsymbol.2201
 2440               		.comm	lastsymbol.2201,1,1
 2441               		.local	fsms.2199
 2442               		.comm	fsms.2199,1,1
 2443               		.local	iwgflag.2204
 2444               		.comm	iwgflag.2204,1,1
 2445               		.local	timer.2200
 2446               		.comm	timer.2200,2,1
 2447               		.local	shdntimer.2031
 2448               		.comm	shdntimer.2031,4,1
 2449               	.global	spechar
 2450               		.section	.progmem.data,"a",@progbits
 2453               	spechar:
 2454 0000 3F2E 2F21 		.ascii	"?./!,:;~$^()-@_|=#+*%&<>"
 2454      2C3A 3B7E 
 2454      245E 2829 
 2454      2D40 5F7C 
 2454      3D23 2B2A 
 2455               	.global	morse
 2458               	morse:
 2459 0018 FC        		.byte	-4
 2460 0019 7C        		.byte	124
 2461 001a 3C        		.byte	60
 2462 001b 1C        		.byte	28
 2463 001c 0C        		.byte	12
 2464 001d 04        		.byte	4
 2465 001e 84        		.byte	-124
 2466 001f C4        		.byte	-60
 2467 0020 E4        		.byte	-28
 2468 0021 F4        		.byte	-12
 2469 0022 60        		.byte	96
 2470 0023 88        		.byte	-120
 2471 0024 A8        		.byte	-88
 2472 0025 90        		.byte	-112
 2473 0026 40        		.byte	64
 2474 0027 28        		.byte	40
 2475 0028 D0        		.byte	-48
 2476 0029 08        		.byte	8
 2477 002a 20        		.byte	32
 2478 002b 78        		.byte	120
 2479 002c B0        		.byte	-80
 2480 002d 48        		.byte	72
 2481 002e E0        		.byte	-32
 2482 002f A0        		.byte	-96
 2483 0030 F0        		.byte	-16
 2484 0031 68        		.byte	104
 2485 0032 D8        		.byte	-40
 2486 0033 50        		.byte	80
 2487 0034 10        		.byte	16
 2488 0035 C0        		.byte	-64
 2489 0036 30        		.byte	48
 2490 0037 18        		.byte	24
 2491 0038 70        		.byte	112
 2492 0039 98        		.byte	-104
 2493 003a B8        		.byte	-72
 2494 003b C8        		.byte	-56
 2495 003c 32        		.byte	50
 2496 003d 56        		.byte	86
 2497 003e 94        		.byte	-108
 2498 003f E8        		.byte	-24
 2499 0040 CE        		.byte	-50
 2500 0041 E2        		.byte	-30
 2501 0042 AA        		.byte	-86
 2502 0043 4A        		.byte	74
 2503 0044 13        		.byte	19
 2504 0045 7A        		.byte	122
 2505 0046 B4        		.byte	-76
 2506 0047 B6        		.byte	-74
 2507 0048 86        		.byte	-122
 2508 0049 6A        		.byte	106
 2509 004a 36        		.byte	54
 2510 004b 52        		.byte	82
 2511 004c 8C        		.byte	-116
 2512 004d 16        		.byte	22
 2513 004e 54        		.byte	84
 2514 004f 8B        		.byte	-117
 2515 0050 44        		.byte	68
 2516 0051 AC        		.byte	-84
 2517 0052 14        		.byte	20
 2518 0053 58        		.byte	88
 2519               	.global	eebuffer4
 2520               		.section	.eeprom,"aw",@progbits
 2523               	eebuffer4:
 2524 0000 6D65 7373 		.string	"message 4"
 2524      6167 6520 
 2524      3400 
 2525 000a 0000 0000 		.zero	90
 2525      0000 0000 
 2525      0000 0000 
 2525      0000 0000 
 2525      0000 0000 
 2526               	.global	eebuffer3
 2529               	eebuffer3:
 2530 0064 6D65 7373 		.string	"message 3"
 2530      6167 6520 
 2530      3300 
 2531 006e 0000 0000 		.zero	90
 2531      0000 0000 
 2531      0000 0000 
 2531      0000 0000 
 2531      0000 0000 
 2532               	.global	eebuffer2
 2535               	eebuffer2:
 2536 00c8 6D65 7373 		.string	"message 2"
 2536      6167 6520 
 2536      3200 
 2537 00d2 0000 0000 		.zero	90
 2537      0000 0000 
 2537      0000 0000 
 2537      0000 0000 
 2537      0000 0000 
 2538               	.global	eebuffer1
 2541               	eebuffer1:
 2542 012c 6D65 7373 		.string	"message 1"
 2542      6167 6520 
 2542      3100 
 2543 0136 0000 0000 		.zero	90
 2543      0000 0000 
 2543      0000 0000 
 2543      0000 0000 
 2543      0000 0000 
 2544               	.global	user2
 2547               	user2:
 2548 0190 0000      		.zero	2
 2549               	.global	user1
 2552               	user1:
 2553 0192 0000      		.zero	2
 2554               	.global	fwstor
 2557               	fwstor:
 2558 0194 00        		.zero	1
 2559               	.global	wpmstor
 2562               	wpmstor:
 2563 0195 0F        		.byte	15
 2564               	.global	ctcstor
 2567               	ctcstor:
 2568 0196 4D00      		.word	77
 2569               	.global	flagstor
 2572               	flagstor:
 2573 0198 34        		.byte	52
 2574               	.global	magic
 2577               	magic:
 2578 0199 A5        		.byte	-91
 2579               		.local	farnsworth
 2580               		.comm	farnsworth,1,1
 2581               		.local	wpm
 2582               		.comm	wpm,1,1
 2583               		.local	wpmcnt
 2584               		.comm	wpmcnt,2,1
 2585               		.local	ctcvalue
 2586               		.comm	ctcvalue,2,1
 2587               		.local	volflags
 2588               		.comm	volflags,1,1
 2589               		.local	yackflags
 2590               		.comm	yackflags,1,1
 2610               		.text
 2612               	.Letext0:
 2613               		.ident	"GCC: (GNU) 5.4.0"
 2614               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 yack.c
     /tmp/ccpxFyOC.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccpxFyOC.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccpxFyOC.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccpxFyOC.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccpxFyOC.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccpxFyOC.s:121    .text:0000000000000000 keylatch
     /tmp/ccpxFyOC.s:2588   .bss:0000000000000013 yackflags
     /tmp/ccpxFyOC.s:2586   .bss:0000000000000012 volflags
     /tmp/ccpxFyOC.s:179    .text:0000000000000038 key.part.0
     /tmp/ccpxFyOC.s:223    .text:000000000000005c yackinhibit.part.3
     /tmp/ccpxFyOC.s:252    .text:0000000000000074 key.constprop.4
     /tmp/ccpxFyOC.s:2584   .bss:0000000000000010 ctcvalue
     /tmp/ccpxFyOC.s:308    .text:00000000000000aa __vector_2
     /tmp/ccpxFyOC.s:335    .text:00000000000000be yackpower
     /tmp/ccpxFyOC.s:2446   .bss:0000000000000008 shdntimer.2031
     /tmp/ccpxFyOC.s:437    .text:0000000000000138 yacksave
     /tmp/ccpxFyOC.s:2577   .eeprom:0000000000000199 magic
     /tmp/ccpxFyOC.s:2567   .eeprom:0000000000000196 ctcstor
     /tmp/ccpxFyOC.s:2580   .bss:000000000000000d wpm
     /tmp/ccpxFyOC.s:2562   .eeprom:0000000000000195 wpmstor
     /tmp/ccpxFyOC.s:2572   .eeprom:0000000000000198 flagstor
     /tmp/ccpxFyOC.s:2448   .bss:000000000000000c farnsworth
     /tmp/ccpxFyOC.s:2557   .eeprom:0000000000000194 fwstor
     /tmp/ccpxFyOC.s:497    .text:0000000000000180 yackreset
     /tmp/ccpxFyOC.s:2582   .bss:000000000000000e wpmcnt
     /tmp/ccpxFyOC.s:541    .text:00000000000001b4 yackinit
     /tmp/ccpxFyOC.s:651    .text:000000000000022a yackinhibit
     /tmp/ccpxFyOC.s:683    .text:0000000000000240 yackuser
     /tmp/ccpxFyOC.s:2552   .eeprom:0000000000000192 user1
     /tmp/ccpxFyOC.s:2547   .eeprom:0000000000000190 user2
     /tmp/ccpxFyOC.s:753    .text:000000000000027a yackwpm
     /tmp/ccpxFyOC.s:773    .text:0000000000000282 yackbeat
     /tmp/ccpxFyOC.s:799    .text:0000000000000290 yackpitch
     /tmp/ccpxFyOC.s:870    .text:00000000000002f0 yackmode
     /tmp/ccpxFyOC.s:896    .text:0000000000000308 yackflag
     /tmp/ccpxFyOC.s:917    .text:0000000000000310 yacktoggle
     /tmp/ccpxFyOC.s:942    .text:0000000000000326 yackdelay
     /tmp/ccpxFyOC.s:986    .text:0000000000000348 yackfarns
     /tmp/ccpxFyOC.s:1024   .text:0000000000000364 yackplay
     /tmp/ccpxFyOC.s:1080   .text:000000000000038e yackspeed
     /tmp/ccpxFyOC.s:1189   .text:0000000000000404 yackerror
     /tmp/ccpxFyOC.s:1230   .text:000000000000041a yackctrlkey
     /tmp/ccpxFyOC.s:1361   .text:0000000000000488 yacktune
     /tmp/ccpxFyOC.s:1417   .text:00000000000004b0 yackchar
     /tmp/ccpxFyOC.s:2458   .progmem.data:0000000000000018 morse
     /tmp/ccpxFyOC.s:2453   .progmem.data:0000000000000000 spechar
     /tmp/ccpxFyOC.s:1612   .text:0000000000000544 yackstring
     /tmp/ccpxFyOC.s:1667   .text:000000000000056c yacknumber
     /tmp/ccpxFyOC.s:1764   .text:00000000000005d2 yackiambic
     /tmp/ccpxFyOC.s:2444   .bss:0000000000000006 timer.2200
     /tmp/ccpxFyOC.s:2442   .bss:0000000000000005 iwgflag.2204
     /tmp/ccpxFyOC.s:2440   .bss:0000000000000004 fsms.2199
     /tmp/ccpxFyOC.s:2438   .bss:0000000000000003 lastsymbol.2201
     /tmp/ccpxFyOC.s:2436   .bss:0000000000000002 ultimem.2205
     /tmp/ccpxFyOC.s:2434   .bss:0000000000000001 bcntr.2203
                             .bss:0000000000000000 buffer.2202
     /tmp/ccpxFyOC.s:2163   .text:00000000000007e4 yackmessage
     /tmp/ccpxFyOC.s:2541   .eeprom:000000000000012c eebuffer1
     /tmp/ccpxFyOC.s:2535   .eeprom:00000000000000c8 eebuffer2
     /tmp/ccpxFyOC.s:2529   .eeprom:0000000000000064 eebuffer3
     /tmp/ccpxFyOC.s:2523   .eeprom:0000000000000000 eebuffer4

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_write_word
eeprom_read_byte
eeprom_read_word
__divmodhi4
__udivmodhi4
__mulhi3
eeprom_write_block
eeprom_read_block
__do_clear_bss
