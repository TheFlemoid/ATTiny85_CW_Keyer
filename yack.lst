   1               		.file	"yack.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 121               	keylatch:
   1:yack.c        **** /*!
   2:yack.c        ****  
   3:yack.c        ****  @file      yack.c
   4:yack.c        ****  @brief     CW Keyer library
   5:yack.c        ****  @author    Jan Lategahn DK3LJ jan@lategahn.com (C) 2011; modified by Jack Welch AI4SV; modified by
   6:yack.c        ****  
   7:yack.c        ****  @version   0.87
   8:yack.c        ****  
   9:yack.c        ****  This program is free software: you can redistribute it and/or modify
  10:yack.c        ****  it under the terms of the GNU General Public License as published by
  11:yack.c        ****  the Free Software Foundation, either version 3 of the License, or
  12:yack.c        ****  (at your option) any later version.
  13:yack.c        ****  
  14:yack.c        ****  This program is distributed in the hope that it will be useful,
  15:yack.c        ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:yack.c        ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:yack.c        ****  GNU General Public License for more details.
  18:yack.c        ****  
  19:yack.c        ****  You should have received a copy of the GNU General Public License
  20:yack.c        ****  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:yack.c        ****  
  22:yack.c        ****  @date      15.10.2010  - Created
  23:yack.c        ****  @date      03.10.2013  - Last update
  24:yack.c        ****  @date      21.12.2016  - Added additional prosigns and punctuation. Added 2 additional memories fo
  25:yack.c        ****  @date      03.01.2017  - If memory recording is interrupted by command button, keyer now returns t
  26:yack.c        ****                           Memory playback halts immediately on command key instead of looping throu
  27:yack.c        **** 						  Removed playback of recorded message before saving.
  28:yack.c        **** 						  Changed yackstring command to return to command mode instead of normal mode if interrupted 
  29:yack.c        ****  
  30:yack.c        ****  @todo      Make the delay dependent on T/C 1 
  31:yack.c        **** 
  32:yack.c        **** */ 
  33:yack.c        **** 
  34:yack.c        **** 
  35:yack.c        **** #include <avr/io.h> 
  36:yack.c        **** #include <avr/pgmspace.h>
  37:yack.c        **** #include <avr/eeprom.h>
  38:yack.c        **** #include <avr/interrupt.h>
  39:yack.c        **** #include <avr/sleep.h>
  40:yack.c        **** #include <util/delay.h>
  41:yack.c        **** #include <stdint.h>
  42:yack.c        **** #include "yack.h"
  43:yack.c        **** 
  44:yack.c        **** // Forward declaration of private functions
  45:yack.c        **** static      void key( byte mode); 
  46:yack.c        **** static      char morsechar(byte buffer);
  47:yack.c        **** static      void keylatch(void);
  48:yack.c        **** 
  49:yack.c        **** // Enumerations
  50:yack.c        **** 
  51:yack.c        **** enum FSMSTATE { 
  52:yack.c        ****                 IDLE,   //!< Not keyed, waiting for paddle
  53:yack.c        ****                 KEYED,  //!< Keyed, waiting for duration of current element
  54:yack.c        ****                 IEG     //!< In Inter-Element-Gap 
  55:yack.c        ****               };   
  56:yack.c        **** 
  57:yack.c        **** // Module local definitions
  58:yack.c        **** 
  59:yack.c        **** static		byte	yackflags;		// Permanent (stored) status of module flags
  60:yack.c        **** static		byte	volflags=0;		// Temporary working flags (volatile)
  61:yack.c        **** static 		word	ctcvalue;		// Pitch
  62:yack.c        **** static		word	wpmcnt;			// Speed
  63:yack.c        **** static      byte    wpm;            // Real wpm
  64:yack.c        **** static      byte    farnsworth;     // Additional Farnsworth pause
  65:yack.c        **** 
  66:yack.c        **** // EEPROM Data
  67:yack.c        **** 
  68:yack.c        **** byte		magic EEMEM = MAGPAT;	// Needs to contain 'A5' if mem is valid
  69:yack.c        **** byte		flagstor EEMEM = ( IAMBICB | TXKEY | SIDETONE);	//	Defaults	
  70:yack.c        **** word		ctcstor EEMEM = DEFCTC;	// Pitch = 800Hz
  71:yack.c        **** byte		wpmstor EEMEM = DEFWPM;	// 15 WPM
  72:yack.c        **** byte        fwstor  EEMEM = 0; // No farnsworth pause
  73:yack.c        **** word		user1 EEMEM = 0; // User storage
  74:yack.c        **** word		user2 EEMEM = 0; // User storage
  75:yack.c        **** 
  76:yack.c        **** //char		eebuffer1[100] EEMEM = "message 1";
  77:yack.c        **** //char		eebuffer2[100] EEMEM = "message 2";
  78:yack.c        **** char		eebuffer1[100] EEMEM = "message 1"; 
  79:yack.c        **** char		eebuffer2[100] EEMEM = "message 2"; 
  80:yack.c        **** char		eebuffer3[100] EEMEM = "message 3";
  81:yack.c        **** char		eebuffer4[100] EEMEM = "message 4"; 
  82:yack.c        **** 
  83:yack.c        **** // Flash data
  84:yack.c        **** 
  85:yack.c        **** //! Morse code table in Flash
  86:yack.c        **** 
  87:yack.c        **** //! Encoding: Each byte is read from the left. 0 stands for a dot, 1
  88:yack.c        **** //! stands for a dash. After each played element the content is shifted
  89:yack.c        **** //! left. Playback stops when the leftmost bit contains a "1" and the rest
  90:yack.c        **** //! of the bits are all zero.
  91:yack.c        **** //!
  92:yack.c        **** //! Example: A = .-
  93:yack.c        **** //! Encoding: 01100000
  94:yack.c        **** //!           .-
  95:yack.c        **** //!             | This is the stop marker (1 with all trailing zeros)
  96:yack.c        **** 
  97:yack.c        **** const byte morse[] PROGMEM = 
  98:yack.c        **** {
  99:yack.c        **** 	
 100:yack.c        **** 	0b11111100, // 0
 101:yack.c        **** 	0b01111100, // 1
 102:yack.c        **** 	0b00111100, // 2
 103:yack.c        **** 	0b00011100, // 3
 104:yack.c        **** 	0b00001100, // 4
 105:yack.c        **** 	0b00000100, // 5
 106:yack.c        **** 	0b10000100, // 6
 107:yack.c        **** 	0b11000100, // 7
 108:yack.c        **** 	0b11100100, // 8
 109:yack.c        **** 	0b11110100, // 9
 110:yack.c        **** 	0b01100000, // A
 111:yack.c        **** 	0b10001000, // B
 112:yack.c        **** 	0b10101000, // C
 113:yack.c        **** 	0b10010000, // D
 114:yack.c        **** 	0b01000000, // E
 115:yack.c        **** 	0b00101000, // F
 116:yack.c        **** 	0b11010000, // G
 117:yack.c        **** 	0b00001000, // H
 118:yack.c        **** 	0b00100000, // I                                
 119:yack.c        **** 	0b01111000, // J
 120:yack.c        **** 	0b10110000, // K
 121:yack.c        **** 	0b01001000, // L
 122:yack.c        **** 	0b11100000, // M
 123:yack.c        **** 	0b10100000, // N
 124:yack.c        **** 	0b11110000, // O
 125:yack.c        **** 	0b01101000, // P
 126:yack.c        **** 	0b11011000, // Q
 127:yack.c        **** 	0b01010000, // R
 128:yack.c        **** 	0b00010000, // S
 129:yack.c        **** 	0b11000000, // T
 130:yack.c        **** 	0b00110000, // U
 131:yack.c        **** 	0b00011000, // V
 132:yack.c        **** 	0b01110000, // W
 133:yack.c        **** 	0b10011000, // X
 134:yack.c        **** 	0b10111000, // Y
 135:yack.c        **** 	0b11001000, // Z
 136:yack.c        **** 	0b00110010, // ?
 137:yack.c        **** 	0b01010110, // .
 138:yack.c        **** 	0b10010100, // /
 139:yack.c        **** 	0b11101000, // ! (American Morse version, commonly used in ham circles)
 140:yack.c        **** 	0b11001110, // ,
 141:yack.c        **** 	0b11100010, // :
 142:yack.c        **** 	0b10101010, // ;
 143:yack.c        **** 	0b01001010, // "
 144:yack.c        **** 	0b00010011, // $
 145:yack.c        **** 	0b01111010, // ' (Apostrophe)
 146:yack.c        **** 	0b10110100, // ( or [ (also prosign KN)
 147:yack.c        ****     0b10110110, // ) or ]
 148:yack.c        **** 	0b10000110, // - (Hyphen or single dash)
 149:yack.c        **** 	0b01101010, // @
 150:yack.c        **** 	0b00110110, // _ (Underline)
 151:yack.c        **** 	0b01010010, // Paragaraph break symbol
 152:yack.c        **** 	0b10001100, // = and BT
 153:yack.c        **** 	0b00010110, // SK
 154:yack.c        **** 	0b01010100, // + and AR
 155:yack.c        **** 	0b10001011, // BK
 156:yack.c        **** 	0b01000100, // AS
 157:yack.c        **** 	0b10101100, // KA (also ! in alternate Continental Morse)
 158:yack.c        **** 	0b00010100, // VE
 159:yack.c        **** 	0b01011000  // AA
 160:yack.c        **** };
 161:yack.c        **** 
 162:yack.c        **** 
 163:yack.c        **** // The special characters at the end of the above table can not be decoded
 164:yack.c        **** // without a small table to define their content. # stands for SK, $ for AR
 165:yack.c        **** 
 166:yack.c        **** // To add new characters, add them in the code table above at the end and below
 167:yack.c        **** // Do not forget to increase the legth of the array..
 168:yack.c        **** 
 169:yack.c        **** const char spechar[24] PROGMEM = "?./!,:;~$^()-@_|=#+*%&<>";
 170:yack.c        **** 
 171:yack.c        **** 
 172:yack.c        **** 
 173:yack.c        **** // Functions
 174:yack.c        **** 
 175:yack.c        **** // ***************************************************************************
 176:yack.c        **** // Control functions
 177:yack.c        **** // ***************************************************************************
 178:yack.c        **** 
 179:yack.c        **** void yackreset (void)
 180:yack.c        **** /*! 
 181:yack.c        ****  @brief     Sets all yack parameters to standard values
 182:yack.c        **** 
 183:yack.c        ****  This function resets all YACK EEPROM settings to their default values as 
 184:yack.c        ****  stored in the .h file. It sets the dirty flag and calls the save routine
 185:yack.c        ****  to write the data into EEPROM immediately.
 186:yack.c        **** */
 187:yack.c        **** {
 188:yack.c        **** 
 189:yack.c        **** 	ctcvalue=DEFCTC; // Initialize to 800 Hz
 190:yack.c        ****     wpm=DEFWPM; // Init to default speed
 191:yack.c        **** 	wpmcnt=(1200/YACKBEAT)/DEFWPM; // default speed
 192:yack.c        ****     farnsworth=0; // No Farnsworth gap
 193:yack.c        **** 	yackflags = FLAGDEFAULT;  
 194:yack.c        **** 
 195:yack.c        **** 	volflags |= DIRTYFLAG;
 196:yack.c        **** 	yacksave(); // Store them in EEPROM
 197:yack.c        **** 
 198:yack.c        **** }
 199:yack.c        **** 
 200:yack.c        **** 
 201:yack.c        **** void yackinit (void)
 202:yack.c        **** /*! 
 203:yack.c        ****  @brief     Initializes the YACK library
 204:yack.c        ****  
 205:yack.c        ****  This function initializes the keyer hardware according to configurations in the .h file.
 206:yack.c        ****  Then it attempts to read saved configuration settings from EEPROM. If not possible, it
 207:yack.c        ****  will reset all values to their defaults.
 208:yack.c        ****  This function must be called once before the remaining fuctions can be used.
 209:yack.c        **** */
 210:yack.c        **** {
 211:yack.c        **** 	
 212:yack.c        **** 	byte magval;
 213:yack.c        **** 	
 214:yack.c        **** 	// Configure DDR. Make OUT and ST output ports
 215:yack.c        **** 	SETBIT (OUTDDR,OUTPIN);    
 216:yack.c        **** 	SETBIT (STDDR,STPIN);
 217:yack.c        **** 	
 218:yack.c        **** 	// Raise internal pullups for all inputs
 219:yack.c        **** 	SETBIT (KEYPORT,DITPIN);  
 220:yack.c        **** 	SETBIT (KEYPORT,DAHPIN);
 221:yack.c        **** 	SETBIT (BTNPORT,BTNPIN);
 222:yack.c        **** 	
 223:yack.c        **** 	magval = eeprom_read_byte(&magic); // Retrieve magic value
 224:yack.c        **** 	
 225:yack.c        **** 	if (magval == MAGPAT) // Is memory valid
 226:yack.c        **** 	{
 227:yack.c        **** 		ctcvalue = eeprom_read_word(&ctcstor); // Retrieve last ctc setting
 228:yack.c        **** 		wpm = eeprom_read_byte(&wpmstor); // Retrieve last wpm setting
 229:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate speed
 230:yack.c        **** 		farnsworth = eeprom_read_byte(&fwstor); // Retrieve last wpm setting	
 231:yack.c        **** 		yackflags = eeprom_read_byte(&flagstor); // Retrieve last flags	
 232:yack.c        **** 	}
 233:yack.c        **** 	else
 234:yack.c        **** 	{
 235:yack.c        **** 		yackreset();
 236:yack.c        **** 	}	
 237:yack.c        **** 	
 238:yack.c        **** 	yackinhibit(OFF);
 239:yack.c        **** 
 240:yack.c        **** #ifdef POWERSAVE
 241:yack.c        ****     
 242:yack.c        ****     PCMSK |= PWRWAKE;    // Define which keys wake us up
 243:yack.c        ****     GIMSK |= (1<<PCIE);  // Enable pin change interrupt
 244:yack.c        ****     
 245:yack.c        **** #endif
 246:yack.c        ****     
 247:yack.c        ****     // Initialize timer1 to serve as the system heartbeat
 248:yack.c        ****     // CK runs at 1MHz. Prescaling by 64 makes that 15625 Hz.
 249:yack.c        ****     // Counting 78 cycles of that generates an overflow every 5ms
 250:yack.c        ****     
 251:yack.c        ****     OCR1C = 78; // 77 counts per cycle
 252:yack.c        ****     TCCR1 |= (1<<CTC1) | 0b00000111 ; // Clear Timer on match, prescale ck by 64
 253:yack.c        ****     OCR1A = 1; // CTC mode does not create an overflow so we use OCR1A
 254:yack.c        ****     
 255:yack.c        **** }
 256:yack.c        **** 
 257:yack.c        **** #ifdef POWERSAVE
 258:yack.c        **** 
 259:yack.c        **** ISR(PCINT0_vect)
 260:yack.c        **** /*! 
 261:yack.c        ****  @brief     A dummy pin change interrupt
 262:yack.c        ****  
 263:yack.c        ****  This function is called whenever the system is in sleep mode and there is a level change on one of
 264:yack.c        ****  we are monitoring (dit, dah and the command key). As all handling is already taken care of by poll
 265:yack.c        ****  routines, there is nothing we need to do here.
 266:yack.c        ****  */
 267:yack.c        **** {
 268:yack.c        ****     // Nothing to do here. All we want is to wake up..
 269:yack.c        **** }
 270:yack.c        **** 
 271:yack.c        **** 
 272:yack.c        **** void yackpower(byte n)
 273:yack.c        **** /*! 
 274:yack.c        ****  @brief     Manages the power saving mode
 275:yack.c        ****  
 276:yack.c        ****  This is called in yackbeat intervals with either a TRUE or FALSE as parameter. Whenever the
 277:yack.c        ****  parameter is TRUE a beat counter is advanced until the timeout level is reached. When timeout
 278:yack.c        ****  is reached, the chip shuts down and will only wake up again when issued a level change interrupt o
 279:yack.c        ****  either of the input pins.
 280:yack.c        ****  
 281:yack.c        ****  When the parameter is FALSE, the counter is reset.
 282:yack.c        ****  
 283:yack.c        ****  @param n   TRUE: OK to sleep, FALSE: Can not sleep now
 284:yack.c        ****  
 285:yack.c        **** */
 286:yack.c        **** 
 287:yack.c        **** {
 288:yack.c        ****     static uint32_t shdntimer=0;
 289:yack.c        ****     
 290:yack.c        ****     if (n) // True = we could go to sleep
 291:yack.c        ****     {
 292:yack.c        ****         if(shdntimer++ == YACKSECS(PSTIME))
 293:yack.c        ****         {
 294:yack.c        ****             shdntimer=0; // So we do not go to sleep right after waking up..
 295:yack.c        **** 
 296:yack.c        ****             set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 297:yack.c        ****             sleep_bod_disable();
 298:yack.c        ****             sleep_enable();
 299:yack.c        ****             sei();
 300:yack.c        ****             sleep_cpu();
 301:yack.c        ****             cli();
 302:yack.c        ****             
 303:yack.c        ****             // There is no technical reason to CLI here but it avoids hitting the ISR every time
 304:yack.c        ****             // the paddles are touched. If the remaining code needs the interrupts this is OK to re
 305:yack.c        ****             
 306:yack.c        ****         }
 307:yack.c        ****         
 308:yack.c        ****     }
 309:yack.c        ****     else // Passed parameter is FALSE
 310:yack.c        ****     {
 311:yack.c        ****         shdntimer=0;
 312:yack.c        ****     }
 313:yack.c        **** 
 314:yack.c        **** }
 315:yack.c        **** 
 316:yack.c        **** #endif
 317:yack.c        **** 
 318:yack.c        **** 
 319:yack.c        **** 
 320:yack.c        **** void yacksave (void)
 321:yack.c        **** /*! 
 322:yack.c        ****  @brief     Saves all permanent settings to EEPROM
 323:yack.c        ****  
 324:yack.c        ****  To save EEPROM write cycles, writing only happens when the flag DIRTYFLAG is set.
 325:yack.c        ****  After writing the flag is cleared
 326:yack.c        ****  
 327:yack.c        ****  @callergraph
 328:yack.c        ****  
 329:yack.c        ****  */
 330:yack.c        **** {
 331:yack.c        **** 	
 332:yack.c        **** 	if(volflags & DIRTYFLAG) // Dirty flag set?
 333:yack.c        **** 	{	
 334:yack.c        **** 		
 335:yack.c        **** 		eeprom_write_byte(&magic, MAGPAT);
 336:yack.c        **** 		eeprom_write_word(&ctcstor, ctcvalue);
 337:yack.c        **** 		eeprom_write_byte(&wpmstor, wpm);
 338:yack.c        **** 		eeprom_write_byte(&flagstor, yackflags);
 339:yack.c        ****         eeprom_write_byte(&fwstor, farnsworth);
 340:yack.c        **** 		
 341:yack.c        **** 		volflags &= ~DIRTYFLAG; // Clear the dirty flag
 342:yack.c        **** 	}
 343:yack.c        **** 	
 344:yack.c        **** }
 345:yack.c        **** 
 346:yack.c        **** 
 347:yack.c        **** 
 348:yack.c        **** void yackinhibit (byte mode)
 349:yack.c        **** /*! 
 350:yack.c        ****  @brief     Inhibits keying during command phases
 351:yack.c        ****  
 352:yack.c        ****  This function is used to inhibit and re-enable TX keying (if configured) and enforce the internal 
 353:yack.c        ****  sidetone oscillator to be active so that the user can communicate with the keyer.
 354:yack.c        ****  
 355:yack.c        ****  @param mode   ON inhibits keying, OFF re-enables keying 
 356:yack.c        ****  
 357:yack.c        ****  */
 358:yack.c        **** {
 359:yack.c        **** 	
 360:yack.c        **** 	if (mode)
 361:yack.c        **** 	{
 362:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 363:yack.c        **** 		volflags |= SIDETONE;
 364:yack.c        **** 	}
 365:yack.c        **** 	
 366:yack.c        **** 	else
 367:yack.c        **** 		
 368:yack.c        **** 	{
 369:yack.c        **** 		volflags &= ~(TXKEY | SIDETONE);
 370:yack.c        **** 		volflags |= (yackflags & (TXKEY | SIDETONE));
 371:yack.c        ****         key(UP);
 372:yack.c        **** 	}
 373:yack.c        **** 	
 374:yack.c        **** }
 375:yack.c        **** 
 376:yack.c        **** 
 377:yack.c        **** 
 378:yack.c        **** word yackuser (byte func, byte nr, word content)
 379:yack.c        **** /*! 
 380:yack.c        ****  @brief     Saves user defined settings
 381:yack.c        ****  
 382:yack.c        ****  The routine using this library is given the opportunity to save up to two 16 bit sized
 383:yack.c        ****  values in EEPROM. In case of the sample main function this is used to store the beacon interval 
 384:yack.c        ****  timer value. The routine is not otherwise used by the library.
 385:yack.c        ****  
 386:yack.c        ****  @param func    States if the data is retrieved (READ) or written (WRITE) to EEPROM
 387:yack.c        ****  @param nr      1 or 2 (Number of user storage to access)
 388:yack.c        ****  @param content The 16 bit word to write. Not used in read mode.
 389:yack.c        ****  @return        The content of the retrieved value in read mode.
 390:yack.c        ****  
 391:yack.c        ****  */
 392:yack.c        **** {
 393:yack.c        **** 	
 394:yack.c        ****     
 395:yack.c        **** 	if (func == READ)
 396:yack.c        **** 	{
 397:yack.c        **** 		if (nr == 1) 
 398:yack.c        **** 			return (eeprom_read_word(&user1));
 399:yack.c        **** 		else if (nr == 2)
 400:yack.c        **** 			return (eeprom_read_word(&user2));
 401:yack.c        **** 	}
 402:yack.c        **** 	
 403:yack.c        **** 	if (func == WRITE)
 404:yack.c        **** 	{
 405:yack.c        ****         
 406:yack.c        **** 		if (nr == 1)
 407:yack.c        **** 			eeprom_write_word(&user1, content);
 408:yack.c        **** 		else if (nr == 2)
 409:yack.c        **** 			eeprom_write_word(&user2, content);
 410:yack.c        **** 	}
 411:yack.c        **** 
 412:yack.c        ****     return (FALSE);
 413:yack.c        ****     
 414:yack.c        **** }
 415:yack.c        **** 
 416:yack.c        **** 
 417:yack.c        **** 
 418:yack.c        **** word yackwpm(void)
 419:yack.c        **** /*! 
 420:yack.c        ****  @brief     Retrieves the current WPM speed
 421:yack.c        ****  
 422:yack.c        ****  This function delivers the current WPM speed. 
 423:yack.c        **** 
 424:yack.c        ****  @return        Current speed in WPM
 425:yack.c        ****  
 426:yack.c        ****  */
 427:yack.c        **** {
 428:yack.c        ****     
 429:yack.c        ****     return wpm; 
 430:yack.c        ****     
 431:yack.c        **** }
 432:yack.c        **** 
 433:yack.c        **** 
 434:yack.c        **** void yackspeed (byte dir, byte mode)
 435:yack.c        **** /*! 
 436:yack.c        ****  @brief     Increases or decreases the current WPM speed
 437:yack.c        ****  
 438:yack.c        ****  The amount of increase or decrease is in amounts of wpmcnt. Those are close to real
 439:yack.c        ****  WPM in a 10ms heartbeat but can significantly differ at higher heartbeat speeds.
 440:yack.c        ****  
 441:yack.c        ****  @param dir     UP (faster) or DOWN (slower)
 442:yack.c        ****  
 443:yack.c        ****  */
 444:yack.c        **** {
 445:yack.c        ****     
 446:yack.c        ****     if (mode == FARNSWORTH)
 447:yack.c        ****     {
 448:yack.c        ****         if ((dir == UP) && (farnsworth > 0))
 449:yack.c        ****             farnsworth--;
 450:yack.c        ****         
 451:yack.c        ****         if ((dir == DOWN) && (farnsworth < MAXFARN))
 452:yack.c        ****             farnsworth++;
 453:yack.c        ****     }
 454:yack.c        ****     else // WPMSPEED
 455:yack.c        ****     {
 456:yack.c        ****         if ((dir == UP) && (wpm < MAXWPM))
 457:yack.c        ****             wpm++;
 458:yack.c        ****         
 459:yack.c        ****         if ((dir == DOWN) && (wpm > MINWPM))
 460:yack.c        ****             wpm--;
 461:yack.c        ****         
 462:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate beats
 463:yack.c        **** 
 464:yack.c        **** 	}
 465:yack.c        **** 	
 466:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 467:yack.c        ****     
 468:yack.c        ****     yackplay(DIT);
 469:yack.c        ****     yackdelay(IEGLEN);	// Inter Element gap  
 470:yack.c        ****     yackplay(DAH);
 471:yack.c        ****     yackdelay(ICGLEN);	// Inter Character gap  
 472:yack.c        ****     yackfarns(); // Additional Farnsworth delay
 473:yack.c        ****     
 474:yack.c        **** }
 475:yack.c        **** 
 476:yack.c        **** 
 477:yack.c        **** 
 478:yack.c        **** void yackbeat (void)
 479:yack.c        **** /*! 
 480:yack.c        ****  @brief     Heartbeat delay
 481:yack.c        ****  
 482:yack.c        ****  Several functions in the keyer are timing dependent. The most prominent example is the
 483:yack.c        ****  yackiambic function that implements the IAMBIC keyer finite state machine.
 484:yack.c        ****  The same expects to be called in intervals of YACKBEAT milliseconds. How this is 
 485:yack.c        ****  implemented is left to the user. In a more complex application this would be done
 486:yack.c        ****  using an interrupt or a timer. For simpler cases this is a busy wait routine
 487:yack.c        ****  that delays exactly YACKBEAT ms.
 488:yack.c        ****  
 489:yack.c        ****  */
 490:yack.c        **** {
 491:yack.c        ****     while((TIFR & (1<<OCF1A)) == 0); // Wait for Timeout
 492:yack.c        ****     TIFR |= (1<<OCF1A);                // Reset output compare flag
 493:yack.c        **** }
 494:yack.c        **** 
 495:yack.c        **** 
 496:yack.c        **** 
 497:yack.c        **** void yackpitch (byte dir)
 498:yack.c        **** /*! 
 499:yack.c        ****  @brief     Increases or decreases the sidetone pitch
 500:yack.c        ****  
 501:yack.c        ****  Changes are done not in Hz but in ctc control values. This is to avoid extensive 
 502:yack.c        ****  calculations at runtime. As is all calculations are done by the preprocessor.
 503:yack.c        ****  
 504:yack.c        ****  @param dir     UP or DOWN
 505:yack.c        ****  
 506:yack.c        ****  */
 507:yack.c        **** {
 508:yack.c        **** 	if (dir == UP)
 509:yack.c        **** 		ctcvalue--;
 510:yack.c        **** 	if (dir == DOWN)
 511:yack.c        **** 		ctcvalue++;
 512:yack.c        **** 	
 513:yack.c        **** 	if (ctcvalue < MAXCTC)
 514:yack.c        **** 		ctcvalue = MAXCTC;
 515:yack.c        **** 	
 516:yack.c        **** 	if (ctcvalue > MINCTC)
 517:yack.c        **** 		ctcvalue = MINCTC;
 518:yack.c        **** 	
 519:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 520:yack.c        **** 	
 521:yack.c        **** }
 522:yack.c        **** 
 523:yack.c        **** 
 524:yack.c        **** 
 525:yack.c        **** 
 526:yack.c        **** void yacktune (void)
 527:yack.c        **** /*! 
 528:yack.c        ****  @brief     Activates Tuning mode
 529:yack.c        ****  
 530:yack.c        ****  This produces a solid keydown for TUNEDURATION seconds. After this the TX is unkeyed.
 531:yack.c        ****  The same can be achieved by presing either the DIT or the DAH contact or the control key.
 532:yack.c        ****  
 533:yack.c        **** */
 534:yack.c        **** {
 535:yack.c        **** 	word timer = YACKSECS(TUNEDURATION);
 536:yack.c        **** 	
 537:yack.c        **** 	key(DOWN);
 538:yack.c        **** 	
 539:yack.c        **** 	while(timer && (KEYINP & (1<<DITPIN)) && (KEYINP & (1<<DAHPIN)) && !yackctrlkey(TRUE) )
 540:yack.c        **** 	{
 541:yack.c        **** 		timer--;
 542:yack.c        **** 		yackbeat();
 543:yack.c        **** 	}
 544:yack.c        **** 	
 545:yack.c        **** 	key(UP);
 546:yack.c        **** }
 547:yack.c        **** 
 548:yack.c        **** 
 549:yack.c        **** 
 550:yack.c        **** 
 551:yack.c        **** void yackmode (byte mode)
 552:yack.c        **** /*! 
 553:yack.c        ****  @brief     Sets the keyer mode (e.g. IAMBIC A)
 554:yack.c        ****  
 555:yack.c        ****  This allows to set the content of the two mode bits in yackflags. Currently only
 556:yack.c        ****  two modes are supported, IAMBIC A and IAMBIC B.
 557:yack.c        ****  
 558:yack.c        ****  @param mode    IAMBICA or IAMBICB
 559:yack.c        ****  @return    TRUE is all was OK, FALSE if configuration lock prevented changes
 560:yack.c        ****  
 561:yack.c        ****  */
 562:yack.c        **** {
 563:yack.c        **** 
 564:yack.c        **** 	yackflags &= ~MODE;
 565:yack.c        **** 	yackflags |= mode;
 566:yack.c        **** 	
 567:yack.c        **** 	volflags |= DIRTYFLAG; // Set the dirty flag	
 568:yack.c        **** 
 569:yack.c        **** }
 570:yack.c        **** 
 571:yack.c        **** 
 572:yack.c        **** byte yackflag(byte flag)
 573:yack.c        **** /*! 
 574:yack.c        ****  @brief     Query feature flags
 575:yack.c        ****  
 576:yack.c        ****  @param flag A byte which indicate which flags are to be queried 
 577:yack.c        ****  @return     0 if the flag(s) were clear, >0 if flag(s) were set
 578:yack.c        ****  
 579:yack.c        ****  */
 580:yack.c        **** {
 581:yack.c        ****     return yackflags & flag;
 582:yack.c        **** }
 583:yack.c        **** 
 584:yack.c        **** 
 585:yack.c        **** 
 586:yack.c        **** void yacktoggle(byte flag)
 587:yack.c        **** /*! 
 588:yack.c        ****  @brief     Toggle feature flags
 589:yack.c        ****  
 590:yack.c        ****  When passed one (or more) flags, this routine flips the according bit in yackflags and
 591:yack.c        ****  thereby enables or disables the corresponding feature.
 592:yack.c        ****  
 593:yack.c        ****  @param flag    A byte where any bit to toggle is set e.g. SIDETONE 
 594:yack.c        ****  @return    TRUE if all was OK, FALSE if configuration lock prevented changes
 595:yack.c        ****  
 596:yack.c        ****  */
 597:yack.c        **** {
 598:yack.c        ****     
 599:yack.c        ****     yackflags ^= flag;      // Toggle the feature bit
 600:yack.c        ****     volflags |= DIRTYFLAG;  // Set the dirty flag	
 601:yack.c        **** 
 602:yack.c        **** }
 603:yack.c        **** 
 604:yack.c        **** 
 605:yack.c        **** 
 606:yack.c        **** 
 607:yack.c        **** void yackerror (void)
 608:yack.c        **** /*! 
 609:yack.c        ****  @brief     Creates a series of 8 dits
 610:yack.c        ****  
 611:yack.c        ****  The error prosign (8 dits) can not be encoded in our coding table. A call to this
 612:yack.c        ****  function produces it..
 613:yack.c        ****  
 614:yack.c        ****  */
 615:yack.c        **** {
 616:yack.c        **** 	byte i;
 617:yack.c        **** 	
 618:yack.c        **** 	for (i=0;i<8;i++)
 619:yack.c        **** 	{
 620:yack.c        **** 		yackplay(DIT);
 621:yack.c        **** 		yackdelay(DITLEN);
 622:yack.c        **** 	}
 623:yack.c        **** 	yackdelay(DAHLEN);
 624:yack.c        **** 	
 625:yack.c        **** }
 626:yack.c        **** 
 627:yack.c        **** 
 628:yack.c        **** 
 629:yack.c        **** 
 630:yack.c        **** // ***************************************************************************
 631:yack.c        **** // CW Playback related functions
 632:yack.c        **** // ***************************************************************************
 633:yack.c        **** 
 634:yack.c        **** static void key(byte mode) 
 635:yack.c        **** /*! 
 636:yack.c        ****  @brief     Keys the transmitter and produces a sidetone
 637:yack.c        ****  
 638:yack.c        ****  .. but only if the corresponding functions (TXKEY and SIDETONE) have been set in
 639:yack.c        ****  the feature register. This function also handles a request to invert the keyer line
 640:yack.c        ****  if necessary (TXINV bit).
 641:yack.c        ****  
 642:yack.c        ****  This is a private function.
 643:yack.c        **** 
 644:yack.c        ****  @param mode    UP or DOWN
 645:yack.c        ****  
 646:yack.c        ****  */
 647:yack.c        **** {
 648:yack.c        **** 	
 649:yack.c        ****     if (mode == DOWN) 
 650:yack.c        ****     {
 651:yack.c        ****         if (volflags & SIDETONE) // Are we generating a Sidetone?
 652:yack.c        ****         {
 653:yack.c        ****             OCR0A = ctcvalue;		// Then switch on the Sidetone generator
 654:yack.c        ****             OCR0B = ctcvalue;
 655:yack.c        ****             
 656:yack.c        ****             // Activate CTC mode
 657:yack.c        ****             TCCR0A |= (1<<COM0B0 | 1<<WGM01);
 658:yack.c        ****             
 659:yack.c        ****             // Configure prescaler
 660:yack.c        ****             TCCR0B = 1<<CS01;
 661:yack.c        ****         }
 662:yack.c        ****         
 663:yack.c        ****         if (volflags & TXKEY) // Are we keying the TX?
 664:yack.c        ****         {
 665:yack.c        ****             if (yackflags & TXINV) // Do we need to invert keying?
 666:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 667:yack.c        ****             else
 668:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 669:yack.c        ****         }
 670:yack.c        **** 
 671:yack.c        ****     }
 672:yack.c        ****     
 673:yack.c        ****     if (mode == UP) 
 674:yack.c        ****     {
 675:yack.c        **** 
 676:yack.c        ****         if (volflags & SIDETONE) // Sidetone active?
 677:yack.c        ****         {
 678:yack.c        ****             TCCR0A = 0;
 679:yack.c        ****             TCCR0B = 0;
 680:yack.c        ****         }
 681:yack.c        ****         
 682:yack.c        ****         if (volflags & TXKEY) // Are we keying the TX?
 683:yack.c        ****         {
 684:yack.c        ****             if (yackflags & TXINV) // Do we need to invert keying?
 685:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 686:yack.c        ****             else
 687:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 688:yack.c        ****         }
 689:yack.c        **** 
 690:yack.c        ****     }
 691:yack.c        ****     
 692:yack.c        **** }
 693:yack.c        **** 
 694:yack.c        **** 
 695:yack.c        **** 
 696:yack.c        **** void yackfarns(void)
 697:yack.c        **** /*! 
 698:yack.c        ****  @brief     Produces an additional waiting delay for farnsworth mode.
 699:yack.c        ****  
 700:yack.c        ****  */
 701:yack.c        **** {
 702:yack.c        **** 	
 703:yack.c        ****     word i=farnsworth;
 704:yack.c        **** 	
 705:yack.c        **** 	while (i--)
 706:yack.c        **** 	{
 707:yack.c        ****     	yackdelay(1);
 708:yack.c        **** 	}
 709:yack.c        **** 	
 710:yack.c        **** }
 711:yack.c        **** 
 712:yack.c        **** 
 713:yack.c        **** 
 714:yack.c        **** void yackdelay(byte n)
 715:yack.c        **** /*! 
 716:yack.c        ****  @brief     Produces an active waiting delay for n dot counts
 717:yack.c        ****  
 718:yack.c        ****  This is used during the playback functions where active waiting is needed
 719:yack.c        ****  
 720:yack.c        ****  @param n   number of dot durations to delay (dependent on current keying speed!
 721:yack.c        ****  
 722:yack.c        ****  */
 723:yack.c        **** {
 724:yack.c        **** 	
 725:yack.c        **** 	byte i=n;
 726:yack.c        **** 	byte x;
 727:yack.c        **** 	
 728:yack.c        **** 	while (i--)
 729:yack.c        **** 	{
 730:yack.c        **** 		x=wpmcnt;
 731:yack.c        **** 		while (x--)    
 732:yack.c        **** 			yackbeat();
 733:yack.c        **** 	}
 734:yack.c        **** 	
 735:yack.c        **** }
 736:yack.c        **** 
 737:yack.c        **** 
 738:yack.c        **** 
 739:yack.c        **** 
 740:yack.c        **** void yackplay(byte i) 
 741:yack.c        **** /*! 
 742:yack.c        ****  @brief     Key the TX / Sidetone for the duration of a dit or a dah
 743:yack.c        ****  
 744:yack.c        ****  @param i   DIT or DAH
 745:yack.c        ****  
 746:yack.c        ****  */
 747:yack.c        **** {
 748:yack.c        **** 	
 749:yack.c        ****     key(DOWN); 
 750:yack.c        **** 
 751:yack.c        **** #ifdef POWERSAVE
 752:yack.c        ****     
 753:yack.c        ****     yackpower(FALSE); // Avoid powerdowns when keying
 754:yack.c        ****     
 755:yack.c        **** #endif
 756:yack.c        ****     
 757:yack.c        **** 	switch (i)
 758:yack.c        **** 	{
 759:yack.c        **** 		case DAH:
 760:yack.c        **** 			yackdelay(DAHLEN);
 761:yack.c        **** 			break;
 762:yack.c        **** 			
 763:yack.c        **** 		case DIT:
 764:yack.c        **** 			yackdelay(DITLEN);
 765:yack.c        **** 			break;
 766:yack.c        **** 	}
 767:yack.c        ****     
 768:yack.c        ****     key(UP);
 769:yack.c        **** 	
 770:yack.c        **** }
 771:yack.c        **** 
 772:yack.c        **** 
 773:yack.c        **** 
 774:yack.c        **** 
 775:yack.c        **** void yackchar(char c)
 776:yack.c        **** /*! 
 777:yack.c        ****  @brief     Send a character in morse code
 778:yack.c        ****  
 779:yack.c        ****  This function translates a character passed as parameter into morse code using the 
 780:yack.c        ****  translation table in Flash memory. It then keys transmitter / sidetone with the characters
 781:yack.c        ****  elements and adds all necessary gaps (as if the character was part of a longer word).
 782:yack.c        ****  
 783:yack.c        ****  If the character can not be translated, nothing is sent.
 784:yack.c        ****  
 785:yack.c        ****  If a space is received, an interword gap is sent.
 786:yack.c        ****   
 787:yack.c        ****  @param c   The character to send
 788:yack.c        ****  
 789:yack.c        **** */
 790:yack.c        **** 
 791:yack.c        **** 
 792:yack.c        **** {
 793:yack.c        **** 	byte	code=0x80; // 0x80 is an empty morse character (just eoc bit set)
 794:yack.c        **** 	byte 	i; // a counter
 795:yack.c        **** 	
 796:yack.c        **** 	// First we need to map the actual character to the encoded morse sequence in
 797:yack.c        **** 	// the array "morse"
 798:yack.c        **** 	if(c>='0' && c<='9') // Is it a numerical digit?
 799:yack.c        **** 		code = pgm_read_byte(&morse[c-'0']); // Find it in the beginning of array
 800:yack.c        ****     
 801:yack.c        **** 	if(c>='a' && c<='z') // Is it a character?
 802:yack.c        **** 		code = pgm_read_byte(&morse[c-'a'+10]); // Find it from position 10
 803:yack.c        **** 	
 804:yack.c        **** 	if(c>='A' && c<='Z') // Is it a character in upper case?
 805:yack.c        **** 		code = pgm_read_byte(&morse[c-'A'+10]); // Same as above
 806:yack.c        **** 	
 807:yack.c        **** 	// Last we need to handle special characters. There is a small char
 808:yack.c        **** 	// array "spechar" which contains the characters for the morse elements
 809:yack.c        **** 	// at the end of the "morse" array (see there!)
 810:yack.c        **** 	for(i=0;i<sizeof(spechar);i++) // Read through the array
 811:yack.c        **** 		if (c == pgm_read_byte(&spechar[i])) // Does it contain our character
 812:yack.c        **** 			code = pgm_read_byte(&morse[i+36]); // Map it to morse code
 813:yack.c        **** 	
 814:yack.c        **** 	if(c==' ') // Do they want us to transmit a space (a gap of 7 dots)
 815:yack.c        **** 		yackdelay(IWGLEN-ICGLEN); // ICG was already played after previous char
 816:yack.c        **** 	else
 817:yack.c        **** 	{
 818:yack.c        ****   		while (code != 0x80) // Stop when EOC bit has reached MSB
 819:yack.c        ****   		{
 820:yack.c        **** 			if (yackctrlkey(FALSE)) // Stop playing if someone pushes key
 821:yack.c        **** 				return;
 822:yack.c        **** 			
 823:yack.c        ****      		if (code & 0x80) 	// MSB set ?
 824:yack.c        ****        			yackplay(DAH);      // ..then play a dash
 825:yack.c        ****      		else				// MSB cleared ?
 826:yack.c        ****        			yackplay(DIT);		// .. then play a dot
 827:yack.c        **** 			
 828:yack.c        ****      		yackdelay(IEGLEN);	// Inter Element gap  
 829:yack.c        ****             
 830:yack.c        ****      		code = code << 1;	// Shift code on position left (to next element)
 831:yack.c        ****   		}
 832:yack.c        **** 		
 833:yack.c        ****   		yackdelay(ICGLEN - IEGLEN); // IEG was already played after element
 834:yack.c        **** 
 835:yack.c        ****         yackfarns(); // Insert another gap for farnsworth keying
 836:yack.c        **** 
 837:yack.c        **** 	}
 838:yack.c        **** 	
 839:yack.c        **** }
 840:yack.c        **** 
 841:yack.c        **** 
 842:yack.c        **** 
 843:yack.c        **** void yackstring(const char *p)
 844:yack.c        **** /*! 
 845:yack.c        ****  @brief     Sends a 0-terminated string in CW which resides in Flash
 846:yack.c        ****  
 847:yack.c        ****  Reads character by character from flash, translates into CW and keys the transmitter
 848:yack.c        ****  and/or sidetone depending on feature bit settings.
 849:yack.c        ****  
 850:yack.c        ****  @param p   Pointer to string location in FLASH 
 851:yack.c        ****  
 852:yack.c        ****  */
 853:yack.c        **** {
 854:yack.c        **** 	
 855:yack.c        **** 	char c;
 856:yack.c        **** 	
 857:yack.c        **** 	while ((c = pgm_read_byte(p++))&& !(yackctrlkey(TRUE)) )
 858:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 859:yack.c        **** 		yackchar(c);            // Play the read character
 860:yack.c        **** 								// abort now if someone presses command key
 861:yack.c        **** 	
 862:yack.c        **** }
 863:yack.c        **** 
 864:yack.c        **** 
 865:yack.c        **** 
 866:yack.c        **** void yacknumber(word n)
 867:yack.c        **** /*! 
 868:yack.c        ****  @brief     Sends a number in CW
 869:yack.c        ****  
 870:yack.c        ****  Transforms a number up to 65535 into its digits and sends them in CW
 871:yack.c        ****  
 872:yack.c        ****  @param n   The number to send
 873:yack.c        ****  
 874:yack.c        ****  */
 875:yack.c        **** 
 876:yack.c        **** {
 877:yack.c        ****     
 878:yack.c        ****     char buffer[5];
 879:yack.c        ****     byte i = 0;
 880:yack.c        **** 	
 881:yack.c        **** 	while (n) // Until nothing left or control key pressed
 882:yack.c        **** 	{
 883:yack.c        **** 		buffer[i++] = n%10+'0'; // Store rest of division by 10
 884:yack.c        **** 		n /= 10;                // Divide by 10
 885:yack.c        **** 	}
 886:yack.c        **** 	
 887:yack.c        ****     while (i)
 888:yack.c        ****     {
 889:yack.c        **** 		if (yackctrlkey(TRUE)) {break;}
 890:yack.c        ****         yackchar(buffer[--i]);
 891:yack.c        ****     }
 892:yack.c        ****     
 893:yack.c        ****     yackchar (' ');
 894:yack.c        ****     
 895:yack.c        **** }
 896:yack.c        **** 
 897:yack.c        **** 
 898:yack.c        **** 
 899:yack.c        **** // ***************************************************************************
 900:yack.c        **** // CW Keying related functions
 901:yack.c        **** // ***************************************************************************
 902:yack.c        **** 
 903:yack.c        **** 
 904:yack.c        **** static void keylatch(void)
 905:yack.c        **** /*! 
 906:yack.c        ****  @brief     Latches the status of the DIT and DAH paddles
 907:yack.c        ****  
 908:yack.c        ****  If either DIT or DAH are keyed, this function sets the corresponding bit in 
 909:yack.c        ****  volflags. This is used by the IAMBIC keyer to determine which element needs to 
 910:yack.c        ****  be sounded next.
 911:yack.c        ****  
 912:yack.c        ****  This is a private function.
 913:yack.c        **** 
 914:yack.c        ****  */
 915:yack.c        **** {
 123               	.LM0:
 124               	.LFBB1:
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 0 */
 128               	.L__stack_usage = 0
 916:yack.c        **** 	
 917:yack.c        **** 	byte	swap;	 // Status of swap flag
 918:yack.c        **** 	
 919:yack.c        **** 	swap    = ( yackflags & PDLSWAP);
 130               	.LM1:
 131 0000 8091 0000 		lds r24,yackflags
 132 0004 8078      		andi r24,lo8(-128)
 920:yack.c        **** 	
 921:yack.c        **** 	if (!( KEYINP & (1<<DITPIN)))
 134               	.LM2:
 135 0006 B399      		sbic 0x16,3
 136 0008 00C0      		rjmp .L2
 922:yack.c        **** 		volflags |= (swap?DAHLATCH:DITLATCH);
 138               	.LM3:
 139 000a 8111      		cpse r24,__zero_reg__
 140 000c 00C0      		rjmp .L6
 141 000e 91E0      		ldi r25,lo8(1)
 142 0010 00C0      		rjmp .L3
 143               	.L6:
 144 0012 92E0      		ldi r25,lo8(2)
 145               	.L3:
 147               	.LM4:
 148 0014 2091 0000 		lds r18,volflags
 149 0018 922B      		or r25,r18
 150 001a 9093 0000 		sts volflags,r25
 151               	.L2:
 923:yack.c        **** 	
 924:yack.c        **** 	if (!( KEYINP & (1<<DAHPIN)))
 153               	.LM5:
 154 001e B499      		sbic 0x16,4
 155 0020 00C0      		rjmp .L1
 925:yack.c        **** 		volflags |= (swap?DITLATCH:DAHLATCH);
 157               	.LM6:
 158 0022 8111      		cpse r24,__zero_reg__
 159 0024 00C0      		rjmp .L7
 160 0026 82E0      		ldi r24,lo8(2)
 161 0028 00C0      		rjmp .L5
 162               	.L7:
 163 002a 81E0      		ldi r24,lo8(1)
 164               	.L5:
 166               	.LM7:
 167 002c 9091 0000 		lds r25,volflags
 168 0030 892B      		or r24,r25
 169 0032 8093 0000 		sts volflags,r24
 170               	.L1:
 171 0036 0895      		ret
 176               	.Lscope1:
 179               	key.part.0:
 634:yack.c        **** /*! 
 181               	.LM8:
 182               	.LFBB2:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
 676:yack.c        ****         {
 188               	.LM9:
 189 0038 8091 0000 		lds r24,volflags
 190 003c 84FF      		sbrs r24,4
 191 003e 00C0      		rjmp .L10
 678:yack.c        ****             TCCR0B = 0;
 193               	.LM10:
 194 0040 1ABC      		out 0x2a,__zero_reg__
 679:yack.c        ****         }
 196               	.LM11:
 197 0042 13BE      		out 0x33,__zero_reg__
 198               	.L10:
 682:yack.c        ****         {
 200               	.LM12:
 201 0044 8091 0000 		lds r24,volflags
 202 0048 85FF      		sbrs r24,5
 203 004a 00C0      		rjmp .L9
 684:yack.c        ****                 SETBIT(OUTPORT,OUTPIN);
 205               	.LM13:
 206 004c 8091 0000 		lds r24,yackflags
 207 0050 86FF      		sbrs r24,6
 208 0052 00C0      		rjmp .L12
 685:yack.c        ****             else
 210               	.LM14:
 211 0054 C09A      		sbi 0x18,0
 212 0056 0895      		ret
 213               	.L12:
 687:yack.c        ****         }
 215               	.LM15:
 216 0058 C098      		cbi 0x18,0
 217               	.L9:
 218 005a 0895      		ret
 220               	.Lscope2:
 223               	yackinhibit.part.3:
 348:yack.c        **** /*! 
 225               	.LM16:
 226               	.LFBB3:
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
 370:yack.c        ****         key(UP);
 232               	.LM17:
 233 005c 8091 0000 		lds r24,yackflags
 234 0060 982F      		mov r25,r24
 235 0062 9073      		andi r25,lo8(48)
 236 0064 8091 0000 		lds r24,volflags
 237 0068 8F7C      		andi r24,lo8(-49)
 238 006a 892B      		or r24,r25
 239 006c 8093 0000 		sts volflags,r24
 240               	.LBB23:
 241               	.LBB24:
 242 0070 00C0      		rjmp key.part.0
 243               	.LBE24:
 244               	.LBE23:
 246               	.Lscope3:
 249               	key.constprop.4:
 634:yack.c        **** /*! 
 251               	.LM18:
 252               	.LFBB4:
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 0 */
 256               	.L__stack_usage = 0
 651:yack.c        ****         {
 258               	.LM19:
 259 0072 8091 0000 		lds r24,volflags
 260 0076 84FF      		sbrs r24,4
 261 0078 00C0      		rjmp .L21
 653:yack.c        ****             OCR0B = ctcvalue;
 263               	.LM20:
 264 007a 8091 0000 		lds r24,ctcvalue
 265 007e 89BD      		out 0x29,r24
 654:yack.c        ****             
 267               	.LM21:
 268 0080 8091 0000 		lds r24,ctcvalue
 269 0084 88BD      		out 0x28,r24
 657:yack.c        ****             
 271               	.LM22:
 272 0086 8AB5      		in r24,0x2a
 273 0088 8261      		ori r24,lo8(18)
 274 008a 8ABD      		out 0x2a,r24
 660:yack.c        ****         }
 276               	.LM23:
 277 008c 82E0      		ldi r24,lo8(2)
 278 008e 83BF      		out 0x33,r24
 279               	.L21:
 663:yack.c        ****         {
 281               	.LM24:
 282 0090 8091 0000 		lds r24,volflags
 283 0094 85FF      		sbrs r24,5
 284 0096 00C0      		rjmp .L20
 665:yack.c        ****                 CLEARBIT(OUTPORT,OUTPIN);
 286               	.LM25:
 287 0098 8091 0000 		lds r24,yackflags
 288 009c 86FF      		sbrs r24,6
 289 009e 00C0      		rjmp .L23
 666:yack.c        ****             else
 291               	.LM26:
 292 00a0 C098      		cbi 0x18,0
 293 00a2 0895      		ret
 294               	.L23:
 668:yack.c        ****         }
 296               	.LM27:
 297 00a4 C09A      		sbi 0x18,0
 298               	.L20:
 299 00a6 0895      		ret
 301               	.Lscope4:
 303               	.global	__vector_2
 305               	__vector_2:
 267:yack.c        ****     // Nothing to do here. All we want is to wake up..
 307               	.LM28:
 308               	.LFBB5:
 309 00a8 1F92      		push r1
 310 00aa 0F92      		push r0
 311 00ac 0FB6      		in r0,__SREG__
 312 00ae 0F92      		push r0
 313 00b0 1124      		clr __zero_reg__
 314               	/* prologue: Signal */
 315               	/* frame size = 0 */
 316               	/* stack size = 3 */
 317               	.L__stack_usage = 3
 318               	/* epilogue start */
 269:yack.c        **** 
 320               	.LM29:
 321 00b2 0F90      		pop r0
 322 00b4 0FBE      		out __SREG__,r0
 323 00b6 0F90      		pop r0
 324 00b8 1F90      		pop r1
 325 00ba 1895      		reti
 327               	.Lscope5:
 330               	.global	yackpower
 332               	yackpower:
 287:yack.c        ****     static uint32_t shdntimer=0;
 334               	.LM30:
 335               	.LFBB6:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 290:yack.c        ****     {
 341               	.LM31:
 342 00bc 8823      		tst r24
 343 00be 01F0      		breq .L32
 292:yack.c        ****         {
 345               	.LM32:
 346 00c0 8091 0000 		lds r24,shdntimer.2031
 347 00c4 9091 0000 		lds r25,shdntimer.2031+1
 348 00c8 A091 0000 		lds r26,shdntimer.2031+2
 349 00cc B091 0000 		lds r27,shdntimer.2031+3
 350 00d0 8037      		cpi r24,112
 351 00d2 27E1      		ldi r18,23
 352 00d4 9207      		cpc r25,r18
 353 00d6 A105      		cpc r26,__zero_reg__
 354 00d8 B105      		cpc r27,__zero_reg__
 355 00da 01F0      		breq .L33
 356 00dc 0196      		adiw r24,1
 357 00de A11D      		adc r26,__zero_reg__
 358 00e0 B11D      		adc r27,__zero_reg__
 359 00e2 8093 0000 		sts shdntimer.2031,r24
 360 00e6 9093 0000 		sts shdntimer.2031+1,r25
 361 00ea A093 0000 		sts shdntimer.2031+2,r26
 362 00ee B093 0000 		sts shdntimer.2031+3,r27
 363 00f2 0895      		ret
 364               	.L33:
 365               	.LBB28:
 366               	.LBB29:
 294:yack.c        **** 
 368               	.LM33:
 369 00f4 1092 0000 		sts shdntimer.2031,__zero_reg__
 370 00f8 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 371 00fc 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 372 0100 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 296:yack.c        ****             sleep_bod_disable();
 374               	.LM34:
 375 0104 85B7      		in r24,0x35
 376 0106 877E      		andi r24,lo8(-25)
 377 0108 8061      		ori r24,lo8(16)
 378 010a 85BF      		out 0x35,r24
 379               	.LBB30:
 297:yack.c        ****             sleep_enable();
 381               	.LM35:
 382               	/* #APP */
 383               	 ;  297 "yack.c" 1
 384 010c 85B7      		in r24, 53
 385 010e 8468      		ori r24, 132
 386 0110 85BF      		out 53, r24
 387 0112 8B7F      		andi r24, -5
 388 0114 85BF      		out 53, r24
 389               	 ;  0 "" 2
 390               	/* #NOAPP */
 391               	.LBE30:
 298:yack.c        ****             sei();
 393               	.LM36:
 394 0116 85B7      		in r24,0x35
 395 0118 8062      		ori r24,lo8(32)
 396 011a 85BF      		out 0x35,r24
 299:yack.c        ****             sleep_cpu();
 398               	.LM37:
 399               	/* #APP */
 400               	 ;  299 "yack.c" 1
 401 011c 7894      		sei
 402               	 ;  0 "" 2
 300:yack.c        ****             cli();
 404               	.LM38:
 405               	 ;  300 "yack.c" 1
 406 011e 8895      		sleep
 407               		
 408               	 ;  0 "" 2
 301:yack.c        ****             
 410               	.LM39:
 411               	 ;  301 "yack.c" 1
 412 0120 F894      		cli
 413               	 ;  0 "" 2
 414               	/* #NOAPP */
 415 0122 0895      		ret
 416               	.L32:
 417               	.LBE29:
 418               	.LBE28:
 311:yack.c        ****     }
 420               	.LM40:
 421 0124 1092 0000 		sts shdntimer.2031,__zero_reg__
 422 0128 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 423 012c 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 424 0130 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 425 0134 0895      		ret
 430               	.Lscope6:
 432               	.global	yacksave
 434               	yacksave:
 330:yack.c        **** 	
 436               	.LM41:
 437               	.LFBB7:
 438               	/* prologue: function */
 439               	/* frame size = 0 */
 440               	/* stack size = 0 */
 441               	.L__stack_usage = 0
 332:yack.c        **** 	{	
 443               	.LM42:
 444 0136 8091 0000 		lds r24,volflags
 445 013a 82FF      		sbrs r24,2
 446 013c 00C0      		rjmp .L35
 447               	.LBB33:
 448               	.LBB34:
 335:yack.c        **** 		eeprom_write_word(&ctcstor, ctcvalue);
 450               	.LM43:
 451 013e 65EA      		ldi r22,lo8(-91)
 452 0140 80E0      		ldi r24,lo8(magic)
 453 0142 90E0      		ldi r25,hi8(magic)
 454 0144 00D0      		rcall eeprom_write_byte
 336:yack.c        **** 		eeprom_write_byte(&wpmstor, wpm);
 456               	.LM44:
 457 0146 6091 0000 		lds r22,ctcvalue
 458 014a 7091 0000 		lds r23,ctcvalue+1
 459 014e 80E0      		ldi r24,lo8(ctcstor)
 460 0150 90E0      		ldi r25,hi8(ctcstor)
 461 0152 00D0      		rcall eeprom_write_word
 337:yack.c        **** 		eeprom_write_byte(&flagstor, yackflags);
 463               	.LM45:
 464 0154 6091 0000 		lds r22,wpm
 465 0158 80E0      		ldi r24,lo8(wpmstor)
 466 015a 90E0      		ldi r25,hi8(wpmstor)
 467 015c 00D0      		rcall eeprom_write_byte
 338:yack.c        ****         eeprom_write_byte(&fwstor, farnsworth);
 469               	.LM46:
 470 015e 6091 0000 		lds r22,yackflags
 471 0162 80E0      		ldi r24,lo8(flagstor)
 472 0164 90E0      		ldi r25,hi8(flagstor)
 473 0166 00D0      		rcall eeprom_write_byte
 339:yack.c        **** 		
 475               	.LM47:
 476 0168 6091 0000 		lds r22,farnsworth
 477 016c 80E0      		ldi r24,lo8(fwstor)
 478 016e 90E0      		ldi r25,hi8(fwstor)
 479 0170 00D0      		rcall eeprom_write_byte
 341:yack.c        **** 	}
 481               	.LM48:
 482 0172 8091 0000 		lds r24,volflags
 483 0176 8B7F      		andi r24,lo8(-5)
 484 0178 8093 0000 		sts volflags,r24
 485               	.L35:
 486 017c 0895      		ret
 487               	.LBE34:
 488               	.LBE33:
 490               	.Lscope7:
 492               	.global	yackreset
 494               	yackreset:
 187:yack.c        **** 
 496               	.LM49:
 497               	.LFBB8:
 498               	/* prologue: function */
 499               	/* frame size = 0 */
 500               	/* stack size = 0 */
 501               	.L__stack_usage = 0
 189:yack.c        ****     wpm=DEFWPM; // Init to default speed
 503               	.LM50:
 504 017e 8DE4      		ldi r24,lo8(77)
 505 0180 90E0      		ldi r25,0
 506 0182 9093 0000 		sts ctcvalue+1,r25
 507 0186 8093 0000 		sts ctcvalue,r24
 190:yack.c        **** 	wpmcnt=(1200/YACKBEAT)/DEFWPM; // default speed
 509               	.LM51:
 510 018a 8FE0      		ldi r24,lo8(15)
 511 018c 8093 0000 		sts wpm,r24
 191:yack.c        ****     farnsworth=0; // No Farnsworth gap
 513               	.LM52:
 514 0190 80E1      		ldi r24,lo8(16)
 515 0192 90E0      		ldi r25,0
 516 0194 9093 0000 		sts wpmcnt+1,r25
 517 0198 8093 0000 		sts wpmcnt,r24
 192:yack.c        **** 	yackflags = FLAGDEFAULT;  
 519               	.LM53:
 520 019c 1092 0000 		sts farnsworth,__zero_reg__
 193:yack.c        **** 
 522               	.LM54:
 523 01a0 84E3      		ldi r24,lo8(52)
 524 01a2 8093 0000 		sts yackflags,r24
 195:yack.c        **** 	yacksave(); // Store them in EEPROM
 526               	.LM55:
 527 01a6 8091 0000 		lds r24,volflags
 528 01aa 8460      		ori r24,lo8(4)
 529 01ac 8093 0000 		sts volflags,r24
 196:yack.c        **** 
 531               	.LM56:
 532 01b0 00C0      		rjmp yacksave
 534               	.Lscope8:
 536               	.global	yackinit
 538               	yackinit:
 210:yack.c        **** 	
 540               	.LM57:
 541               	.LFBB9:
 542               	/* prologue: function */
 543               	/* frame size = 0 */
 544               	/* stack size = 0 */
 545               	.L__stack_usage = 0
 215:yack.c        **** 	SETBIT (STDDR,STPIN);
 547               	.LM58:
 548 01b2 B89A      		sbi 0x17,0
 216:yack.c        **** 	
 550               	.LM59:
 551 01b4 B99A      		sbi 0x17,1
 219:yack.c        **** 	SETBIT (KEYPORT,DAHPIN);
 553               	.LM60:
 554 01b6 C39A      		sbi 0x18,3
 220:yack.c        **** 	SETBIT (BTNPORT,BTNPIN);
 556               	.LM61:
 557 01b8 C49A      		sbi 0x18,4
 221:yack.c        **** 	
 559               	.LM62:
 560 01ba C29A      		sbi 0x18,2
 223:yack.c        **** 	
 562               	.LM63:
 563 01bc 80E0      		ldi r24,lo8(magic)
 564 01be 90E0      		ldi r25,hi8(magic)
 565 01c0 00D0      		rcall eeprom_read_byte
 225:yack.c        **** 	{
 567               	.LM64:
 568 01c2 853A      		cpi r24,lo8(-91)
 569 01c4 01F4      		brne .L42
 227:yack.c        **** 		wpm = eeprom_read_byte(&wpmstor); // Retrieve last wpm setting
 571               	.LM65:
 572 01c6 80E0      		ldi r24,lo8(ctcstor)
 573 01c8 90E0      		ldi r25,hi8(ctcstor)
 574 01ca 00D0      		rcall eeprom_read_word
 575 01cc 9093 0000 		sts ctcvalue+1,r25
 576 01d0 8093 0000 		sts ctcvalue,r24
 228:yack.c        ****         wpmcnt=(1200/YACKBEAT)/wpm; // Calculate speed
 578               	.LM66:
 579 01d4 80E0      		ldi r24,lo8(wpmstor)
 580 01d6 90E0      		ldi r25,hi8(wpmstor)
 581 01d8 00D0      		rcall eeprom_read_byte
 582 01da 8093 0000 		sts wpm,r24
 229:yack.c        **** 		farnsworth = eeprom_read_byte(&fwstor); // Retrieve last wpm setting	
 584               	.LM67:
 585 01de 682F      		mov r22,r24
 586 01e0 70E0      		ldi r23,0
 587 01e2 80EF      		ldi r24,lo8(-16)
 588 01e4 90E0      		ldi r25,0
 589 01e6 00D0      		rcall __divmodhi4
 590 01e8 7093 0000 		sts wpmcnt+1,r23
 591 01ec 6093 0000 		sts wpmcnt,r22
 230:yack.c        **** 		yackflags = eeprom_read_byte(&flagstor); // Retrieve last flags	
 593               	.LM68:
 594 01f0 80E0      		ldi r24,lo8(fwstor)
 595 01f2 90E0      		ldi r25,hi8(fwstor)
 596 01f4 00D0      		rcall eeprom_read_byte
 597 01f6 8093 0000 		sts farnsworth,r24
 231:yack.c        **** 	}
 599               	.LM69:
 600 01fa 80E0      		ldi r24,lo8(flagstor)
 601 01fc 90E0      		ldi r25,hi8(flagstor)
 602 01fe 00D0      		rcall eeprom_read_byte
 603 0200 8093 0000 		sts yackflags,r24
 604 0204 00C0      		rjmp .L43
 605               	.L42:
 235:yack.c        **** 	}	
 607               	.LM70:
 608 0206 00D0      		rcall yackreset
 609               	.L43:
 610               	.LBB35:
 611               	.LBB36:
 612 0208 00D0      		rcall yackinhibit.part.3
 613               	.LBE36:
 614               	.LBE35:
 242:yack.c        ****     GIMSK |= (1<<PCIE);  // Enable pin change interrupt
 616               	.LM71:
 617 020a 85B3      		in r24,0x15
 618 020c 8C61      		ori r24,lo8(28)
 619 020e 85BB      		out 0x15,r24
 243:yack.c        ****     
 621               	.LM72:
 622 0210 8BB7      		in r24,0x3b
 623 0212 8062      		ori r24,lo8(32)
 624 0214 8BBF      		out 0x3b,r24
 251:yack.c        ****     TCCR1 |= (1<<CTC1) | 0b00000111 ; // Clear Timer on match, prescale ck by 64
 626               	.LM73:
 627 0216 8EE4      		ldi r24,lo8(78)
 628 0218 8DBD      		out 0x2d,r24
 252:yack.c        ****     OCR1A = 1; // CTC mode does not create an overflow so we use OCR1A
 630               	.LM74:
 631 021a 80B7      		in r24,0x30
 632 021c 8768      		ori r24,lo8(-121)
 633 021e 80BF      		out 0x30,r24
 253:yack.c        ****     
 635               	.LM75:
 636 0220 81E0      		ldi r24,lo8(1)
 637 0222 8EBD      		out 0x2e,r24
 638 0224 0895      		ret
 640               	.Lscope9:
 643               	.global	yackinhibit
 645               	yackinhibit:
 358:yack.c        **** 	
 647               	.LM76:
 648               	.LFBB10:
 649               	/* prologue: function */
 650               	/* frame size = 0 */
 651               	/* stack size = 0 */
 652               	.L__stack_usage = 0
 360:yack.c        **** 	{
 654               	.LM77:
 655 0226 8823      		tst r24
 656 0228 01F0      		breq .L45
 363:yack.c        **** 	}
 658               	.LM78:
 659 022a 8091 0000 		lds r24,volflags
 660 022e 8F7C      		andi r24,lo8(-49)
 661 0230 8061      		ori r24,lo8(16)
 662 0232 8093 0000 		sts volflags,r24
 663 0236 0895      		ret
 664               	.L45:
 665 0238 00C0      		rjmp yackinhibit.part.3
 667               	.Lscope10:
 672               	.global	yackuser
 674               	yackuser:
 392:yack.c        **** 	
 676               	.LM79:
 677               	.LFBB11:
 678               	/* prologue: function */
 679               	/* frame size = 0 */
 680               	/* stack size = 0 */
 681               	.L__stack_usage = 0
 682 023a 962F      		mov r25,r22
 395:yack.c        **** 	{
 684               	.LM80:
 685 023c 8130      		cpi r24,lo8(1)
 686 023e 01F4      		brne .L49
 397:yack.c        **** 			return (eeprom_read_word(&user1));
 688               	.LM81:
 689 0240 6130      		cpi r22,lo8(1)
 690 0242 01F4      		brne .L50
 398:yack.c        **** 		else if (nr == 2)
 692               	.LM82:
 693 0244 80E0      		ldi r24,lo8(user1)
 694 0246 90E0      		ldi r25,hi8(user1)
 695 0248 00C0      		rjmp .L57
 696               	.L50:
 399:yack.c        **** 			return (eeprom_read_word(&user2));
 698               	.LM83:
 699 024a 6230      		cpi r22,lo8(2)
 700 024c 01F4      		brne .L51
 400:yack.c        **** 	}
 702               	.LM84:
 703 024e 80E0      		ldi r24,lo8(user2)
 704 0250 90E0      		ldi r25,hi8(user2)
 705               	.L57:
 706 0252 00C0      		rjmp eeprom_read_word
 707               	.L49:
 403:yack.c        **** 	{
 709               	.LM85:
 710 0254 8230      		cpi r24,lo8(2)
 711 0256 01F4      		brne .L51
 712 0258 BA01      		movw r22,r20
 406:yack.c        **** 			eeprom_write_word(&user1, content);
 714               	.LM86:
 715 025a 9130      		cpi r25,lo8(1)
 716 025c 01F4      		brne .L52
 407:yack.c        **** 		else if (nr == 2)
 718               	.LM87:
 719 025e 80E0      		ldi r24,lo8(user1)
 720 0260 90E0      		ldi r25,hi8(user1)
 721 0262 00C0      		rjmp .L56
 722               	.L52:
 408:yack.c        **** 			eeprom_write_word(&user2, content);
 724               	.LM88:
 725 0264 9230      		cpi r25,lo8(2)
 726 0266 01F4      		brne .L51
 409:yack.c        **** 	}
 728               	.LM89:
 729 0268 80E0      		ldi r24,lo8(user2)
 730 026a 90E0      		ldi r25,hi8(user2)
 731               	.L56:
 732 026c 00D0      		rcall eeprom_write_word
 733               	.L51:
 414:yack.c        **** 
 735               	.LM90:
 736 026e 80E0      		ldi r24,0
 737 0270 90E0      		ldi r25,0
 738 0272 0895      		ret
 740               	.Lscope11:
 742               	.global	yackwpm
 744               	yackwpm:
 427:yack.c        ****     
 746               	.LM91:
 747               	.LFBB12:
 748               	/* prologue: function */
 749               	/* frame size = 0 */
 750               	/* stack size = 0 */
 751               	.L__stack_usage = 0
 429:yack.c        ****     
 753               	.LM92:
 754 0274 8091 0000 		lds r24,wpm
 431:yack.c        **** 
 756               	.LM93:
 757 0278 90E0      		ldi r25,0
 758 027a 0895      		ret
 760               	.Lscope12:
 762               	.global	yackbeat
 764               	yackbeat:
 490:yack.c        ****     while((TIFR & (1<<OCF1A)) == 0); // Wait for Timeout
 766               	.LM94:
 767               	.LFBB13:
 768               	/* prologue: function */
 769               	/* frame size = 0 */
 770               	/* stack size = 0 */
 771               	.L__stack_usage = 0
 772               	.L60:
 491:yack.c        ****     TIFR |= (1<<OCF1A);                // Reset output compare flag
 774               	.LM95:
 775 027c 08B6      		in __tmp_reg__,0x38
 776 027e 06FE      		sbrs __tmp_reg__,6
 777 0280 00C0      		rjmp .L60
 492:yack.c        **** }
 779               	.LM96:
 780 0282 88B7      		in r24,0x38
 781 0284 8064      		ori r24,lo8(64)
 782 0286 88BF      		out 0x38,r24
 783 0288 0895      		ret
 785               	.Lscope13:
 788               	.global	yackpitch
 790               	yackpitch:
 507:yack.c        **** 	if (dir == UP)
 792               	.LM97:
 793               	.LFBB14:
 794               	/* prologue: function */
 795               	/* frame size = 0 */
 796               	/* stack size = 0 */
 797               	.L__stack_usage = 0
 798 028a 2091 0000 		lds r18,ctcvalue
 799 028e 3091 0000 		lds r19,ctcvalue+1
 508:yack.c        **** 		ctcvalue--;
 801               	.LM98:
 802 0292 8130      		cpi r24,lo8(1)
 803 0294 01F4      		brne .L64
 509:yack.c        **** 	if (dir == DOWN)
 805               	.LM99:
 806 0296 2150      		subi r18,1
 807 0298 3109      		sbc r19,__zero_reg__
 808 029a 00C0      		rjmp .L68
 809               	.L64:
 510:yack.c        **** 		ctcvalue++;
 811               	.LM100:
 812 029c 8230      		cpi r24,lo8(2)
 813 029e 01F4      		brne .L65
 511:yack.c        **** 	
 815               	.LM101:
 816 02a0 2F5F      		subi r18,-1
 817 02a2 3F4F      		sbci r19,-1
 818               	.L68:
 819 02a4 3093 0000 		sts ctcvalue+1,r19
 820 02a8 2093 0000 		sts ctcvalue,r18
 821               	.L65:
 513:yack.c        **** 		ctcvalue = MAXCTC;
 823               	.LM102:
 824 02ac 8091 0000 		lds r24,ctcvalue
 825 02b0 9091 0000 		lds r25,ctcvalue+1
 826 02b4 8897      		sbiw r24,40
 827 02b6 00F4      		brsh .L66
 514:yack.c        **** 	
 829               	.LM103:
 830 02b8 88E2      		ldi r24,lo8(40)
 831 02ba 90E0      		ldi r25,0
 832 02bc 9093 0000 		sts ctcvalue+1,r25
 833 02c0 8093 0000 		sts ctcvalue,r24
 834               	.L66:
 516:yack.c        **** 		ctcvalue = MINCTC;
 836               	.LM104:
 837 02c4 8091 0000 		lds r24,ctcvalue
 838 02c8 9091 0000 		lds r25,ctcvalue+1
 839 02cc 8C39      		cpi r24,-100
 840 02ce 9105      		cpc r25,__zero_reg__
 841 02d0 00F0      		brlo .L67
 517:yack.c        **** 	
 843               	.LM105:
 844 02d2 8BE9      		ldi r24,lo8(-101)
 845 02d4 90E0      		ldi r25,0
 846 02d6 9093 0000 		sts ctcvalue+1,r25
 847 02da 8093 0000 		sts ctcvalue,r24
 848               	.L67:
 519:yack.c        **** 	
 850               	.LM106:
 851 02de 8091 0000 		lds r24,volflags
 852 02e2 8460      		ori r24,lo8(4)
 853 02e4 8093 0000 		sts volflags,r24
 854 02e8 0895      		ret
 856               	.Lscope14:
 859               	.global	yackmode
 861               	yackmode:
 562:yack.c        **** 
 863               	.LM107:
 864               	.LFBB15:
 865               	/* prologue: function */
 866               	/* frame size = 0 */
 867               	/* stack size = 0 */
 868               	.L__stack_usage = 0
 565:yack.c        **** 	
 870               	.LM108:
 871 02ea 9091 0000 		lds r25,yackflags
 872 02ee 937F      		andi r25,lo8(-13)
 873 02f0 892B      		or r24,r25
 874 02f2 8093 0000 		sts yackflags,r24
 567:yack.c        **** 
 876               	.LM109:
 877 02f6 8091 0000 		lds r24,volflags
 878 02fa 8460      		ori r24,lo8(4)
 879 02fc 8093 0000 		sts volflags,r24
 880 0300 0895      		ret
 882               	.Lscope15:
 885               	.global	yackflag
 887               	yackflag:
 580:yack.c        ****     return yackflags & flag;
 889               	.LM110:
 890               	.LFBB16:
 891               	/* prologue: function */
 892               	/* frame size = 0 */
 893               	/* stack size = 0 */
 894               	.L__stack_usage = 0
 581:yack.c        **** }
 896               	.LM111:
 897 0302 9091 0000 		lds r25,yackflags
 582:yack.c        **** 
 899               	.LM112:
 900 0306 8923      		and r24,r25
 901 0308 0895      		ret
 903               	.Lscope16:
 906               	.global	yacktoggle
 908               	yacktoggle:
 597:yack.c        ****     
 910               	.LM113:
 911               	.LFBB17:
 912               	/* prologue: function */
 913               	/* frame size = 0 */
 914               	/* stack size = 0 */
 915               	.L__stack_usage = 0
 599:yack.c        ****     volflags |= DIRTYFLAG;  // Set the dirty flag	
 917               	.LM114:
 918 030a 9091 0000 		lds r25,yackflags
 919 030e 8927      		eor r24,r25
 920 0310 8093 0000 		sts yackflags,r24
 600:yack.c        **** 
 922               	.LM115:
 923 0314 8091 0000 		lds r24,volflags
 924 0318 8460      		ori r24,lo8(4)
 925 031a 8093 0000 		sts volflags,r24
 926 031e 0895      		ret
 928               	.Lscope17:
 931               	.global	yackdelay
 933               	yackdelay:
 723:yack.c        **** 	
 935               	.LM116:
 936               	.LFBB18:
 937 0320 CF93      		push r28
 938 0322 DF93      		push r29
 939               	/* prologue: function */
 940               	/* frame size = 0 */
 941               	/* stack size = 2 */
 942               	.L__stack_usage = 2
 943 0324 C82F      		mov r28,r24
 944               	.L73:
 728:yack.c        **** 	{
 946               	.LM117:
 947 0326 CC23      		tst r28
 948 0328 01F0      		breq .L77
 730:yack.c        **** 		while (x--)    
 950               	.LM118:
 951 032a D091 0000 		lds r29,wpmcnt
 952               	.L74:
 731:yack.c        **** 			yackbeat();
 954               	.LM119:
 955 032e DD23      		tst r29
 956 0330 01F0      		breq .L78
 732:yack.c        **** 	}
 958               	.LM120:
 959 0332 00D0      		rcall yackbeat
 960 0334 D150      		subi r29,lo8(-(-1))
 961 0336 00C0      		rjmp .L74
 962               	.L78:
 963 0338 C150      		subi r28,lo8(-(-1))
 964 033a 00C0      		rjmp .L73
 965               	.L77:
 966               	/* epilogue start */
 735:yack.c        **** 
 968               	.LM121:
 969 033c DF91      		pop r29
 970 033e CF91      		pop r28
 971 0340 0895      		ret
 973               	.Lscope18:
 975               	.global	yackfarns
 977               	yackfarns:
 701:yack.c        **** 	
 979               	.LM122:
 980               	.LFBB19:
 981 0342 CF93      		push r28
 982 0344 DF93      		push r29
 983               	/* prologue: function */
 984               	/* frame size = 0 */
 985               	/* stack size = 2 */
 986               	.L__stack_usage = 2
 703:yack.c        **** 	
 988               	.LM123:
 989 0346 C091 0000 		lds r28,farnsworth
 990 034a D0E0      		ldi r29,0
 991               	.L80:
 705:yack.c        **** 	{
 993               	.LM124:
 994 034c 2097      		sbiw r28,0
 995 034e 01F0      		breq .L82
 707:yack.c        **** 	}
 997               	.LM125:
 998 0350 81E0      		ldi r24,lo8(1)
 999 0352 00D0      		rcall yackdelay
 1000 0354 2197      		sbiw r28,1
 1001 0356 00C0      		rjmp .L80
 1002               	.L82:
 1003               	/* epilogue start */
 710:yack.c        **** 
 1005               	.LM126:
 1006 0358 DF91      		pop r29
 1007 035a CF91      		pop r28
 1008 035c 0895      		ret
 1010               	.Lscope19:
 1013               	.global	yackplay
 1015               	yackplay:
 747:yack.c        **** 	
 1017               	.LM127:
 1018               	.LFBB20:
 1019 035e CF93      		push r28
 1020               	/* prologue: function */
 1021               	/* frame size = 0 */
 1022               	/* stack size = 1 */
 1023               	.L__stack_usage = 1
 1024 0360 C82F      		mov r28,r24
 749:yack.c        **** 
 1026               	.LM128:
 1027 0362 00D0      		rcall key.constprop.4
 1028               	.LBB37:
 1029               	.LBB38:
 311:yack.c        ****     }
 1031               	.LM129:
 1032 0364 1092 0000 		sts shdntimer.2031,__zero_reg__
 1033 0368 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 1034 036c 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 1035 0370 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 1036               	.LBE38:
 1037               	.LBE37:
 757:yack.c        **** 	{
 1039               	.LM130:
 1040 0374 C130      		cpi r28,lo8(1)
 1041 0376 01F0      		breq .L85
 1042 0378 C230      		cpi r28,lo8(2)
 1043 037a 01F4      		brne .L84
 760:yack.c        **** 			break;
 1045               	.LM131:
 1046 037c 83E0      		ldi r24,lo8(3)
 1047 037e 00C0      		rjmp .L87
 1048               	.L85:
 764:yack.c        **** 			break;
 1050               	.LM132:
 1051 0380 81E0      		ldi r24,lo8(1)
 1052               	.L87:
 1053 0382 00D0      		rcall yackdelay
 1054               	.L84:
 1055               	/* epilogue start */
 770:yack.c        **** 
 1057               	.LM133:
 1058 0384 CF91      		pop r28
 1059               	.LBB39:
 1060               	.LBB40:
 1061 0386 00C0      		rjmp key.part.0
 1062               	.LBE40:
 1063               	.LBE39:
 1065               	.Lscope20:
 1069               	.global	yackspeed
 1071               	yackspeed:
 444:yack.c        ****     
 1073               	.LM134:
 1074               	.LFBB21:
 1075               	/* prologue: function */
 1076               	/* frame size = 0 */
 1077               	/* stack size = 0 */
 1078               	.L__stack_usage = 0
 446:yack.c        ****     {
 1080               	.LM135:
 1081 0388 6130      		cpi r22,lo8(1)
 1082 038a 01F4      		brne .L89
 448:yack.c        ****             farnsworth--;
 1084               	.LM136:
 1085 038c 8130      		cpi r24,lo8(1)
 1086 038e 01F4      		brne .L90
 448:yack.c        ****             farnsworth--;
 1088               	.LM137:
 1089 0390 8091 0000 		lds r24,farnsworth
 1090 0394 8823      		tst r24
 1091 0396 01F0      		breq .L92
 449:yack.c        ****         
 1093               	.LM138:
 1094 0398 8150      		subi r24,lo8(-(-1))
 1095 039a 00C0      		rjmp .L103
 1096               	.L90:
 451:yack.c        ****             farnsworth++;
 1098               	.LM139:
 1099 039c 8230      		cpi r24,lo8(2)
 1100 039e 01F4      		brne .L92
 451:yack.c        ****             farnsworth++;
 1102               	.LM140:
 1103 03a0 8091 0000 		lds r24,farnsworth
 1104 03a4 8F3F      		cpi r24,lo8(-1)
 1105 03a6 01F0      		breq .L92
 452:yack.c        ****     }
 1107               	.LM141:
 1108 03a8 8F5F      		subi r24,lo8(-(1))
 1109               	.L103:
 1110 03aa 8093 0000 		sts farnsworth,r24
 1111 03ae 00C0      		rjmp .L92
 1112               	.L89:
 1113 03b0 9091 0000 		lds r25,wpm
 456:yack.c        ****             wpm++;
 1115               	.LM142:
 1116 03b4 8130      		cpi r24,lo8(1)
 1117 03b6 01F4      		brne .L93
 456:yack.c        ****             wpm++;
 1119               	.LM143:
 1120 03b8 9233      		cpi r25,lo8(50)
 1121 03ba 00F4      		brsh .L95
 457:yack.c        ****         
 1123               	.LM144:
 1124 03bc 9F5F      		subi r25,lo8(-(1))
 1125 03be 00C0      		rjmp .L102
 1126               	.L93:
 459:yack.c        ****             wpm--;
 1128               	.LM145:
 1129 03c0 8230      		cpi r24,lo8(2)
 1130 03c2 01F4      		brne .L95
 459:yack.c        ****             wpm--;
 1132               	.LM146:
 1133 03c4 9630      		cpi r25,lo8(6)
 1134 03c6 00F0      		brlo .L95
 460:yack.c        ****         
 1136               	.LM147:
 1137 03c8 9150      		subi r25,lo8(-(-1))
 1138               	.L102:
 1139 03ca 9093 0000 		sts wpm,r25
 1140               	.L95:
 462:yack.c        **** 
 1142               	.LM148:
 1143 03ce 6091 0000 		lds r22,wpm
 1144 03d2 70E0      		ldi r23,0
 1145 03d4 80EF      		ldi r24,lo8(-16)
 1146 03d6 90E0      		ldi r25,0
 1147 03d8 00D0      		rcall __divmodhi4
 1148 03da 7093 0000 		sts wpmcnt+1,r23
 1149 03de 6093 0000 		sts wpmcnt,r22
 1150               	.L92:
 466:yack.c        ****     
 1152               	.LM149:
 1153 03e2 8091 0000 		lds r24,volflags
 1154 03e6 8460      		ori r24,lo8(4)
 1155 03e8 8093 0000 		sts volflags,r24
 468:yack.c        ****     yackdelay(IEGLEN);	// Inter Element gap  
 1157               	.LM150:
 1158 03ec 81E0      		ldi r24,lo8(1)
 1159 03ee 00D0      		rcall yackplay
 469:yack.c        ****     yackplay(DAH);
 1161               	.LM151:
 1162 03f0 81E0      		ldi r24,lo8(1)
 1163 03f2 00D0      		rcall yackdelay
 470:yack.c        ****     yackdelay(ICGLEN);	// Inter Character gap  
 1165               	.LM152:
 1166 03f4 82E0      		ldi r24,lo8(2)
 1167 03f6 00D0      		rcall yackplay
 471:yack.c        ****     yackfarns(); // Additional Farnsworth delay
 1169               	.LM153:
 1170 03f8 83E0      		ldi r24,lo8(3)
 1171 03fa 00D0      		rcall yackdelay
 472:yack.c        ****     
 1173               	.LM154:
 1174 03fc 00C0      		rjmp yackfarns
 1176               	.Lscope21:
 1178               	.global	yackerror
 1180               	yackerror:
 615:yack.c        **** 	byte i;
 1182               	.LM155:
 1183               	.LFBB22:
 1184 03fe CF93      		push r28
 1185               	/* prologue: function */
 1186               	/* frame size = 0 */
 1187               	/* stack size = 1 */
 1188               	.L__stack_usage = 1
 615:yack.c        **** 	byte i;
 1190               	.LM156:
 1191 0400 C8E0      		ldi r28,lo8(8)
 1192               	.L105:
 620:yack.c        **** 		yackdelay(DITLEN);
 1194               	.LM157:
 1195 0402 81E0      		ldi r24,lo8(1)
 1196 0404 00D0      		rcall yackplay
 621:yack.c        **** 	}
 1198               	.LM158:
 1199 0406 81E0      		ldi r24,lo8(1)
 1200 0408 00D0      		rcall yackdelay
 1201 040a C150      		subi r28,lo8(-(-1))
 618:yack.c        **** 	{
 1203               	.LM159:
 1204 040c 01F4      		brne .L105
 623:yack.c        **** 	
 1206               	.LM160:
 1207 040e 83E0      		ldi r24,lo8(3)
 1208               	/* epilogue start */
 625:yack.c        **** 
 1210               	.LM161:
 1211 0410 CF91      		pop r28
 623:yack.c        **** 	
 1213               	.LM162:
 1214 0412 00C0      		rjmp yackdelay
 1216               	.Lscope22:
 1219               	.global	yackctrlkey
 1221               	yackctrlkey:
 926:yack.c        **** 	
 927:yack.c        **** }
 928:yack.c        **** 
 929:yack.c        **** 
 930:yack.c        **** 
 931:yack.c        **** byte yackctrlkey(byte mode)
 932:yack.c        **** /*! 
 933:yack.c        ****  @brief     Scans for the Control key
 934:yack.c        ****  
 935:yack.c        ****  This function is regularly called at different points in the program. In a normal case
 936:yack.c        ****  it terminates instantly. When the command key is found to be closed, the routine idles
 937:yack.c        ****  until it is released again and returns a TRUE return value.
 938:yack.c        ****  
 939:yack.c        ****  If, during the period where the contact was closed one of the paddles was closed too,
 940:yack.c        ****  the wpm speed is changed and the keypress not interpreted as a Control request. 
 941:yack.c        **** 
 942:yack.c        ****  @param mode    TRUE if caller has taken care of command key press, FALSE if not
 943:yack.c        ****  @return        TRUE if a press of the command key is not yet handled. 
 944:yack.c        ****  
 945:yack.c        ****  @callergraph
 946:yack.c        ****  
 947:yack.c        ****  */
 948:yack.c        **** {
 1223               	.LM163:
 1224               	.LFBB23:
 1225 0414 CF93      		push r28
 1226 0416 DF93      		push r29
 1227               	/* prologue: function */
 1228               	/* frame size = 0 */
 1229               	/* stack size = 2 */
 1230               	.L__stack_usage = 2
 1231 0418 D82F      		mov r29,r24
 949:yack.c        **** 	
 950:yack.c        **** 	byte volbfr;
 951:yack.c        **** 	
 952:yack.c        ****     volbfr = volflags; // Remember current volatile settings
 1233               	.LM164:
 1234 041a C091 0000 		lds r28,volflags
 953:yack.c        ****     
 954:yack.c        **** 	if (!(BTNINP & (1<<BTNPIN))) // If command button is pressed
 1236               	.LM165:
 1237 041e B299      		sbic 0x16,2
 1238 0420 00C0      		rjmp .L108
 955:yack.c        **** 	{
 956:yack.c        ****         
 957:yack.c        ****         volbfr |= CKLATCH; // Set control key latch
 1240               	.LM166:
 1241 0422 C860      		ori r28,lo8(8)
 958:yack.c        **** 		
 959:yack.c        **** 		// Apparently the control key has been pressed. To avoid bouncing
 960:yack.c        **** 		// We will now wait a short while and then busy wait until the key is
 961:yack.c        **** 		// released.
 962:yack.c        **** 		// Should we find that someone is keying the paddle, let him change
 963:yack.c        **** 		// the speed and pretend ctrl was never pressed in the first place..
 964:yack.c        **** 
 965:yack.c        **** 		yackinhibit(ON); // Stop keying, switch on sidetone.
 1243               	.LM167:
 1244 0424 81E0      		ldi r24,lo8(1)
 1245 0426 00D0      		rcall yackinhibit
 1246               	.LBB41:
 1247               	.LBB42:
 1249               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1251               	.LM168:
 1252 0428 83ED      		ldi r24,lo8(12499)
 1253 042a 90E3      		ldi r25,hi8(12499)
 1254 042c 0197      	1:	sbiw r24,1
 1255 042e 01F4      		brne 1b
 1256 0430 00C0      		rjmp .
 1257 0432 0000      		nop
 1258               	.L111:
 1259               	.LBE42:
 1260               	.LBE41:
 1262               	.Ltext2:
 966:yack.c        **** 		
 967:yack.c        **** 		_delay_ms(50);
 968:yack.c        **** 		
 969:yack.c        **** 		while(!(BTNINP & (1<<BTNPIN))) // Busy wait for release
 1264               	.LM169:
 1265 0434 B299      		sbic 0x16,2
 1266 0436 00C0      		rjmp .L116
 970:yack.c        **** 		{
 971:yack.c        ****             
 972:yack.c        **** 			if (!( KEYINP & (1<<DITPIN))) // Someone pressing DIT paddle
 1268               	.LM170:
 1269 0438 B399      		sbic 0x16,3
 1270 043a 00C0      		rjmp .L110
 973:yack.c        **** 			{
 974:yack.c        **** 				yackspeed(DOWN,WPMSPEED);
 1272               	.LM171:
 1273 043c 60E0      		ldi r22,0
 1274 043e 82E0      		ldi r24,lo8(2)
 1275 0440 00D0      		rcall yackspeed
 975:yack.c        ****                 volbfr &= ~(CKLATCH); // Ignore that control key was pressed
 1277               	.LM172:
 1278 0442 C77F      		andi r28,lo8(-9)
 1279               	.L110:
 976:yack.c        **** 			}	
 977:yack.c        **** 			
 978:yack.c        **** 			if (!( KEYINP & (1<<DAHPIN))) // Someone pressing DAH paddle
 1281               	.LM173:
 1282 0444 B499      		sbic 0x16,4
 1283 0446 00C0      		rjmp .L111
 979:yack.c        **** 			{
 980:yack.c        **** 				yackspeed(UP,WPMSPEED);
 1285               	.LM174:
 1286 0448 60E0      		ldi r22,0
 1287 044a 81E0      		ldi r24,lo8(1)
 1288 044c 00D0      		rcall yackspeed
 981:yack.c        ****                 volbfr &= ~(CKLATCH);
 1290               	.LM175:
 1291 044e C77F      		andi r28,lo8(-9)
 1292 0450 00C0      		rjmp .L111
 1293               	.L116:
 1294               	.LBB43:
 1295               	.LBB44:
 1297               	.Ltext3:
 1299               	.LM176:
 1300 0452 83ED      		ldi r24,lo8(12499)
 1301 0454 90E3      		ldi r25,hi8(12499)
 1302 0456 0197      	1:	sbiw r24,1
 1303 0458 01F4      		brne 1b
 1304 045a 00C0      		rjmp .
 1305 045c 0000      		nop
 1306               	.LBE44:
 1307               	.LBE43:
 1309               	.Ltext4:
 982:yack.c        **** 			}	
 983:yack.c        **** 			
 984:yack.c        **** 		}
 985:yack.c        ****         
 986:yack.c        **** 		_delay_ms(50); // Trailing edge debounce
 987:yack.c        **** 		
 988:yack.c        ****         yacksave();	// In case we had a speed change	
 1311               	.LM177:
 1312 045e 00D0      		rcall yacksave
 1313               	.L108:
 989:yack.c        **** 		
 990:yack.c        **** 	}
 991:yack.c        **** 
 992:yack.c        ****     volflags = volbfr; // Restore previous state
 993:yack.c        **** 
 994:yack.c        ****     if (mode==TRUE) // Does caller want us to reset latch?
 1315               	.LM178:
 1316 0460 D130      		cpi r29,lo8(1)
 1317 0462 01F0      		breq .L113
 992:yack.c        **** 
 1319               	.LM179:
 1320 0464 C093 0000 		sts volflags,r28
 1321 0468 00C0      		rjmp .L114
 1322               	.L113:
 995:yack.c        ****     {
 996:yack.c        ****         volflags &= ~(CKLATCH);
 1324               	.LM180:
 1325 046a 8C2F      		mov r24,r28
 1326 046c 877F      		andi r24,lo8(-9)
 1327 046e 8093 0000 		sts volflags,r24
 1328               	.L114:
 997:yack.c        ****     }
 998:yack.c        ****     
 999:yack.c        ****     //yacksave(); // In case we had a speed change (Does NOT work if command is here - moved immedi
1000:yack.c        ****     
1001:yack.c        **** 	return((volbfr&CKLATCH)!=0); // Tell caller if we had a ctrl button press
1002:yack.c        **** 	
1003:yack.c        **** }
 1330               	.LM181:
 1331 0472 C3FB      		bst r28,3
 1332 0474 8827      		clr r24
 1333 0476 80F9      		bld r24,0
 1334               	/* epilogue start */
 1335 0478 DF91      		pop r29
 1336 047a CF91      		pop r28
 1337 047c 0895      		ret
 1342               	.Lscope23:
 1344               	.global	yacktune
 1346               	yacktune:
 534:yack.c        **** 	word timer = YACKSECS(TUNEDURATION);
 1348               	.LM182:
 1349               	.LFBB24:
 1350 047e CF93      		push r28
 1351 0480 DF93      		push r29
 1352               	/* prologue: function */
 1353               	/* frame size = 0 */
 1354               	/* stack size = 2 */
 1355               	.L__stack_usage = 2
 537:yack.c        **** 	
 1357               	.LM183:
 1358 0482 00D0      		rcall key.constprop.4
 1359 0484 C0EA      		ldi r28,lo8(-96)
 1360 0486 DFE0      		ldi r29,lo8(15)
 1361               	.L118:
 539:yack.c        **** 	{
 1363               	.LM184:
 1364 0488 B399      		sbic 0x16,3
 1365 048a 00C0      		rjmp .L128
 1366               	.L119:
 1367               	/* epilogue start */
 546:yack.c        **** 
 1369               	.LM185:
 1370 048c DF91      		pop r29
 1371 048e CF91      		pop r28
 1372               	.LBB45:
 1373               	.LBB46:
 1374 0490 00C0      		rjmp key.part.0
 1375               	.L128:
 1376               	.LBE46:
 1377               	.LBE45:
 539:yack.c        **** 	{
 1379               	.LM186:
 1380 0492 B49B      		sbis 0x16,4
 1381 0494 00C0      		rjmp .L119
 539:yack.c        **** 	{
 1383               	.LM187:
 1384 0496 81E0      		ldi r24,lo8(1)
 1385 0498 00D0      		rcall yackctrlkey
 1386 049a 8111      		cpse r24,__zero_reg__
 1387 049c 00C0      		rjmp .L119
 542:yack.c        **** 	}
 1389               	.LM188:
 1390 049e 00D0      		rcall yackbeat
 1391 04a0 2197      		sbiw r28,1
 539:yack.c        **** 	{
 1393               	.LM189:
 1394 04a2 01F4      		brne .L118
 1395 04a4 00C0      		rjmp .L119
 1397               	.Lscope24:
 1400               	.global	yackchar
 1402               	yackchar:
 792:yack.c        **** 	byte	code=0x80; // 0x80 is an empty morse character (just eoc bit set)
 1404               	.LM190:
 1405               	.LFBB25:
 1406 04a6 CF93      		push r28
 1407               	/* prologue: function */
 1408               	/* frame size = 0 */
 1409               	/* stack size = 1 */
 1410               	.L__stack_usage = 1
 798:yack.c        **** 		code = pgm_read_byte(&morse[c-'0']); // Find it in the beginning of array
 1412               	.LM191:
 1413 04a8 90ED      		ldi r25,lo8(-48)
 1414 04aa 980F      		add r25,r24
 1415 04ac 9A30      		cpi r25,lo8(10)
 1416 04ae 00F4      		brsh .L141
 1417               	.LBB47:
 799:yack.c        ****     
 1419               	.LM192:
 1420 04b0 E82F      		mov r30,r24
 1421 04b2 F0E0      		ldi r31,0
 1422 04b4 E050      		subi r30,lo8(-(morse-48))
 1423 04b6 F040      		sbci r31,hi8(-(morse-48))
 1424               	/* #APP */
 1425               	 ;  799 "yack.c" 1
 1426 04b8 C491      		lpm r28, Z
 1427               		
 1428               	 ;  0 "" 2
 1429               	/* #NOAPP */
 1430 04ba 00C0      		rjmp .L130
 1431               	.L141:
 1432               	.LBE47:
 793:yack.c        **** 	byte 	i; // a counter
 1434               	.LM193:
 1435 04bc C0E8      		ldi r28,lo8(-128)
 1436               	.L130:
 801:yack.c        **** 		code = pgm_read_byte(&morse[c-'a'+10]); // Find it from position 10
 1438               	.LM194:
 1439 04be 9FE9      		ldi r25,lo8(-97)
 1440 04c0 980F      		add r25,r24
 1441 04c2 9A31      		cpi r25,lo8(26)
 1442 04c4 00F4      		brsh .L131
 1443               	.LBB48:
 802:yack.c        **** 	
 1445               	.LM195:
 1446 04c6 E82F      		mov r30,r24
 1447 04c8 F0E0      		ldi r31,0
 1448 04ca E050      		subi r30,lo8(-(morse-87))
 1449 04cc F040      		sbci r31,hi8(-(morse-87))
 1450               	/* #APP */
 1451               	 ;  802 "yack.c" 1
 1452 04ce C491      		lpm r28, Z
 1453               		
 1454               	 ;  0 "" 2
 1455               	/* #NOAPP */
 1456               	.L131:
 1457               	.LBE48:
 804:yack.c        **** 		code = pgm_read_byte(&morse[c-'A'+10]); // Same as above
 1459               	.LM196:
 1460 04d0 9FEB      		ldi r25,lo8(-65)
 1461 04d2 980F      		add r25,r24
 1462 04d4 9A31      		cpi r25,lo8(26)
 1463 04d6 00F4      		brsh .L132
 1464               	.LBB49:
 805:yack.c        **** 	
 1466               	.LM197:
 1467 04d8 E82F      		mov r30,r24
 1468 04da F0E0      		ldi r31,0
 1469 04dc E050      		subi r30,lo8(-(morse-55))
 1470 04de F040      		sbci r31,hi8(-(morse-55))
 1471               	/* #APP */
 1472               	 ;  805 "yack.c" 1
 1473 04e0 C491      		lpm r28, Z
 1474               		
 1475               	 ;  0 "" 2
 1476               	/* #NOAPP */
 1477               	.L132:
 1478               	.LBE49:
 793:yack.c        **** 	byte 	i; // a counter
 1480               	.LM198:
 1481 04e2 20E0      		ldi r18,0
 1482 04e4 30E0      		ldi r19,0
 1483               	.L134:
 1484               	.LBB50:
 811:yack.c        **** 			code = pgm_read_byte(&morse[i+36]); // Map it to morse code
 1486               	.LM199:
 1487 04e6 F901      		movw r30,r18
 1488 04e8 E050      		subi r30,lo8(-(spechar))
 1489 04ea F040      		sbci r31,hi8(-(spechar))
 1490               	/* #APP */
 1491               	 ;  811 "yack.c" 1
 1492 04ec E491      		lpm r30, Z
 1493               		
 1494               	 ;  0 "" 2
 1495               	/* #NOAPP */
 1496               	.LBE50:
 1497 04ee 8E13      		cpse r24,r30
 1498 04f0 00C0      		rjmp .L133
 1499               	.LBB51:
 812:yack.c        **** 	
 1501               	.LM200:
 1502 04f2 F901      		movw r30,r18
 1503 04f4 E050      		subi r30,lo8(-(morse+36))
 1504 04f6 F040      		sbci r31,hi8(-(morse+36))
 1505               	/* #APP */
 1506               	 ;  812 "yack.c" 1
 1507 04f8 C491      		lpm r28, Z
 1508               		
 1509               	 ;  0 "" 2
 1510               	/* #NOAPP */
 1511               	.L133:
 1512 04fa 2F5F      		subi r18,-1
 1513 04fc 3F4F      		sbci r19,-1
 1514               	.LBE51:
 810:yack.c        **** 		if (c == pgm_read_byte(&spechar[i])) // Does it contain our character
 1516               	.LM201:
 1517 04fe 2831      		cpi r18,24
 1518 0500 3105      		cpc r19,__zero_reg__
 1519 0502 01F4      		brne .L134
 814:yack.c        **** 		yackdelay(IWGLEN-ICGLEN); // ICG was already played after previous char
 1521               	.LM202:
 1522 0504 8032      		cpi r24,lo8(32)
 1523 0506 01F4      		brne .L136
 815:yack.c        **** 	else
 1525               	.LM203:
 1526 0508 84E0      		ldi r24,lo8(4)
 1527               	/* epilogue start */
 839:yack.c        **** 
 1529               	.LM204:
 1530 050a CF91      		pop r28
 815:yack.c        **** 	else
 1532               	.LM205:
 1533 050c 00C0      		rjmp yackdelay
 1534               	.L140:
 820:yack.c        **** 				return;
 1536               	.LM206:
 1537 050e 80E0      		ldi r24,0
 1538 0510 00D0      		rcall yackctrlkey
 1539 0512 8111      		cpse r24,__zero_reg__
 1540 0514 00C0      		rjmp .L129
 823:yack.c        ****        			yackplay(DAH);      // ..then play a dash
 1542               	.LM207:
 1543 0516 C7FF      		sbrs r28,7
 1544 0518 00C0      		rjmp .L138
 824:yack.c        ****      		else				// MSB cleared ?
 1546               	.LM208:
 1547 051a 82E0      		ldi r24,lo8(2)
 1548               	.L143:
 826:yack.c        **** 			
 1550               	.LM209:
 1551 051c 00D0      		rcall yackplay
 828:yack.c        ****             
 1553               	.LM210:
 1554 051e 81E0      		ldi r24,lo8(1)
 1555 0520 00D0      		rcall yackdelay
 830:yack.c        ****   		}
 1557               	.LM211:
 1558 0522 CC0F      		lsl r28
 1559               	.L136:
 818:yack.c        ****   		{
 1561               	.LM212:
 1562 0524 C038      		cpi r28,lo8(-128)
 1563 0526 01F4      		brne .L140
 1564 0528 00C0      		rjmp .L144
 1565               	.L138:
 826:yack.c        **** 			
 1567               	.LM213:
 1568 052a 81E0      		ldi r24,lo8(1)
 1569 052c 00C0      		rjmp .L143
 1570               	.L144:
 833:yack.c        **** 
 1572               	.LM214:
 1573 052e 82E0      		ldi r24,lo8(2)
 1574 0530 00D0      		rcall yackdelay
 1575               	/* epilogue start */
 839:yack.c        **** 
 1577               	.LM215:
 1578 0532 CF91      		pop r28
 835:yack.c        **** 
 1580               	.LM216:
 1581 0534 00C0      		rjmp yackfarns
 1582               	.L129:
 1583               	/* epilogue start */
 839:yack.c        **** 
 1585               	.LM217:
 1586 0536 CF91      		pop r28
 1587 0538 0895      		ret
 1592               	.Lscope25:
 1595               	.global	yackstring
 1597               	yackstring:
 853:yack.c        **** 	
 1599               	.LM218:
 1600               	.LFBB26:
 1601 053a 1F93      		push r17
 1602 053c CF93      		push r28
 1603 053e DF93      		push r29
 1604               	/* prologue: function */
 1605               	/* frame size = 0 */
 1606               	/* stack size = 3 */
 1607               	.L__stack_usage = 3
 1608 0540 EC01      		movw r28,r24
 1609               	.L146:
 1610               	.LBB52:
 857:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 1612               	.LM219:
 1613 0542 FE01      		movw r30,r28
 1614               	/* #APP */
 1615               	 ;  857 "yack.c" 1
 1616 0544 1491      		lpm r17, Z
 1617               		
 1618               	 ;  0 "" 2
 1619               	/* #NOAPP */
 1620               	.LBE52:
 1621 0546 1123      		tst r17
 1622 0548 01F0      		breq .L145
 857:yack.c        **** 		// While end of string in flash not reached and ctrl not pressed
 1624               	.LM220:
 1625 054a 81E0      		ldi r24,lo8(1)
 1626 054c 00D0      		rcall yackctrlkey
 1627 054e 2196      		adiw r28,1
 1628 0550 8111      		cpse r24,__zero_reg__
 1629 0552 00C0      		rjmp .L145
 859:yack.c        **** 								// abort now if someone presses command key
 1631               	.LM221:
 1632 0554 812F      		mov r24,r17
 1633 0556 00D0      		rcall yackchar
 1634 0558 00C0      		rjmp .L146
 1635               	.L145:
 1636               	/* epilogue start */
 862:yack.c        **** 
 1638               	.LM222:
 1639 055a DF91      		pop r29
 1640 055c CF91      		pop r28
 1641 055e 1F91      		pop r17
 1642 0560 0895      		ret
 1647               	.Lscope26:
 1650               	.global	yacknumber
 1652               	yacknumber:
 876:yack.c        ****     
 1654               	.LM223:
 1655               	.LFBB27:
 1656 0562 1F93      		push r17
 1657 0564 CF93      		push r28
 1658 0566 DF93      		push r29
 1659 0568 00D0      		rcall .
 1660 056a 00D0      		rcall .
 1661 056c 1F92      		push __zero_reg__
 1662 056e CDB7      		in r28,__SP_L__
 1663 0570 DEB7      		in r29,__SP_H__
 1664               	/* prologue: function */
 1665               	/* frame size = 5 */
 1666               	/* stack size = 8 */
 1667               	.L__stack_usage = 8
 879:yack.c        **** 	
 1669               	.LM224:
 1670 0572 10E0      		ldi r17,0
 883:yack.c        **** 		n /= 10;                // Divide by 10
 1672               	.LM225:
 1673 0574 2AE0      		ldi r18,lo8(10)
 1674 0576 30E0      		ldi r19,0
 1675               	.L151:
 881:yack.c        **** 	{
 1677               	.LM226:
 1678 0578 0097      		sbiw r24,0
 1679 057a 01F0      		breq .L153
 883:yack.c        **** 		n /= 10;                // Divide by 10
 1681               	.LM227:
 1682 057c E1E0      		ldi r30,lo8(1)
 1683 057e F0E0      		ldi r31,0
 1684 0580 EC0F      		add r30,r28
 1685 0582 FD1F      		adc r31,r29
 1686 0584 E10F      		add r30,r17
 1687 0586 F11D      		adc r31,__zero_reg__
 1688 0588 B901      		movw r22,r18
 1689 058a 00D0      		rcall __udivmodhi4
 1690 058c 805D      		subi r24,lo8(-(48))
 1691 058e 8083      		st Z,r24
 884:yack.c        **** 	}
 1693               	.LM228:
 1694 0590 CB01      		movw r24,r22
 883:yack.c        **** 		n /= 10;                // Divide by 10
 1696               	.LM229:
 1697 0592 1F5F      		subi r17,lo8(-(1))
 1698 0594 00C0      		rjmp .L151
 1699               	.L155:
 889:yack.c        ****         yackchar(buffer[--i]);
 1701               	.LM230:
 1702 0596 81E0      		ldi r24,lo8(1)
 1703 0598 00D0      		rcall yackctrlkey
 1704 059a 8111      		cpse r24,__zero_reg__
 1705 059c 00C0      		rjmp .L156
 890:yack.c        ****     }
 1707               	.LM231:
 1708 059e 1150      		subi r17,lo8(-(-1))
 1709 05a0 E1E0      		ldi r30,lo8(1)
 1710 05a2 F0E0      		ldi r31,0
 1711 05a4 EC0F      		add r30,r28
 1712 05a6 FD1F      		adc r31,r29
 1713 05a8 E10F      		add r30,r17
 1714 05aa F11D      		adc r31,__zero_reg__
 1715 05ac 8081      		ld r24,Z
 1716 05ae 00D0      		rcall yackchar
 1717               	.L153:
 887:yack.c        ****     {
 1719               	.LM232:
 1720 05b0 1111      		cpse r17,__zero_reg__
 1721 05b2 00C0      		rjmp .L155
 1722               	.L156:
 893:yack.c        ****     
 1724               	.LM233:
 1725 05b4 80E2      		ldi r24,lo8(32)
 1726               	/* epilogue start */
 895:yack.c        **** 
 1728               	.LM234:
 1729 05b6 0F90      		pop __tmp_reg__
 1730 05b8 0F90      		pop __tmp_reg__
 1731 05ba 0F90      		pop __tmp_reg__
 1732 05bc 0F90      		pop __tmp_reg__
 1733 05be 0F90      		pop __tmp_reg__
 1734 05c0 DF91      		pop r29
 1735 05c2 CF91      		pop r28
 1736 05c4 1F91      		pop r17
 893:yack.c        ****     
 1738               	.LM235:
 1739 05c6 00C0      		rjmp yackchar
 1744               	.Lscope27:
 1747               	.global	yackiambic
 1749               	yackiambic:
1004:yack.c        **** 
1005:yack.c        **** 
1006:yack.c        **** 
1007:yack.c        **** static char morsechar(byte buffer)
1008:yack.c        **** /*! 
1009:yack.c        ****  @brief     Reverse maps a combination of dots and dashes to a character
1010:yack.c        ****  
1011:yack.c        ****  This routine is passed a sequence of dots and dashes in the format we use for morse
1012:yack.c        ****  character encoding (see top of this file). It looks up the corresponding character in
1013:yack.c        ****  the Flash table and returns it to the caller. 
1014:yack.c        ****  
1015:yack.c        ****  This is a private function.
1016:yack.c        ****  
1017:yack.c        ****  @param buffer    A character in YACK CW notation
1018:yack.c        ****  @return          The mapped character or /0 if no match was found  
1019:yack.c        ****  
1020:yack.c        ****  */
1021:yack.c        **** {
1022:yack.c        **** 	byte i;
1023:yack.c        **** 	
1024:yack.c        **** 	for(i=0;i<sizeof(morse);i++)
1025:yack.c        **** 	{
1026:yack.c        **** 		
1027:yack.c        **** 		if (pgm_read_byte(&morse[i]) == buffer)
1028:yack.c        **** 		{
1029:yack.c        **** 			if (i < 10) return ('0' + i); 		// First 10 chars are digits
1030:yack.c        **** 			if (i < 36) return ('A' + i - 10); 	// Then follow letters
1031:yack.c        **** 			return (pgm_read_byte(&spechar[i - 36])); // Then special chars
1032:yack.c        **** 		}
1033:yack.c        **** 		
1034:yack.c        **** 	}
1035:yack.c        **** 	
1036:yack.c        **** 	return '\0';
1037:yack.c        **** }
1038:yack.c        **** 
1039:yack.c        **** 
1040:yack.c        **** 
1041:yack.c        **** void yackmessage(byte function, byte msgnr)
1042:yack.c        **** /*! 
1043:yack.c        ****  @brief     Handles EEPROM stored CW messages (macros)
1044:yack.c        ****  
1045:yack.c        ****  When called in RECORD mode, the function records a message up to 100 characters and stores it in 
1046:yack.c        ****  EEPROM. The routine stops recording when timing out after DEFTIMEOUT seconds. Recording
1047:yack.c        ****  can be aborted using the control key. If more than 100 characters are recorded, the error prosign
1048:yack.c        ****  is sounded and recording starts from the beginning. After recording and timing out the message is 
1049:yack.c        ****  back once before it is stored. To erase a message, do not key one.
1050:yack.c        ****  
1051:yack.c        ****  When called in PLAY mode, the message is just played back. Playback can be aborted using the comma
1052:yack.c        ****  key.
1053:yack.c        ****  
1054:yack.c        ****  @param     function    RECORD or PLAY
1055:yack.c        ****  @param     msgnr       1 or 2 or 3 or 4
1056:yack.c        ****  @return    TRUE if all OK, FALSE if lock prevented message recording
1057:yack.c        ****  
1058:yack.c        ****  */
1059:yack.c        **** {
1060:yack.c        **** 	unsigned char	rambuffer[RBSIZE];  // Storage for the message
1061:yack.c        **** 	unsigned char	c;					// Work character
1062:yack.c        **** 	
1063:yack.c        **** 	word			extimer = 0;		// Detects end of message (10 sec)
1064:yack.c        **** 	
1065:yack.c        **** 	byte 			i = 0;       		// Pointer into RAM buffer
1066:yack.c        **** 	byte 			n;					// Generic counter
1067:yack.c        **** 	
1068:yack.c        **** 	if (function == RECORD)
1069:yack.c        **** 	{
1070:yack.c        **** 
1071:yack.c        **** 		extimer = YACKSECS(DEFTIMEOUT);	// 5 Second until message end
1072:yack.c        **** 	   	while(extimer--)	// Continue until we waited 10 seconds
1073:yack.c        ****    		{
1074:yack.c        **** 			if (yackctrlkey(TRUE)) return;
1075:yack.c        **** 			
1076:yack.c        **** 			if ((c = yackiambic(ON))) // Check for a character from the key
1077:yack.c        **** 			{
1078:yack.c        **** 				rambuffer[i++] = c; // Add that character to our buffer
1079:yack.c        **** 				extimer = YACKSECS(DEFTIMEOUT); // Reset End of message timer
1080:yack.c        **** 			}
1081:yack.c        **** 			
1082:yack.c        **** 			if (i>=RBSIZE) // End of buffer reached?
1083:yack.c        **** 			{
1084:yack.c        **** 				yackerror();
1085:yack.c        **** 				i = 0;
1086:yack.c        **** 			}
1087:yack.c        **** 			
1088:yack.c        **** 			yackbeat(); // 10 ms heartbeat
1089:yack.c        **** 		}	
1090:yack.c        **** 		
1091:yack.c        **** 		// Extimer has expired. Message has ended
1092:yack.c        **** 		
1093:yack.c        **** 		if(i) // Was anything received at all?
1094:yack.c        **** 		{
1095:yack.c        **** 			rambuffer[--i] = 0; // Add a \0 end marker over last space
1096:yack.c        **** 			
1097:yack.c        **** 			// Replay the message
1098:yack.c        **** 			//for (n=0;n<i;n++){
1099:yack.c        **** 			//	if (yackctrlkey(TRUE)) {return;} //Break to command mode without saving if command key presse
1100:yack.c        **** 			//	yackchar(rambuffer[n]);
1101:yack.c        **** 	        //    }
1102:yack.c        **** 			
1103:yack.c        **** 			// Store it in EEPROM
1104:yack.c        **** 			if (msgnr == 1)
1105:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer1,RBSIZE);
1106:yack.c        **** 			if (msgnr == 2)
1107:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer2,RBSIZE);
1108:yack.c        **** 			if (msgnr == 3)
1109:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer3,RBSIZE);
1110:yack.c        **** 			if (msgnr == 4)
1111:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer4,RBSIZE);
1112:yack.c        **** 		}
1113:yack.c        **** 		else
1114:yack.c        **** 			yackerror();
1115:yack.c        **** 	}
1116:yack.c        **** 	
1117:yack.c        **** 	
1118:yack.c        **** 	if (function == PLAY)
1119:yack.c        **** 	{
1120:yack.c        **** 		// Retrieve the message from EEPROM
1121:yack.c        **** 		if (msgnr == 1)
1122:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer1,RBSIZE);
1123:yack.c        **** 		if (msgnr == 2)
1124:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer2,RBSIZE);
1125:yack.c        **** 		if (msgnr == 3)
1126:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer3,RBSIZE);
1127:yack.c        **** 		if (msgnr == 4)
1128:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer4,RBSIZE);
1129:yack.c        **** 		
1130:yack.c        **** 		// Replay the message
1131:yack.c        **** 		for (n=0;(c=rambuffer[n]);n++){ // Read until end of message
1132:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
1133:yack.c        **** 			yackchar(c); // play it back 
1134:yack.c        **** 		}
1135:yack.c        **** 	}
1136:yack.c        **** }
1137:yack.c        **** 
1138:yack.c        **** char yackiambic(byte ctrl)
1139:yack.c        **** /*! 
1140:yack.c        ****  @brief     Finite state machine for the IAMBIC keyer
1141:yack.c        ****  
1142:yack.c        ****  If IAMBIC (squeeze) keying is requested, this routine, which usually terminates
1143:yack.c        ****  immediately needs to be called in regular intervals of YACKBEAT milliseconds.
1144:yack.c        ****  
1145:yack.c        ****  This can happen though an outside busy waiting loop or a counter mechanism.
1146:yack.c        ****  
1147:yack.c        ****  @param ctrl    ON if the keyer should recognize when a word ends. OFF if not.
1148:yack.c        ****  @return        The character if one was recognized, /0 if not
1149:yack.c        ****  
1150:yack.c        ****  */
1151:yack.c        **** {
 1751               	.LM236:
 1752               	.LFBB28:
 1753 05c8 CF93      		push r28
 1754               	/* prologue: function */
 1755               	/* frame size = 0 */
 1756               	/* stack size = 1 */
 1757               	.L__stack_usage = 1
1152:yack.c        **** 	
1153:yack.c        **** 	static enum FSMSTATE	fsms = IDLE;	// FSM state indicator
1154:yack.c        **** 	static 		word		timer;			// A countdown timer
1155:yack.c        **** 	static		byte		lastsymbol;		// The last symbol sent
1156:yack.c        **** 	static		byte		buffer = 0;		// A place to store a sent char
1157:yack.c        **** 	static		byte		bcntr = 0;		// Number of elements sent
1158:yack.c        **** 	static		byte		iwgflag = 0;	// Flag: Are we in interword gap?
1159:yack.c        ****     static      byte        ultimem = 0;    // Buffer for last keying status
1160:yack.c        **** 				char		retchar;		// The character to return to caller
1161:yack.c        **** 	
1162:yack.c        **** 	// This routine is called every YACKBEAT ms. It starts with idle mode where
1163:yack.c        **** 	// the morse key is polled. Once a contact close is sensed, the TX key is 
1164:yack.c        **** 	// closed, the sidetone oscillator is fired up and the FSM progresses
1165:yack.c        **** 	// to the next state (KEYED). There it waits for the timer to expire, 
1166:yack.c        **** 	// afterwards progressing to IEG (Inter Element Gap).
1167:yack.c        **** 	// Once the IEG has completed, processing returns to the IDLE state.
1168:yack.c        **** 	
1169:yack.c        **** 	// If the FSM remains in idle state long enough (one dash time), the
1170:yack.c        **** 	// character is assumed to be complete and a decoding is attempted. If
1171:yack.c        **** 	// succesful, the ascii code of the character is returned to the caller
1172:yack.c        **** 	
1173:yack.c        **** 	// If the FSM remains in idle state for another 4 dot times (7 dot times 
1174:yack.c        **** 	// altogether), we assume that the word has ended. A space char
1175:yack.c        **** 	// is transmitted in this case.
1176:yack.c        **** 	
1177:yack.c        **** 	if (timer) timer--; // Count down
 1759               	.LM237:
 1760 05ca 2091 0000 		lds r18,timer.2200
 1761 05ce 3091 0000 		lds r19,timer.2200+1
 1762 05d2 2115      		cp r18,__zero_reg__
 1763 05d4 3105      		cpc r19,__zero_reg__
 1764 05d6 01F0      		breq .L158
 1766               	.LM238:
 1767 05d8 2150      		subi r18,1
 1768 05da 3109      		sbc r19,__zero_reg__
 1769 05dc 3093 0000 		sts timer.2200+1,r19
 1770 05e0 2093 0000 		sts timer.2200,r18
 1771               	.L158:
1178:yack.c        **** 	
1179:yack.c        **** 	if (ctrl == OFF) iwgflag = 0; // No space detection
 1773               	.LM239:
 1774 05e4 8111      		cpse r24,__zero_reg__
 1775 05e6 00C0      		rjmp .L159
 1777               	.LM240:
 1778 05e8 1092 0000 		sts iwgflag.2204,__zero_reg__
 1779               	.L159:
1180:yack.c        **** 	
1181:yack.c        **** 	switch (fsms)
 1781               	.LM241:
 1782 05ec 8091 0000 		lds r24,fsms.2199
 1783 05f0 8130      		cpi r24,lo8(1)
 1784 05f2 01F4      		brne .+2
 1785 05f4 00C0      		rjmp .L161
 1786 05f6 00F0      		brlo .L162
 1787 05f8 8230      		cpi r24,lo8(2)
 1788 05fa 01F4      		brne .+2
 1789 05fc 00C0      		rjmp .L163
 1790 05fe 00C0      		rjmp .L197
 1791               	.L162:
1182:yack.c        **** 	{
1183:yack.c        **** 			
1184:yack.c        **** 		case IDLE:
1185:yack.c        **** 			
1186:yack.c        **** 			keylatch();
 1793               	.LM242:
 1794 0600 00D0      		rcall keylatch
1187:yack.c        ****            
1188:yack.c        **** #ifdef POWERSAVE            
1189:yack.c        ****             
1190:yack.c        ****             yackpower(TRUE); // OK to go to sleep when here.
 1796               	.LM243:
 1797 0602 81E0      		ldi r24,lo8(1)
 1798 0604 00D0      		rcall yackpower
1191:yack.c        **** 
1192:yack.c        **** #endif            
1193:yack.c        ****             
1194:yack.c        ****             // Handle latching logic for various keyer modes
1195:yack.c        ****             switch (yackflags & MODE)
 1800               	.LM244:
 1801 0606 8091 0000 		lds r24,yackflags
 1802 060a 8C70      		andi r24,lo8(12)
 1803 060c 8430      		cpi r24,lo8(4)
 1804 060e 01F0      		breq .L165
 1805 0610 00F4      		brsh .L166
 1806 0612 8823      		tst r24
 1807 0614 01F0      		breq .L165
 1808 0616 00C0      		rjmp .L164
 1809               	.L166:
 1810 0618 8830      		cpi r24,lo8(8)
 1811 061a 01F0      		breq .L167
 1812 061c 8C30      		cpi r24,lo8(12)
 1813 061e 01F0      		breq .L168
 1814 0620 00C0      		rjmp .L164
 1815               	.L165:
1196:yack.c        ****             {
1197:yack.c        ****                 case IAMBICA:
1198:yack.c        ****                 case IAMBICB:
1199:yack.c        ****                     // When the paddle keys are squeezed, we need to ensure that
1200:yack.c        ****                     // dots and dashes are alternating. To do that, whe delete
1201:yack.c        ****                     // any latched paddle of the same kind that we just sent.
1202:yack.c        ****                     // However, we only do this ONCE
1203:yack.c        ****                     
1204:yack.c        ****                     volflags &= ~lastsymbol;
 1817               	.LM245:
 1818 0622 8091 0000 		lds r24,lastsymbol.2201
 1819 0626 8095      		com r24
 1820 0628 9091 0000 		lds r25,volflags
 1821 062c 8923      		and r24,r25
 1822 062e 8093 0000 		sts volflags,r24
1205:yack.c        ****                     lastsymbol = 0;
 1824               	.LM246:
 1825 0632 1092 0000 		sts lastsymbol.2201,__zero_reg__
1206:yack.c        ****                     break;                    
 1827               	.LM247:
 1828 0636 00C0      		rjmp .L164
 1829               	.L167:
1207:yack.c        ****                  
1208:yack.c        ****                 case ULTIMATIC:
1209:yack.c        ****                     // Ultimatic logic: The last paddle to be active will be repeated indefinitely
1210:yack.c        ****                     // In case the keyer is squeezed right out of idle mode, we just send a DAH 
1211:yack.c        ****                     if ((volflags & SQUEEZED) == SQUEEZED) // Squeezed?
 1831               	.LM248:
 1832 0638 8091 0000 		lds r24,volflags
 1833 063c 982F      		mov r25,r24
 1834 063e 9370      		andi r25,lo8(3)
 1835 0640 9330      		cpi r25,lo8(3)
 1836 0642 01F4      		brne .L169
1212:yack.c        ****                     {
1213:yack.c        ****                         if (ultimem)
 1838               	.LM249:
 1839 0644 9091 0000 		lds r25,ultimem.2205
 1840 0648 9923      		tst r25
 1841 064a 01F0      		breq .L198
1214:yack.c        ****                           volflags &= ~ultimem; // Opposite symbol from last one
 1843               	.LM250:
 1844 064c 9095      		com r25
 1845 064e 8923      		and r24,r25
 1846 0650 00C0      		rjmp .L199
 1847               	.L169:
1215:yack.c        ****                         else
1216:yack.c        ****                           volflags &= ~DITLATCH; // Reset the DIT latch
1217:yack.c        ****                     }
1218:yack.c        ****                     else
1219:yack.c        ****                     {
1220:yack.c        ****                         ultimem = volflags & SQUEEZED; // Remember the last single key
 1849               	.LM251:
 1850 0652 9093 0000 		sts ultimem.2205,r25
 1851 0656 00C0      		rjmp .L164
 1852               	.L168:
1221:yack.c        ****                     }
1222:yack.c        **** 
1223:yack.c        ****                     break;
1224:yack.c        ****                             
1225:yack.c        ****                 case DAHPRIO:            
1226:yack.c        ****                     // If both paddles pressed, DAH is given priority
1227:yack.c        ****                     if ((volflags & SQUEEZED) == SQUEEZED)
 1854               	.LM252:
 1855 0658 8091 0000 		lds r24,volflags
 1856 065c 982F      		mov r25,r24
 1857 065e 9370      		andi r25,lo8(3)
 1858 0660 9330      		cpi r25,lo8(3)
 1859 0662 01F4      		brne .L164
 1860               	.L198:
1228:yack.c        ****                     {
1229:yack.c        ****                         volflags &= ~DITLATCH; // Reset the DIT latch
 1862               	.LM253:
 1863 0664 8E7F      		andi r24,lo8(-2)
 1864               	.L199:
 1865 0666 8093 0000 		sts volflags,r24
 1866               	.L164:
1230:yack.c        ****                     }
1231:yack.c        ****                     break;
1232:yack.c        ****             }        
1233:yack.c        ****             
1234:yack.c        ****             
1235:yack.c        **** 			// The following handles the inter-character gap. When there are
1236:yack.c        **** 			// three (default) dot lengths of space after an element, the
1237:yack.c        **** 			// character is complete and can be returned to caller
1238:yack.c        **** 			if (timer == 0 && bcntr != 0) // Have we idled for 3 dots
 1868               	.LM254:
 1869 066a 8091 0000 		lds r24,timer.2200
 1870 066e 9091 0000 		lds r25,timer.2200+1
 1871 0672 892B      		or r24,r25
 1872 0674 01F0      		breq .+2
 1873 0676 00C0      		rjmp .L171
 1875               	.LM255:
 1876 0678 8091 0000 		lds r24,bcntr.2203
 1877 067c 8823      		tst r24
 1878 067e 01F4      		brne .+2
 1879 0680 00C0      		rjmp .L172
1239:yack.c        **** 				// and is there something to decode?
1240:yack.c        **** 			{
1241:yack.c        **** 				buffer = buffer << 1;	  // Make space for the termination bit
1242:yack.c        **** 				buffer |= 1;			  // The 1 on the right signals end
1243:yack.c        **** 				buffer = buffer << (7-bcntr); // Shift to left justify
 1881               	.LM256:
 1882 0682 9091 0000 		lds r25,buffer.2202
 1883 0686 990F      		lsl r25
 1884 0688 9160      		ori r25,lo8(1)
 1885 068a 27E0      		ldi r18,lo8(7)
 1886 068c 30E0      		ldi r19,0
 1887 068e 281B      		sub r18,r24
 1888 0690 3109      		sbc r19,__zero_reg__
 1889 0692 00C0      		rjmp 2f
 1890               		1:
 1891 0694 990F      		lsl r25
 1892               		2:
 1893 0696 2A95      		dec r18
 1894 0698 02F4      		brpl 1b
 1895 069a 20E0      		ldi r18,0
 1896 069c 30E0      		ldi r19,0
 1897               	.L177:
 1898 069e 822F      		mov r24,r18
 1899               	.LBB61:
 1900               	.LBB62:
 1901               	.LBB63:
1027:yack.c        **** 		{
 1903               	.LM257:
 1904 06a0 F901      		movw r30,r18
 1905 06a2 E050      		subi r30,lo8(-(morse))
 1906 06a4 F040      		sbci r31,hi8(-(morse))
 1907               	/* #APP */
 1908               	 ;  1027 "yack.c" 1
 1909 06a6 E491      		lpm r30, Z
 1910               		
 1911               	 ;  0 "" 2
 1912               	/* #NOAPP */
 1913               	.LBE63:
 1914 06a8 9E13      		cpse r25,r30
 1915 06aa 00C0      		rjmp .L173
1029:yack.c        **** 			if (i < 36) return ('A' + i - 10); 	// Then follow letters
 1917               	.LM258:
 1918 06ac 2A30      		cpi r18,lo8(10)
 1919 06ae 00F4      		brsh .L174
 1920 06b0 805D      		subi r24,lo8(-(48))
 1921 06b2 00C0      		rjmp .L175
 1922               	.L174:
1030:yack.c        **** 			return (pgm_read_byte(&spechar[i - 36])); // Then special chars
 1924               	.LM259:
 1925 06b4 2432      		cpi r18,lo8(36)
 1926 06b6 00F4      		brsh .L176
 1927 06b8 895C      		subi r24,lo8(-(55))
 1928 06ba 00C0      		rjmp .L175
 1929               	.L176:
 1930               	.LBB64:
1031:yack.c        **** 		}
 1932               	.LM260:
 1933 06bc F901      		movw r30,r18
 1934 06be E050      		subi r30,lo8(-(spechar-36))
 1935 06c0 F040      		sbci r31,hi8(-(spechar-36))
 1936               	/* #APP */
 1937               	 ;  1031 "yack.c" 1
 1938 06c2 8491      		lpm r24, Z
 1939               		
 1940               	 ;  0 "" 2
 1941               	/* #NOAPP */
 1942 06c4 00C0      		rjmp .L175
 1943               	.L173:
 1944 06c6 2F5F      		subi r18,-1
 1945 06c8 3F4F      		sbci r19,-1
 1946               	.LBE64:
1024:yack.c        **** 	{
 1948               	.LM261:
 1949 06ca 2C33      		cpi r18,60
 1950 06cc 3105      		cpc r19,__zero_reg__
 1951 06ce 01F4      		brne .L177
1036:yack.c        **** }
 1953               	.LM262:
 1954 06d0 80E0      		ldi r24,0
 1955               	.L175:
 1956               	.LBE62:
 1957               	.LBE61:
1244:yack.c        **** 				retchar = morsechar(buffer); // Attempt decoding
1245:yack.c        **** 				buffer = bcntr = 0;			// Clear buffer
 1959               	.LM263:
 1960 06d2 1092 0000 		sts bcntr.2203,__zero_reg__
 1961 06d6 1092 0000 		sts buffer.2202,__zero_reg__
1246:yack.c        **** 				timer = (IWGLEN - ICGLEN) * wpmcnt;	// If 4 further dots of gap,
 1963               	.LM264:
 1964 06da 2091 0000 		lds r18,wpmcnt
 1965 06de 3091 0000 		lds r19,wpmcnt+1
 1966 06e2 220F      		lsl r18
 1967 06e4 331F      		rol r19
 1968 06e6 220F      		lsl r18
 1969 06e8 331F      		rol r19
 1970 06ea 3093 0000 		sts timer.2200+1,r19
 1971 06ee 2093 0000 		sts timer.2200,r18
1247:yack.c        **** 				// this might be a Word gap.
1248:yack.c        **** 				iwgflag = 1;                // Signal we are waiting for IWG                          
 1973               	.LM265:
 1974 06f2 91E0      		ldi r25,lo8(1)
 1975 06f4 9093 0000 		sts iwgflag.2204,r25
1249:yack.c        **** 				return (retchar);			// and return decoded char
 1977               	.LM266:
 1978 06f8 00C0      		rjmp .L160
 1979               	.L172:
1250:yack.c        **** 			}
1251:yack.c        **** 			
1252:yack.c        **** 			// This handles the Inter-word gap. Already 3 dots have been
1253:yack.c        **** 			// waited for, if 4 more follow, interpret this as a word end
1254:yack.c        **** 			if (timer == 0 && iwgflag) // Have we idled for 4+3 = 7 dots?
 1981               	.LM267:
 1982 06fa 8091 0000 		lds r24,iwgflag.2204
 1983 06fe 8823      		tst r24
 1984 0700 01F0      		breq .L171
1255:yack.c        **** 			{
1256:yack.c        **** 				iwgflag = 0;   // Clear Interword Gap flag
 1986               	.LM268:
 1987 0702 1092 0000 		sts iwgflag.2204,__zero_reg__
1257:yack.c        **** 				return (' ');  // And return a space
 1989               	.LM269:
 1990 0706 80E2      		ldi r24,lo8(32)
 1991 0708 00C0      		rjmp .L160
 1992               	.L171:
1258:yack.c        **** 			}
1259:yack.c        **** 			
1260:yack.c        **** 			// Now evaluate the latch and determine what to send next
1261:yack.c        **** 			if ( volflags & (DITLATCH | DAHLATCH)) // Anything in the latch?
 1994               	.LM270:
 1995 070a C091 0000 		lds r28,volflags
 1996 070e 8C2F      		mov r24,r28
 1997 0710 8370      		andi r24,lo8(3)
 1998 0712 01F4      		brne .+2
 1999 0714 00C0      		rjmp .L197
1262:yack.c        **** 			{
1263:yack.c        **** 				iwgflag = 0; // No interword gap if dit or dah
 2001               	.LM271:
 2002 0716 1092 0000 		sts iwgflag.2204,__zero_reg__
1264:yack.c        ****                 bcntr++;	// Count that we will send something now
 2004               	.LM272:
 2005 071a 8091 0000 		lds r24,bcntr.2203
 2006 071e 8F5F      		subi r24,lo8(-(1))
 2007 0720 8093 0000 		sts bcntr.2203,r24
1265:yack.c        **** 				buffer = buffer << 1; // Make space for the new character
 2009               	.LM273:
 2010 0724 2091 0000 		lds r18,buffer.2202
 2011 0728 220F      		lsl r18
 2012 072a 2093 0000 		sts buffer.2202,r18
 2013 072e 8091 0000 		lds r24,wpmcnt
 2014 0732 9091 0000 		lds r25,wpmcnt+1
1266:yack.c        **** 				
1267:yack.c        **** 				if (volflags & DITLATCH) // Is it a dit?
 2016               	.LM274:
 2017 0736 C0FF      		sbrs r28,0
 2018 0738 00C0      		rjmp .L179
1268:yack.c        **** 				{
1269:yack.c        **** 					timer	= DITLEN * wpmcnt; // Duration = one dot time
 2020               	.LM275:
 2021 073a 9093 0000 		sts timer.2200+1,r25
 2022 073e 8093 0000 		sts timer.2200,r24
1270:yack.c        **** 					lastsymbol = DITLATCH; // Remember what we sent
 2024               	.LM276:
 2025 0742 81E0      		ldi r24,lo8(1)
 2026 0744 8093 0000 		sts lastsymbol.2201,r24
 2027 0748 00C0      		rjmp .L180
 2028               	.L179:
1271:yack.c        **** 				}
1272:yack.c        **** 				else // must be a DAH then..
1273:yack.c        **** 				{
1274:yack.c        **** 					timer	= DAHLEN * wpmcnt; // Duration = one dash time
 2030               	.LM277:
 2031 074a 63E0      		ldi r22,lo8(3)
 2032 074c 70E0      		ldi r23,0
 2033 074e 00D0      		rcall __mulhi3
 2034 0750 9093 0000 		sts timer.2200+1,r25
 2035 0754 8093 0000 		sts timer.2200,r24
1275:yack.c        **** 					lastsymbol = DAHLATCH; // Remember
 2037               	.LM278:
 2038 0758 82E0      		ldi r24,lo8(2)
 2039 075a 8093 0000 		sts lastsymbol.2201,r24
1276:yack.c        **** 					buffer |= 1; // set LSB to remember dash
 2041               	.LM279:
 2042 075e 2160      		ori r18,lo8(1)
 2043 0760 2093 0000 		sts buffer.2202,r18
 2044               	.L180:
1277:yack.c        **** 				}
1278:yack.c        **** 				
1279:yack.c        **** 				key(DOWN); // Switch on the side tone and TX
 2046               	.LM280:
 2047 0764 00D0      		rcall key.constprop.4
1280:yack.c        **** 				volflags &= ~(DITLATCH | DAHLATCH); // Reset both latches
 2049               	.LM281:
 2050 0766 CC7F      		andi r28,lo8(-4)
 2051 0768 C093 0000 		sts volflags,r28
1281:yack.c        **** 				
1282:yack.c        **** 				fsms 	= KEYED; // Change FSM state
 2053               	.LM282:
 2054 076c 81E0      		ldi r24,lo8(1)
 2055 076e 00C0      		rjmp .L200
 2056               	.L161:
 2057               	.LBB65:
 2058               	.LBB66:
 311:yack.c        ****     }
 2060               	.LM283:
 2061 0770 1092 0000 		sts shdntimer.2031,__zero_reg__
 2062 0774 1092 0000 		sts shdntimer.2031+1,__zero_reg__
 2063 0778 1092 0000 		sts shdntimer.2031+2,__zero_reg__
 2064 077c 1092 0000 		sts shdntimer.2031+3,__zero_reg__
 2065               	.LBE66:
 2066               	.LBE65:
1283:yack.c        **** 			}
1284:yack.c        **** 			
1285:yack.c        **** 			break;
1286:yack.c        **** 			
1287:yack.c        **** 		case KEYED:
1288:yack.c        **** 
1289:yack.c        **** #ifdef POWERSAVE
1290:yack.c        ****  			
1291:yack.c        ****             yackpower(FALSE); // can not go to sleep when keyed
1292:yack.c        **** 
1293:yack.c        **** #endif
1294:yack.c        ****             
1295:yack.c        **** 			if ((yackflags & MODE) == IAMBICB) // If we are in IAMBIC B mode
 2068               	.LM284:
 2069 0780 8091 0000 		lds r24,yackflags
 2070 0784 8C70      		andi r24,lo8(12)
 2071 0786 8430      		cpi r24,lo8(4)
 2072 0788 01F4      		brne .L181
1296:yack.c        **** 				keylatch();                      // then latch here already 
 2074               	.LM285:
 2075 078a 00D0      		rcall keylatch
 2076               	.L181:
1297:yack.c        **** 			
1298:yack.c        **** 			if(timer == 0) // Done with sounding our element?
 2078               	.LM286:
 2079 078c 8091 0000 		lds r24,timer.2200
 2080 0790 9091 0000 		lds r25,timer.2200+1
 2081 0794 892B      		or r24,r25
 2082 0796 01F4      		brne .L197
 2083               	.LBB67:
 2084               	.LBB68:
 2085 0798 00D0      		rcall key.part.0
 2086               	.LBE68:
 2087               	.LBE67:
1299:yack.c        **** 			{
1300:yack.c        **** 				key(UP); // Then cancel the side tone
1301:yack.c        **** 				timer	= IEGLEN * wpmcnt; // One dot time for the gap
 2089               	.LM287:
 2090 079a 8091 0000 		lds r24,wpmcnt
 2091 079e 9091 0000 		lds r25,wpmcnt+1
 2092 07a2 9093 0000 		sts timer.2200+1,r25
 2093 07a6 8093 0000 		sts timer.2200,r24
1302:yack.c        **** 				fsms	= IEG; // Change FSM state
 2095               	.LM288:
 2096 07aa 82E0      		ldi r24,lo8(2)
 2097               	.L200:
 2098 07ac 8093 0000 		sts fsms.2199,r24
 2099 07b0 00C0      		rjmp .L197
 2100               	.L163:
1303:yack.c        **** 			}
1304:yack.c        **** 			
1305:yack.c        **** 			break;
1306:yack.c        **** 			
1307:yack.c        **** 			
1308:yack.c        **** 		case IEG:
1309:yack.c        **** 			
1310:yack.c        **** 			keylatch();	// Latch any paddle movements (both A and B)
 2102               	.LM289:
 2103 07b2 00D0      		rcall keylatch
1311:yack.c        **** 			
1312:yack.c        **** 			if(timer == 0) // End of gap reached?
 2105               	.LM290:
 2106 07b4 8091 0000 		lds r24,timer.2200
 2107 07b8 9091 0000 		lds r25,timer.2200+1
 2108 07bc 892B      		or r24,r25
 2109 07be 01F4      		brne .L197
1313:yack.c        **** 			{
1314:yack.c        **** 				fsms	= IDLE; // Change FSM state
 2111               	.LM291:
 2112 07c0 1092 0000 		sts fsms.2199,__zero_reg__
1315:yack.c        **** 				// The following timer determines what the IDLE state
1316:yack.c        ****                 // accepts as character. Anything longer than 2 dots as gap will be
1317:yack.c        ****                 // accepted for a character end.
1318:yack.c        **** 				timer	= (ICGLEN - IEGLEN -1) * wpmcnt; 
 2114               	.LM292:
 2115 07c4 8091 0000 		lds r24,wpmcnt
 2116 07c8 9091 0000 		lds r25,wpmcnt+1
 2117 07cc 9093 0000 		sts timer.2200+1,r25
 2118 07d0 8093 0000 		sts timer.2200,r24
 2119               	.L197:
1319:yack.c        **** 			}
1320:yack.c        **** 			break;
1321:yack.c        **** 			
1322:yack.c        **** 	}
1323:yack.c        **** 	
1324:yack.c        **** 	return '\0'; // Nothing to return if not returned in above routine
 2121               	.LM293:
 2122 07d4 80E0      		ldi r24,0
 2123               	.L160:
 2124               	/* epilogue start */
1325:yack.c        **** 	
1326:yack.c        **** }
 2126               	.LM294:
 2127 07d6 CF91      		pop r28
 2128 07d8 0895      		ret
 2142               	.Lscope28:
 2146               	.global	yackmessage
 2148               	yackmessage:
1059:yack.c        **** 	unsigned char	rambuffer[RBSIZE];  // Storage for the message
 2150               	.LM295:
 2151               	.LFBB29:
 2152 07da EF92      		push r14
 2153 07dc FF92      		push r15
 2154 07de 0F93      		push r16
 2155 07e0 1F93      		push r17
 2156 07e2 CF93      		push r28
 2157 07e4 DF93      		push r29
 2158 07e6 CDB7      		in r28,__SP_L__
 2159 07e8 DEB7      		in r29,__SP_H__
 2160 07ea C456      		subi r28,100
 2161 07ec D109      		sbc r29,__zero_reg__
 2162 07ee 0FB6      		in __tmp_reg__,__SREG__
 2163 07f0 F894      		cli
 2164 07f2 DEBF      		out __SP_H__,r29
 2165 07f4 0FBE      		out __SREG__,__tmp_reg__
 2166 07f6 CDBF      		out __SP_L__,r28
 2167               	/* prologue: function */
 2168               	/* frame size = 100 */
 2169               	/* stack size = 106 */
 2170               	.L__stack_usage = 106
 2171 07f8 062F      		mov r16,r22
1068:yack.c        **** 	{
 2173               	.LM296:
 2174 07fa 8130      		cpi r24,lo8(1)
 2175 07fc 01F0      		breq .+2
 2176 07fe 00C0      		rjmp .L202
 2177 0800 10E0      		ldi r17,0
 2178 0802 98EE      		ldi r25,lo8(-24)
 2179 0804 E92E      		mov r14,r25
 2180 0806 93E0      		ldi r25,lo8(3)
 2181 0808 F92E      		mov r15,r25
 2182               	.L207:
1074:yack.c        **** 			
 2184               	.LM297:
 2185 080a 81E0      		ldi r24,lo8(1)
 2186 080c 00D0      		rcall yackctrlkey
 2187 080e 8111      		cpse r24,__zero_reg__
 2188 0810 00C0      		rjmp .L201
1076:yack.c        **** 			{
 2190               	.LM298:
 2191 0812 81E0      		ldi r24,lo8(1)
 2192 0814 00D0      		rcall yackiambic
 2193 0816 8111      		cpse r24,__zero_reg__
 2194 0818 00C0      		rjmp .L204
1072:yack.c        ****    		{
 2196               	.LM299:
 2197 081a 81E0      		ldi r24,1
 2198 081c E81A      		sub r14,r24
 2199 081e F108      		sbc r15,__zero_reg__
 2200 0820 00C0      		rjmp .L205
 2201               	.L204:
1078:yack.c        **** 				extimer = YACKSECS(DEFTIMEOUT); // Reset End of message timer
 2203               	.LM300:
 2204 0822 E1E0      		ldi r30,lo8(1)
 2205 0824 F0E0      		ldi r31,0
 2206 0826 EC0F      		add r30,r28
 2207 0828 FD1F      		adc r31,r29
 2208 082a E10F      		add r30,r17
 2209 082c F11D      		adc r31,__zero_reg__
 2210 082e 8083      		st Z,r24
 2211 0830 1F5F      		subi r17,lo8(-(1))
1079:yack.c        **** 			}
 2213               	.LM301:
 2214 0832 88EE      		ldi r24,lo8(-24)
 2215 0834 E82E      		mov r14,r24
 2216 0836 83E0      		ldi r24,lo8(3)
 2217 0838 F82E      		mov r15,r24
 2218               	.L205:
1082:yack.c        **** 			{
 2220               	.LM302:
 2221 083a 1436      		cpi r17,lo8(100)
 2222 083c 00F0      		brlo .L206
1084:yack.c        **** 				i = 0;
 2224               	.LM303:
 2225 083e 00D0      		rcall yackerror
1085:yack.c        **** 			}
 2227               	.LM304:
 2228 0840 10E0      		ldi r17,0
 2229               	.L206:
1088:yack.c        **** 		}	
 2231               	.LM305:
 2232 0842 00D0      		rcall yackbeat
1072:yack.c        ****    		{
 2234               	.LM306:
 2235 0844 E114      		cp r14,__zero_reg__
 2236 0846 F104      		cpc r15,__zero_reg__
 2237 0848 01F4      		brne .L207
1093:yack.c        **** 		{
 2239               	.LM307:
 2240 084a 1123      		tst r17
 2241 084c 01F0      		breq .L208
1095:yack.c        **** 			
 2243               	.LM308:
 2244 084e 1150      		subi r17,lo8(-(-1))
 2245 0850 E1E0      		ldi r30,lo8(1)
 2246 0852 F0E0      		ldi r31,0
 2247 0854 EC0F      		add r30,r28
 2248 0856 FD1F      		adc r31,r29
 2249 0858 E10F      		add r30,r17
 2250 085a F11D      		adc r31,__zero_reg__
 2251 085c 1082      		st Z,__zero_reg__
1104:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer1,RBSIZE);
 2253               	.LM309:
 2254 085e 0130      		cpi r16,lo8(1)
 2255 0860 01F4      		brne .L209
1105:yack.c        **** 			if (msgnr == 2)
 2257               	.LM310:
 2258 0862 44E6      		ldi r20,lo8(100)
 2259 0864 50E0      		ldi r21,0
 2260 0866 60E0      		ldi r22,lo8(eebuffer1)
 2261 0868 70E0      		ldi r23,hi8(eebuffer1)
 2262 086a 00C0      		rjmp .L222
 2263               	.L209:
1106:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer2,RBSIZE);
 2265               	.LM311:
 2266 086c 0230      		cpi r16,lo8(2)
 2267 086e 01F4      		brne .L211
1107:yack.c        **** 			if (msgnr == 3)
 2269               	.LM312:
 2270 0870 44E6      		ldi r20,lo8(100)
 2271 0872 50E0      		ldi r21,0
 2272 0874 60E0      		ldi r22,lo8(eebuffer2)
 2273 0876 70E0      		ldi r23,hi8(eebuffer2)
 2274               	.L222:
 2275 0878 CE01      		movw r24,r28
 2276 087a 0196      		adiw r24,1
 2277 087c 00D0      		rcall eeprom_write_block
 2278 087e 00C0      		rjmp .L201
 2279               	.L211:
1108:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer3,RBSIZE);
 2281               	.LM313:
 2282 0880 0330      		cpi r16,lo8(3)
 2283 0882 01F4      		brne .L212
1109:yack.c        **** 			if (msgnr == 4)
 2285               	.LM314:
 2286 0884 44E6      		ldi r20,lo8(100)
 2287 0886 50E0      		ldi r21,0
 2288 0888 60E0      		ldi r22,lo8(eebuffer3)
 2289 088a 70E0      		ldi r23,hi8(eebuffer3)
 2290 088c 00C0      		rjmp .L222
 2291               	.L212:
1110:yack.c        **** 	  			eeprom_write_block(rambuffer,eebuffer4,RBSIZE);
 2293               	.LM315:
 2294 088e 0430      		cpi r16,lo8(4)
 2295 0890 01F4      		brne .L201
1111:yack.c        **** 		}
 2297               	.LM316:
 2298 0892 44E6      		ldi r20,lo8(100)
 2299 0894 50E0      		ldi r21,0
 2300 0896 60E0      		ldi r22,lo8(eebuffer4)
 2301 0898 70E0      		ldi r23,hi8(eebuffer4)
 2302 089a 00C0      		rjmp .L222
 2303               	.L208:
1114:yack.c        **** 	}
 2305               	.LM317:
 2306 089c 00D0      		rcall yackerror
 2307 089e 00C0      		rjmp .L201
 2308               	.L202:
1118:yack.c        **** 	{
 2310               	.LM318:
 2311 08a0 8230      		cpi r24,lo8(2)
 2312 08a2 01F4      		brne .L201
1121:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer1,RBSIZE);
 2314               	.LM319:
 2315 08a4 6130      		cpi r22,lo8(1)
 2316 08a6 01F4      		brne .L213
1122:yack.c        **** 		if (msgnr == 2)
 2318               	.LM320:
 2319 08a8 44E6      		ldi r20,lo8(100)
 2320 08aa 50E0      		ldi r21,0
 2321 08ac 60E0      		ldi r22,lo8(eebuffer1)
 2322 08ae 70E0      		ldi r23,hi8(eebuffer1)
 2323 08b0 00C0      		rjmp .L221
 2324               	.L213:
1123:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer2,RBSIZE);
 2326               	.LM321:
 2327 08b2 6230      		cpi r22,lo8(2)
 2328 08b4 01F4      		brne .L215
1124:yack.c        **** 		if (msgnr == 3)
 2330               	.LM322:
 2331 08b6 44E6      		ldi r20,lo8(100)
 2332 08b8 50E0      		ldi r21,0
 2333 08ba 60E0      		ldi r22,lo8(eebuffer2)
 2334 08bc 70E0      		ldi r23,hi8(eebuffer2)
 2335 08be 00C0      		rjmp .L221
 2336               	.L215:
1125:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer3,RBSIZE);
 2338               	.LM323:
 2339 08c0 6330      		cpi r22,lo8(3)
 2340 08c2 01F4      		brne .L216
1126:yack.c        **** 		if (msgnr == 4)
 2342               	.LM324:
 2343 08c4 44E6      		ldi r20,lo8(100)
 2344 08c6 50E0      		ldi r21,0
 2345 08c8 60E0      		ldi r22,lo8(eebuffer3)
 2346 08ca 70E0      		ldi r23,hi8(eebuffer3)
 2347 08cc 00C0      		rjmp .L221
 2348               	.L216:
1127:yack.c        **** 	  		eeprom_read_block(rambuffer,eebuffer4,RBSIZE);
 2350               	.LM325:
 2351 08ce 6430      		cpi r22,lo8(4)
 2352 08d0 01F4      		brne .L214
1128:yack.c        **** 		
 2354               	.LM326:
 2355 08d2 44E6      		ldi r20,lo8(100)
 2356 08d4 50E0      		ldi r21,0
 2357 08d6 60E0      		ldi r22,lo8(eebuffer4)
 2358 08d8 70E0      		ldi r23,hi8(eebuffer4)
 2359               	.L221:
 2360 08da CE01      		movw r24,r28
 2361 08dc 0196      		adiw r24,1
 2362 08de 00D0      		rcall eeprom_read_block
 2363               	.L214:
1085:yack.c        **** 			}
 2365               	.LM327:
 2366 08e0 10E0      		ldi r17,0
 2367               	.L217:
1131:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
 2369               	.LM328:
 2370 08e2 E1E0      		ldi r30,lo8(1)
 2371 08e4 F0E0      		ldi r31,0
 2372 08e6 EC0F      		add r30,r28
 2373 08e8 FD1F      		adc r31,r29
 2374 08ea E10F      		add r30,r17
 2375 08ec F11D      		adc r31,__zero_reg__
 2376 08ee 0081      		ld r16,Z
 2377 08f0 0023      		tst r16
 2378 08f2 01F0      		breq .L201
1132:yack.c        **** 			yackchar(c); // play it back 
 2380               	.LM329:
 2381 08f4 80E0      		ldi r24,0
 2382 08f6 00D0      		rcall yackctrlkey
 2383 08f8 8111      		cpse r24,__zero_reg__
 2384 08fa 00C0      		rjmp .L201
1133:yack.c        **** 		}
 2386               	.LM330:
 2387 08fc 802F      		mov r24,r16
 2388 08fe 00D0      		rcall yackchar
1131:yack.c        **** 		if (yackctrlkey(FALSE)) {return;} //Break immediately if command key pressed
 2390               	.LM331:
 2391 0900 1F5F      		subi r17,lo8(-(1))
 2392 0902 00C0      		rjmp .L217
 2393               	.L201:
 2394               	/* epilogue start */
1136:yack.c        **** 
 2396               	.LM332:
 2397 0904 CC59      		subi r28,-100
 2398 0906 DF4F      		sbci r29,-1
 2399 0908 0FB6      		in __tmp_reg__,__SREG__
 2400 090a F894      		cli
 2401 090c DEBF      		out __SP_H__,r29
 2402 090e 0FBE      		out __SREG__,__tmp_reg__
 2403 0910 CDBF      		out __SP_L__,r28
 2404 0912 DF91      		pop r29
 2405 0914 CF91      		pop r28
 2406 0916 1F91      		pop r17
 2407 0918 0F91      		pop r16
 2408 091a FF90      		pop r15
 2409 091c EF90      		pop r14
 2410 091e 0895      		ret
 2417               	.Lscope29:
 2418               		.local	buffer.2202
 2419               		.comm	buffer.2202,1,1
 2420               		.local	bcntr.2203
 2421               		.comm	bcntr.2203,1,1
 2422               		.local	ultimem.2205
 2423               		.comm	ultimem.2205,1,1
 2424               		.local	lastsymbol.2201
 2425               		.comm	lastsymbol.2201,1,1
 2426               		.local	fsms.2199
 2427               		.comm	fsms.2199,1,1
 2428               		.local	iwgflag.2204
 2429               		.comm	iwgflag.2204,1,1
 2430               		.local	timer.2200
 2431               		.comm	timer.2200,2,1
 2432               		.local	shdntimer.2031
 2433               		.comm	shdntimer.2031,4,1
 2434               	.global	spechar
 2435               		.section	.progmem.data,"a",@progbits
 2438               	spechar:
 2439 0000 3F2E 2F21 		.ascii	"?./!,:;~$^()-@_|=#+*%&<>"
 2439      2C3A 3B7E 
 2439      245E 2829 
 2439      2D40 5F7C 
 2439      3D23 2B2A 
 2440               	.global	morse
 2443               	morse:
 2444 0018 FC        		.byte	-4
 2445 0019 7C        		.byte	124
 2446 001a 3C        		.byte	60
 2447 001b 1C        		.byte	28
 2448 001c 0C        		.byte	12
 2449 001d 04        		.byte	4
 2450 001e 84        		.byte	-124
 2451 001f C4        		.byte	-60
 2452 0020 E4        		.byte	-28
 2453 0021 F4        		.byte	-12
 2454 0022 60        		.byte	96
 2455 0023 88        		.byte	-120
 2456 0024 A8        		.byte	-88
 2457 0025 90        		.byte	-112
 2458 0026 40        		.byte	64
 2459 0027 28        		.byte	40
 2460 0028 D0        		.byte	-48
 2461 0029 08        		.byte	8
 2462 002a 20        		.byte	32
 2463 002b 78        		.byte	120
 2464 002c B0        		.byte	-80
 2465 002d 48        		.byte	72
 2466 002e E0        		.byte	-32
 2467 002f A0        		.byte	-96
 2468 0030 F0        		.byte	-16
 2469 0031 68        		.byte	104
 2470 0032 D8        		.byte	-40
 2471 0033 50        		.byte	80
 2472 0034 10        		.byte	16
 2473 0035 C0        		.byte	-64
 2474 0036 30        		.byte	48
 2475 0037 18        		.byte	24
 2476 0038 70        		.byte	112
 2477 0039 98        		.byte	-104
 2478 003a B8        		.byte	-72
 2479 003b C8        		.byte	-56
 2480 003c 32        		.byte	50
 2481 003d 56        		.byte	86
 2482 003e 94        		.byte	-108
 2483 003f E8        		.byte	-24
 2484 0040 CE        		.byte	-50
 2485 0041 E2        		.byte	-30
 2486 0042 AA        		.byte	-86
 2487 0043 4A        		.byte	74
 2488 0044 13        		.byte	19
 2489 0045 7A        		.byte	122
 2490 0046 B4        		.byte	-76
 2491 0047 B6        		.byte	-74
 2492 0048 86        		.byte	-122
 2493 0049 6A        		.byte	106
 2494 004a 36        		.byte	54
 2495 004b 52        		.byte	82
 2496 004c 8C        		.byte	-116
 2497 004d 16        		.byte	22
 2498 004e 54        		.byte	84
 2499 004f 8B        		.byte	-117
 2500 0050 44        		.byte	68
 2501 0051 AC        		.byte	-84
 2502 0052 14        		.byte	20
 2503 0053 58        		.byte	88
 2504               	.global	eebuffer4
 2505               		.section	.eeprom,"aw",@progbits
 2508               	eebuffer4:
 2509 0000 6D65 7373 		.string	"message 4"
 2509      6167 6520 
 2509      3400 
 2510 000a 0000 0000 		.zero	90
 2510      0000 0000 
 2510      0000 0000 
 2510      0000 0000 
 2510      0000 0000 
 2511               	.global	eebuffer3
 2514               	eebuffer3:
 2515 0064 6D65 7373 		.string	"message 3"
 2515      6167 6520 
 2515      3300 
 2516 006e 0000 0000 		.zero	90
 2516      0000 0000 
 2516      0000 0000 
 2516      0000 0000 
 2516      0000 0000 
 2517               	.global	eebuffer2
 2520               	eebuffer2:
 2521 00c8 6D65 7373 		.string	"message 2"
 2521      6167 6520 
 2521      3200 
 2522 00d2 0000 0000 		.zero	90
 2522      0000 0000 
 2522      0000 0000 
 2522      0000 0000 
 2522      0000 0000 
 2523               	.global	eebuffer1
 2526               	eebuffer1:
 2527 012c 6D65 7373 		.string	"message 1"
 2527      6167 6520 
 2527      3100 
 2528 0136 0000 0000 		.zero	90
 2528      0000 0000 
 2528      0000 0000 
 2528      0000 0000 
 2528      0000 0000 
 2529               	.global	user2
 2532               	user2:
 2533 0190 0000      		.zero	2
 2534               	.global	user1
 2537               	user1:
 2538 0192 0000      		.zero	2
 2539               	.global	fwstor
 2542               	fwstor:
 2543 0194 00        		.zero	1
 2544               	.global	wpmstor
 2547               	wpmstor:
 2548 0195 0F        		.byte	15
 2549               	.global	ctcstor
 2552               	ctcstor:
 2553 0196 4D00      		.word	77
 2554               	.global	flagstor
 2557               	flagstor:
 2558 0198 34        		.byte	52
 2559               	.global	magic
 2562               	magic:
 2563 0199 A5        		.byte	-91
 2564               		.local	farnsworth
 2565               		.comm	farnsworth,1,1
 2566               		.local	wpm
 2567               		.comm	wpm,1,1
 2568               		.local	wpmcnt
 2569               		.comm	wpmcnt,2,1
 2570               		.local	ctcvalue
 2571               		.comm	ctcvalue,2,1
 2572               		.local	volflags
 2573               		.comm	volflags,1,1
 2574               		.local	yackflags
 2575               		.comm	yackflags,1,1
 2595               		.text
 2597               	.Letext0:
 2598               		.ident	"GCC: (GNU) 5.4.0"
 2599               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 yack.c
     /tmp/ccUp0P4Q.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccUp0P4Q.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccUp0P4Q.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccUp0P4Q.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccUp0P4Q.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccUp0P4Q.s:121    .text:0000000000000000 keylatch
     /tmp/ccUp0P4Q.s:2573   .bss:0000000000000013 yackflags
     /tmp/ccUp0P4Q.s:2571   .bss:0000000000000012 volflags
     /tmp/ccUp0P4Q.s:179    .text:0000000000000038 key.part.0
     /tmp/ccUp0P4Q.s:223    .text:000000000000005c yackinhibit.part.3
     /tmp/ccUp0P4Q.s:249    .text:0000000000000072 key.constprop.4
     /tmp/ccUp0P4Q.s:2569   .bss:0000000000000010 ctcvalue
     /tmp/ccUp0P4Q.s:305    .text:00000000000000a8 __vector_2
     /tmp/ccUp0P4Q.s:332    .text:00000000000000bc yackpower
     /tmp/ccUp0P4Q.s:2431   .bss:0000000000000008 shdntimer.2031
     /tmp/ccUp0P4Q.s:434    .text:0000000000000136 yacksave
     /tmp/ccUp0P4Q.s:2562   .eeprom:0000000000000199 magic
     /tmp/ccUp0P4Q.s:2552   .eeprom:0000000000000196 ctcstor
     /tmp/ccUp0P4Q.s:2565   .bss:000000000000000d wpm
     /tmp/ccUp0P4Q.s:2547   .eeprom:0000000000000195 wpmstor
     /tmp/ccUp0P4Q.s:2557   .eeprom:0000000000000198 flagstor
     /tmp/ccUp0P4Q.s:2433   .bss:000000000000000c farnsworth
     /tmp/ccUp0P4Q.s:2542   .eeprom:0000000000000194 fwstor
     /tmp/ccUp0P4Q.s:494    .text:000000000000017e yackreset
     /tmp/ccUp0P4Q.s:2567   .bss:000000000000000e wpmcnt
     /tmp/ccUp0P4Q.s:538    .text:00000000000001b2 yackinit
     /tmp/ccUp0P4Q.s:645    .text:0000000000000226 yackinhibit
     /tmp/ccUp0P4Q.s:674    .text:000000000000023a yackuser
     /tmp/ccUp0P4Q.s:2537   .eeprom:0000000000000192 user1
     /tmp/ccUp0P4Q.s:2532   .eeprom:0000000000000190 user2
     /tmp/ccUp0P4Q.s:744    .text:0000000000000274 yackwpm
     /tmp/ccUp0P4Q.s:764    .text:000000000000027c yackbeat
     /tmp/ccUp0P4Q.s:790    .text:000000000000028a yackpitch
     /tmp/ccUp0P4Q.s:861    .text:00000000000002ea yackmode
     /tmp/ccUp0P4Q.s:887    .text:0000000000000302 yackflag
     /tmp/ccUp0P4Q.s:908    .text:000000000000030a yacktoggle
     /tmp/ccUp0P4Q.s:933    .text:0000000000000320 yackdelay
     /tmp/ccUp0P4Q.s:977    .text:0000000000000342 yackfarns
     /tmp/ccUp0P4Q.s:1015   .text:000000000000035e yackplay
     /tmp/ccUp0P4Q.s:1071   .text:0000000000000388 yackspeed
     /tmp/ccUp0P4Q.s:1180   .text:00000000000003fe yackerror
     /tmp/ccUp0P4Q.s:1221   .text:0000000000000414 yackctrlkey
     /tmp/ccUp0P4Q.s:1346   .text:000000000000047e yacktune
     /tmp/ccUp0P4Q.s:1402   .text:00000000000004a6 yackchar
     /tmp/ccUp0P4Q.s:2443   .progmem.data:0000000000000018 morse
     /tmp/ccUp0P4Q.s:2438   .progmem.data:0000000000000000 spechar
     /tmp/ccUp0P4Q.s:1597   .text:000000000000053a yackstring
     /tmp/ccUp0P4Q.s:1652   .text:0000000000000562 yacknumber
     /tmp/ccUp0P4Q.s:1749   .text:00000000000005c8 yackiambic
     /tmp/ccUp0P4Q.s:2429   .bss:0000000000000006 timer.2200
     /tmp/ccUp0P4Q.s:2427   .bss:0000000000000005 iwgflag.2204
     /tmp/ccUp0P4Q.s:2425   .bss:0000000000000004 fsms.2199
     /tmp/ccUp0P4Q.s:2423   .bss:0000000000000003 lastsymbol.2201
     /tmp/ccUp0P4Q.s:2421   .bss:0000000000000002 ultimem.2205
     /tmp/ccUp0P4Q.s:2419   .bss:0000000000000001 bcntr.2203
                             .bss:0000000000000000 buffer.2202
     /tmp/ccUp0P4Q.s:2148   .text:00000000000007da yackmessage
     /tmp/ccUp0P4Q.s:2526   .eeprom:000000000000012c eebuffer1
     /tmp/ccUp0P4Q.s:2520   .eeprom:00000000000000c8 eebuffer2
     /tmp/ccUp0P4Q.s:2514   .eeprom:0000000000000064 eebuffer3
     /tmp/ccUp0P4Q.s:2508   .eeprom:0000000000000000 eebuffer4

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_write_word
eeprom_read_byte
eeprom_read_word
__divmodhi4
__udivmodhi4
__mulhi3
eeprom_write_block
eeprom_read_block
__do_clear_bss
