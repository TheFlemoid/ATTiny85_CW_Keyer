   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 113               	.global	pitch
 115               	pitch:
   1:main.c        **** /*!
   2:main.c        ****  
   3:main.c        ****  @file      main.c
   4:main.c        ****  @brief     CW Keyer application
   5:main.c        ****  @author    Jan Lategahn DK3LJ jan@lategahn.com (C) 2010 modified by Jack Welch AI4SV; modified by 
   6:main.c        **** 
   7:main.c        ****  This file implements a sample CW keyer application by using the yack.c
   8:main.c        ****  library. It is targeted at the ATTINY45 microcontroller but can be used
   9:main.c        ****  for other ATMEL controllers in the same way. Note the enclosed documentation
  10:main.c        ****  for further defails.
  11:main.c        ****  
  12:main.c        ****  This program is free software: you can redistribute it and/or modify
  13:main.c        ****  it under the terms of the GNU General Public License as published by
  14:main.c        ****  the Free Software Foundation, either version 3 of the License, or
  15:main.c        ****  (at your option) any later version.
  16:main.c        ****  
  17:main.c        ****  This program is distributed in the hope that it will be useful,
  18:main.c        ****  but WITHOUT ANY WARRANTY; without even the implied warranty of
  19:main.c        ****  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  20:main.c        ****  GNU General Public License for more details.
  21:main.c        ****  
  22:main.c        ****  You should have received a copy of the GNU General Public License
  23:main.c        ****  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  24:main.c        ****  
  25:main.c        ****  @version   0.87
  26:main.c        ****  
  27:main.c        ****  @date      15.10.2010  - Created
  28:main.c        ****  @date      16.12.2010  - Submitted to SVN
  29:main.c        ****  @date      03.10.2013  - Last change
  30:main.c        ****  @date      21.12.2016  - Added additional prosigns and punctuation. Added 2 additional memories fo
  31:main.c        ****                           Fixed pitch change not saving after timeout. (WD9DMP)
  32:main.c        ****  @date      21.12.2016  - Added a call to save changes to EEPROM while in command mode loop if DIRT
  33:main.c        ****                           Changed "SK" response when leaving command mode to "#" which now decodes 
  34:main.c        **** 						  Beacon command ("N") was in both the lockable and unlockable command list, making it unlock
  35:main.c        **** 						  
  36:main.c        ****  @date      03.01.2017  - Added short 3 DAH delay after command returns before txok ("R") is sent t
  37:main.c        ****                           If memory recording is interrupted by command button, keyer now returns t
  38:main.c        **** 						  Removed playback of recorded message before saving.
  39:main.c        **** 						  When in Pitch change routine, allow breaking back to command mode with key press. Changes a
  40:main.c        **** 						  When in Farnsworth spacing change routine, allow breaking back to command mode with key pre
  41:main.c        **** 						  Changed Farnsworth setting mode to play continuous DIT-DAH when not holding paddle to adjus
  42:main.c        **** 						  Changed Version command to return to command mode instead of normal mode if interrupted wit
  43:main.c        **** 						  Changed speed inquiry command to return to command mode instead of normal mode if interrupt
  44:main.c        ****  */ 
  45:main.c        **** 
  46:main.c        **** 
  47:main.c        **** #ifndef F_CPU
  48:main.c        **** #error F_CPU undefined!! Please define in Makefile
  49:main.c        **** #endif
  50:main.c        **** 
  51:main.c        **** #include <avr/io.h> 
  52:main.c        **** #include <avr/pgmspace.h>
  53:main.c        **** #include <util/delay.h>
  54:main.c        **** #include "yack.h"
  55:main.c        **** 
  56:main.c        **** // Time after which callsign training is assumed complete
  57:main.c        **** #define		TRAINTIMEOUT	10      // 10 Seconds
  58:main.c        **** #define		PITCHREPEAT		10		// 10 e's will be played for pitch adjust
  59:main.c        **** #define     FARNSREPEAT     10      // 10 a's will be played for Farnsworth
  60:main.c        **** 
  61:main.c        **** // Some texts in Flash used by the application
  62:main.c        **** const char  txok[] PROGMEM 		= "R";
  63:main.c        **** const char  vers[] PROGMEM      = "V0.87";
  64:main.c        **** const char  prgx[] PROGMEM 		= "#"; // # decodes to prosign SK with no intercharacter gap
  65:main.c        **** const char  imok[] PROGMEM		= "73";
  66:main.c        **** 
  67:main.c        **** void pitch(void)
  68:main.c        **** /*! 
  69:main.c        ****  @brief     Pitch change mode
  70:main.c        ****  
  71:main.c        ****  This function implements pitch change mode. A series of dots is played and pitch can 
  72:main.c        ****  be adjusted using the paddle levers.
  73:main.c        ****  
  74:main.c        ****  Once 10 dots have been played at the same pitch, the mode terminates
  75:main.c        ****  */
  76:main.c        **** {
 117               	.LM0:
 118               	.LFBB1:
 119 0000 CF93      		push r28
 120 0002 DF93      		push r29
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 2 */
 124               	.L__stack_usage = 2
 125               	.L2:
 127               	.LM1:
 128 0004 CAE0      		ldi r28,lo8(10)
 129 0006 D0E0      		ldi r29,0
 130               	.L7:
  77:main.c        **** 	word	timer=PITCHREPEAT;
  78:main.c        **** 	
  79:main.c        **** 	while (timer) 			// while not yet timed out
  80:main.c        **** 	{
  81:main.c        **** 		timer--;
  82:main.c        **** 		yackchar('E');		// play an 'e'
 132               	.LM2:
 133 0008 85E4      		ldi r24,lo8(69)
 134 000a 00D0      		rcall yackchar
  83:main.c        **** 		
  84:main.c        **** 		if (yackctrlkey(TRUE)) {return;}
 136               	.LM3:
 137 000c 81E0      		ldi r24,lo8(1)
 138 000e 00D0      		rcall yackctrlkey
 139 0010 8111      		cpse r24,__zero_reg__
 140 0012 00C0      		rjmp .L1
  85:main.c        **** 		
  86:main.c        **** 		if(!(KEYINP & (1<<DITPIN))) // if DIT was keyed
 142               	.LM4:
 143 0014 B39B      		sbis 0x16,3
 144 0016 00C0      		rjmp .L4
  81:main.c        **** 		yackchar('E');		// play an 'e'
 146               	.LM5:
 147 0018 2197      		sbiw r28,1
 148 001a 00C0      		rjmp .L5
 149               	.L4:
  87:main.c        **** 	  	{
  88:main.c        **** 	  		yackpitch(DOWN);		// increase the pitch
 151               	.LM6:
 152 001c 82E0      		ldi r24,lo8(2)
 153 001e 00D0      		rcall yackpitch
  89:main.c        **** 	  		timer=PITCHREPEAT;
 155               	.LM7:
 156 0020 CAE0      		ldi r28,lo8(10)
 157 0022 D0E0      		ldi r29,0
 158               	.L5:
  90:main.c        **** 	  	}
  91:main.c        **** 		
  92:main.c        **** 		if(!(KEYINP & (1<<DAHPIN))) // if DAH was keyed
 160               	.LM8:
 161 0024 B499      		sbic 0x16,4
 162 0026 00C0      		rjmp .L6
  93:main.c        **** 	  	{
  94:main.c        **** 	  		yackpitch(UP);	// lower the pitch
 164               	.LM9:
 165 0028 81E0      		ldi r24,lo8(1)
 166 002a 00D0      		rcall yackpitch
 167 002c 00C0      		rjmp .L2
 168               	.L6:
  79:main.c        **** 	{
 170               	.LM10:
 171 002e 2097      		sbiw r28,0
 172 0030 01F4      		brne .L7
 173               	.L1:
 174               	/* epilogue start */
  95:main.c        **** 	  		timer=PITCHREPEAT;
  96:main.c        **** 	  	}
  97:main.c        **** 	  	
  98:main.c        **** 	}
  99:main.c        **** 	
 100:main.c        **** 	
 101:main.c        **** }
 176               	.LM11:
 177 0032 DF91      		pop r29
 178 0034 CF91      		pop r28
 179 0036 0895      		ret
 184               	.Lscope1:
 186               	.global	setfarns
 188               	setfarns:
 102:main.c        **** 
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        **** void setfarns(void)
 106:main.c        **** /*! 
 107:main.c        ****  @brief     Farnsworth change mode
 108:main.c        ****  
 109:main.c        ****  This function implements farnsworth pause change mode. Farnsworth pauses can be added or removed
 110:main.c        ****  with the paddle keys.
 111:main.c        ****  
 112:main.c        ****  */
 113:main.c        **** {
 190               	.LM12:
 191               	.LFBB2:
 192 0038 CF93      		push r28
 193               	.L19:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 1 */
 197               	.L__stack_usage = 1
 114:main.c        **** 	byte	timer=0;
 199               	.LM13:
 200 003a C0E0      		ldi r28,0
 201               	.L12:
 115:main.c        **** 	
 116:main.c        **** 	while (timer++ != FARNSREPEAT) 			// while not yet timed out
 117:main.c        **** 	{
 118:main.c        **** 	    if (yackctrlkey(TRUE)) {return;}
 203               	.LM14:
 204 003c 81E0      		ldi r24,lo8(1)
 205 003e 00D0      		rcall yackctrlkey
 206 0040 8111      		cpse r24,__zero_reg__
 207 0042 00C0      		rjmp .L11
 119:main.c        **** 		
 120:main.c        **** 	    yackplay(DIT);
 209               	.LM15:
 210 0044 81E0      		ldi r24,lo8(1)
 211 0046 00D0      		rcall yackplay
 121:main.c        ****         yackdelay(IEGLEN);	// Inter Element gap  
 213               	.LM16:
 214 0048 81E0      		ldi r24,lo8(1)
 215 004a 00D0      		rcall yackdelay
 122:main.c        ****         yackplay(DAH);
 217               	.LM17:
 218 004c 82E0      		ldi r24,lo8(2)
 219 004e 00D0      		rcall yackplay
 123:main.c        ****         yackdelay(ICGLEN);	// Inter Character gap  
 221               	.LM18:
 222 0050 83E0      		ldi r24,lo8(3)
 223 0052 00D0      		rcall yackdelay
 124:main.c        ****         yackfarns(); // Additional Farnsworth delay
 225               	.LM19:
 226 0054 00D0      		rcall yackfarns
 125:main.c        **** 	
 126:main.c        ****         
 127:main.c        **** 		if(!(KEYINP & (1<<DITPIN))) // if DIT was keyed
 228               	.LM20:
 229 0056 B399      		sbic 0x16,3
 230 0058 00C0      		rjmp .L14
 128:main.c        **** 	  	{
 129:main.c        **** 	  		yackspeed(DOWN,FARNSWORTH);		// increase interword spacing
 232               	.LM21:
 233 005a 61E0      		ldi r22,lo8(1)
 234 005c 82E0      		ldi r24,lo8(2)
 235 005e 00C0      		rjmp .L20
 236               	.L14:
 130:main.c        **** 	  		timer=0;
 131:main.c        **** 	  	}
 132:main.c        **** 		
 133:main.c        **** 		else if(!(KEYINP & (1<<DAHPIN))) // if DAH was keyed
 238               	.LM22:
 239 0060 B49B      		sbis 0x16,4
 240 0062 00C0      		rjmp .L16
 116:main.c        **** 	{
 242               	.LM23:
 243 0064 CF5F      		subi r28,lo8(-(1))
 244 0066 CA30      		cpi r28,lo8(10)
 245 0068 01F4      		brne .L12
 246 006a 00C0      		rjmp .L11
 247               	.L16:
 134:main.c        **** 	  	{
 135:main.c        **** 	  		yackspeed(UP,FARNSWORTH);	// decrease interword spacing
 249               	.LM24:
 250 006c 61E0      		ldi r22,lo8(1)
 251 006e 81E0      		ldi r24,lo8(1)
 252               	.L20:
 253 0070 00D0      		rcall yackspeed
 254 0072 00C0      		rjmp .L19
 255               	.L11:
 256               	/* epilogue start */
 136:main.c        **** 	  		timer=0;
 137:main.c        **** 	  	}
 138:main.c        **** 	  
 139:main.c        ****         
 140:main.c        **** 	}
 141:main.c        **** 	
 142:main.c        **** }
 258               	.LM25:
 259 0074 CF91      		pop r28
 260 0076 0895      		ret
 265               	.Lscope2:
 268               	.global	lfsr
 270               	lfsr:
 143:main.c        **** 
 144:main.c        **** 
 145:main.c        **** 
 146:main.c        **** 
 147:main.c        **** word lfsr(byte n)
 148:main.c        **** /*! 
 149:main.c        ****  @brief     Simple random number generator
 150:main.c        ****  
 151:main.c        ****  The library function random number generator works fine but is 
 152:main.c        ****  a nightmare in size as it utilizes various multiplications and
 153:main.c        ****  divisions (+600 Byte). This routine implements a LFSR (linear
 154:main.c        ****  feedback shift register) in the Galois method which is good enough 
 155:main.c        ****  for this specific application.
 156:main.c        ****  
 157:main.c        ****  @param n    a number between 2 and 255
 158:main.c        ****  @return     a random number between 0 and n-1
 159:main.c        ****  */
 160:main.c        **** {
 272               	.LM26:
 273               	.LFBB3:
 274               	/* prologue: function */
 275               	/* frame size = 0 */
 276               	/* stack size = 0 */
 277               	.L__stack_usage = 0
 161:main.c        **** 	
 162:main.c        **** 	static word 	lfsr = 0xACE1;
 163:main.c        **** 	byte			random;
 164:main.c        **** 	
 165:main.c        ****   	lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xB400u);    
 279               	.LM27:
 280 0078 4091 0000 		lds r20,lfsr.1962
 281 007c 5091 0000 		lds r21,lfsr.1962+1
 282 0080 9A01      		movw r18,r20
 283 0082 2170      		andi r18,1
 284 0084 3327      		clr r19
 285 0086 3195      		neg r19
 286 0088 2195      		neg r18
 287 008a 3109      		sbc r19,__zero_reg__
 288 008c 2227      		clr r18
 289 008e 347B      		andi r19,180
 290 0090 5695      		lsr r21
 291 0092 4795      		ror r20
 292 0094 2427      		eor r18,r20
 293 0096 3527      		eor r19,r21
 294 0098 3093 0000 		sts lfsr.1962+1,r19
 295 009c 2093 0000 		sts lfsr.1962,r18
 166:main.c        **** 	
 167:main.c        **** 	random = lfsr >> 8; // Byte = upper byte of word 
 297               	.LM28:
 298 00a0 932F      		mov r25,r19
 299               	.L22:
 168:main.c        **** 	
 169:main.c        **** 	while (random >= n) random -= n; // Cheap modulo :-)
 301               	.LM29:
 302 00a2 9817      		cp r25,r24
 303 00a4 00F0      		brlo .L24
 305               	.LM30:
 306 00a6 981B      		sub r25,r24
 307 00a8 00C0      		rjmp .L22
 308               	.L24:
 170:main.c        **** 	
 171:main.c        **** 	return random;
 172:main.c        **** 	
 173:main.c        **** }
 310               	.LM31:
 311 00aa 892F      		mov r24,r25
 312 00ac 90E0      		ldi r25,0
 313 00ae 0895      		ret
 319               	.Lscope3:
 322               	.global	rndcall
 324               	rndcall:
 174:main.c        **** 
 175:main.c        **** 
 176:main.c        **** 
 177:main.c        **** 
 178:main.c        **** 
 179:main.c        **** void rndcall(char* call)
 180:main.c        **** /*! 
 181:main.c        ****  @brief     Randomize a callsign
 182:main.c        ****  
 183:main.c        ****  This creates a random callsign with 2 letters + 1 digit + 2 letters
 184:main.c        ****  
 185:main.c        ****  @param call a pointer to a buffer of sufficient size to store the callsign
 186:main.c        ****  */
 187:main.c        **** {
 326               	.LM32:
 327               	.LFBB4:
 328 00b0 EF92      		push r14
 329 00b2 FF92      		push r15
 330 00b4 0F93      		push r16
 331 00b6 1F93      		push r17
 332 00b8 CF93      		push r28
 333               	/* prologue: function */
 334               	/* frame size = 0 */
 335               	/* stack size = 5 */
 336               	.L__stack_usage = 5
 337 00ba 7C01      		movw r14,r24
 338 00bc 8C01      		movw r16,r24
 188:main.c        **** 	byte	i;
 189:main.c        **** 	
 190:main.c        **** 	// Generate a random callsign 2 Char, 1 Digit, 2 Char
 191:main.c        **** 	
 192:main.c        **** 	for (i=0;i<5;i++)
 340               	.LM33:
 341 00be C0E0      		ldi r28,0
 342               	.L28:
 193:main.c        **** 	{
 194:main.c        **** 		if (i == 2)
 344               	.LM34:
 345 00c0 C230      		cpi r28,lo8(2)
 346 00c2 01F4      		brne .L26
 195:main.c        **** 			call[i]=lfsr(10) + '0';
 348               	.LM35:
 349 00c4 8AE0      		ldi r24,lo8(10)
 350 00c6 00D0      		rcall lfsr
 351 00c8 805D      		subi r24,lo8(-(48))
 352 00ca F701      		movw r30,r14
 353 00cc 8283      		std Z+2,r24
 354 00ce 00C0      		rjmp .L27
 355               	.L26:
 196:main.c        **** 		else
 197:main.c        **** 			call[i]=lfsr(26) + 'A';
 357               	.LM36:
 358 00d0 8AE1      		ldi r24,lo8(26)
 359 00d2 00D0      		rcall lfsr
 360 00d4 8F5B      		subi r24,lo8(-(65))
 361 00d6 F801      		movw r30,r16
 362 00d8 8083      		st Z,r24
 363               	.L27:
 192:main.c        **** 	{
 365               	.LM37:
 366 00da CF5F      		subi r28,lo8(-(1))
 367 00dc 0F5F      		subi r16,-1
 368 00de 1F4F      		sbci r17,-1
 369 00e0 C530      		cpi r28,lo8(5)
 370 00e2 01F4      		brne .L28
 371               	/* epilogue start */
 198:main.c        **** 		
 199:main.c        **** 	}
 200:main.c        **** }
 373               	.LM38:
 374 00e4 CF91      		pop r28
 375 00e6 1F91      		pop r17
 376 00e8 0F91      		pop r16
 377 00ea FF90      		pop r15
 378 00ec EF90      		pop r14
 379 00ee 0895      		ret
 384               	.Lscope4:
 386               	.global	cstrain
 388               	cstrain:
 201:main.c        **** 
 202:main.c        **** 
 203:main.c        **** 
 204:main.c        **** 
 205:main.c        **** void cstrain(void)
 206:main.c        **** /*! 
 207:main.c        ****  @brief     Callsign trainer mode
 208:main.c        ****  
 209:main.c        ****  This implements callsign training. The keyer plays a random callsign and the 
 210:main.c        ****  user repeats it on the paddle. If a mistake happens, the error prosign is
 211:main.c        ****  sounded, the callsign sent again and the user attempts one more time.
 212:main.c        ****  */
 213:main.c        **** {
 390               	.LM39:
 391               	.LFBB5:
 392 00f0 CF92      		push r12
 393 00f2 DF92      		push r13
 394 00f4 EF92      		push r14
 395 00f6 FF92      		push r15
 396 00f8 0F93      		push r16
 397 00fa 1F93      		push r17
 398 00fc CF93      		push r28
 399 00fe DF93      		push r29
 400 0100 00D0      		rcall .
 401 0102 00D0      		rcall .
 402 0104 1F92      		push __zero_reg__
 403 0106 CDB7      		in r28,__SP_L__
 404 0108 DEB7      		in r29,__SP_H__
 405               	/* prologue: function */
 406               	/* frame size = 5 */
 407               	/* stack size = 13 */
 408               	.L__stack_usage = 13
 409 010a 6E01      		movw r12,r28
 410 010c 86E0      		ldi r24,6
 411 010e C80E      		add r12,r24
 412 0110 D11C      		adc r13,__zero_reg__
 413               	.L42:
 214:main.c        **** 	char	call[5]; 	// A buffer to store the callsign
 215:main.c        **** 	char	c;			// The character returned by IAMBIC keyer
 216:main.c        **** 	byte	i;			// Counter
 217:main.c        **** 	byte	n;			// Playback counter
 218:main.c        **** 	word	timer;		// Timeout timer
 219:main.c        **** 	
 220:main.c        **** 	while(1)	// Endless loop will exit throught RETURN statement only
 221:main.c        **** 		
 222:main.c        **** 	{
 223:main.c        **** 		rndcall(call); // Make up a callsign
 415               	.LM40:
 416 0112 CE01      		movw r24,r28
 417 0114 0196      		adiw r24,1
 418 0116 00D0      		rcall rndcall
 224:main.c        **** 		
 225:main.c        **** 		i=0; // i counts the number of chracters correctly guessed
 420               	.LM41:
 421 0118 10E0      		ldi r17,0
 422               	.L31:
 226:main.c        **** 		
 227:main.c        **** 		while(i<5)
 228:main.c        **** 		{
 229:main.c        ****             if (!i) // If nothing guessed yet, play the callsign
 424               	.LM42:
 425 011a 1123      		tst r17
 426 011c 01F0      		breq .L32
 427               	.L36:
 225:main.c        **** 		
 429               	.LM43:
 430 011e 80ED      		ldi r24,lo8(-48)
 431 0120 E82E      		mov r14,r24
 432 0122 87E0      		ldi r24,lo8(7)
 433 0124 F82E      		mov r15,r24
 434               	.L33:
 230:main.c        **** 			{
 231:main.c        **** 				yackdelay(2 * IWGLEN); // Give him some time to breathe b4 next callsign
 232:main.c        **** 				for (n=0;n<5;n++)
 233:main.c        ****                 {    
 234:main.c        **** 					yackchar(call[n]);
 235:main.c        ****                     yackfarns(); // Add potential farnsworth delays
 236:main.c        ****                     if(yackctrlkey(TRUE)) 
 237:main.c        ****                         return; // Abort if requested..
 238:main.c        ****                 }
 239:main.c        **** 			}
 240:main.c        **** 			
 241:main.c        **** 			timer = YACKSECS(TRAINTIMEOUT);
 242:main.c        **** 			
 243:main.c        **** 			do 
 244:main.c        **** 			{ 
 245:main.c        **** 				
 246:main.c        **** 				c=yackiambic(OFF); 	// Wait for a character 
 436               	.LM44:
 437 0126 80E0      		ldi r24,0
 438 0128 00D0      		rcall yackiambic
 439 012a 082F      		mov r16,r24
 247:main.c        **** 				yackbeat();			// FSM heartbeat
 441               	.LM45:
 442 012c 00D0      		rcall yackbeat
 248:main.c        **** 				timer--;			// Countdown
 444               	.LM46:
 445 012e F1E0      		ldi r31,1
 446 0130 EF1A      		sub r14,r31
 447 0132 F108      		sbc r15,__zero_reg__
 249:main.c        ****                 
 250:main.c        **** 			} while ((!c) && timer && !(yackctrlkey(FALSE))); // Stop when character or timeout
 449               	.LM47:
 450 0134 0111      		cpse r16,__zero_reg__
 451 0136 00C0      		rjmp .L37
 453               	.LM48:
 454 0138 01F0      		breq .L30
 456               	.LM49:
 457 013a 80E0      		ldi r24,0
 458 013c 00D0      		rcall yackctrlkey
 459 013e 8823      		tst r24
 460 0140 01F0      		breq .L33
 461               	.L38:
 251:main.c        **** 			
 252:main.c        **** 			if (timer == 0 || yackctrlkey(TRUE))	// If termination because of timeout 
 463               	.LM50:
 464 0142 81E0      		ldi r24,lo8(1)
 465 0144 00D0      		rcall yackctrlkey
 466 0146 8111      		cpse r24,__zero_reg__
 467 0148 00C0      		rjmp .L30
 253:main.c        **** 				return;				// then return
 254:main.c        **** 			
 255:main.c        **** 			if (call[i] == c)		// Was it the right character?
 469               	.LM51:
 470 014a E1E0      		ldi r30,lo8(1)
 471 014c F0E0      		ldi r31,0
 472 014e EC0F      		add r30,r28
 473 0150 FD1F      		adc r31,r29
 474 0152 E10F      		add r30,r17
 475 0154 F11D      		adc r31,__zero_reg__
 476 0156 8081      		ld r24,Z
 477 0158 8017      		cp r24,r16
 478 015a 01F0      		breq .L53
 256:main.c        **** 				i++;				// then increment counter
 257:main.c        **** 			else
 258:main.c        **** 			{
 259:main.c        **** 		   		yackerror();		// Send an error prosign
 480               	.LM52:
 481 015c 00D0      		rcall yackerror
 260:main.c        **** 				i=0;				// And reset the counter
 483               	.LM53:
 484 015e 10E0      		ldi r17,0
 485               	.L32:
 231:main.c        **** 				for (n=0;n<5;n++)
 487               	.LM54:
 488 0160 8EE0      		ldi r24,lo8(14)
 489 0162 00D0      		rcall yackdelay
 490 0164 FE01      		movw r30,r28
 491 0166 3196      		adiw r30,1
 492 0168 7F01      		movw r14,r30
 493               	.L35:
 234:main.c        ****                     yackfarns(); // Add potential farnsworth delays
 495               	.LM55:
 496 016a F701      		movw r30,r14
 497 016c 8191      		ld r24,Z+
 498 016e 7F01      		movw r14,r30
 499 0170 00D0      		rcall yackchar
 235:main.c        ****                     if(yackctrlkey(TRUE)) 
 501               	.LM56:
 502 0172 00D0      		rcall yackfarns
 236:main.c        ****                         return; // Abort if requested..
 504               	.LM57:
 505 0174 81E0      		ldi r24,lo8(1)
 506 0176 00D0      		rcall yackctrlkey
 507 0178 8111      		cpse r24,__zero_reg__
 508 017a 00C0      		rjmp .L30
 232:main.c        ****                 {    
 510               	.LM58:
 511 017c EC14      		cp r14,r12
 512 017e FD04      		cpc r15,r13
 513 0180 01F4      		brne .L35
 514 0182 00C0      		rjmp .L36
 515               	.L37:
 252:main.c        **** 				return;				// then return
 517               	.LM59:
 518 0184 EF28      		or r14,r15
 519 0186 01F4      		brne .L38
 520 0188 00C0      		rjmp .L30
 521               	.L53:
 256:main.c        **** 			else
 523               	.LM60:
 524 018a 1F5F      		subi r17,lo8(-(1))
 227:main.c        **** 		{
 526               	.LM61:
 527 018c 1530      		cpi r17,lo8(5)
 528 018e 01F4      		brne .L31
 261:main.c        **** 			}
 262:main.c        **** 			
 263:main.c        **** 		}
 264:main.c        **** 		
 265:main.c        **** 		yackchar ('R');
 530               	.LM62:
 531 0190 82E5      		ldi r24,lo8(82)
 532 0192 00D0      		rcall yackchar
 266:main.c        **** 		
 267:main.c        **** 	}
 534               	.LM63:
 535 0194 00C0      		rjmp .L42
 536               	.L30:
 537               	/* epilogue start */
 268:main.c        **** }
 539               	.LM64:
 540 0196 0F90      		pop __tmp_reg__
 541 0198 0F90      		pop __tmp_reg__
 542 019a 0F90      		pop __tmp_reg__
 543 019c 0F90      		pop __tmp_reg__
 544 019e 0F90      		pop __tmp_reg__
 545 01a0 DF91      		pop r29
 546 01a2 CF91      		pop r28
 547 01a4 1F91      		pop r17
 548 01a6 0F91      		pop r16
 549 01a8 FF90      		pop r15
 550 01aa EF90      		pop r14
 551 01ac DF90      		pop r13
 552 01ae CF90      		pop r12
 553 01b0 0895      		ret
 561               	.Lscope5:
 564               	.global	beacon
 566               	beacon:
 269:main.c        **** 
 270:main.c        **** 
 271:main.c        **** 
 272:main.c        **** void beacon(byte mode)
 273:main.c        **** /*! 
 274:main.c        ****  @brief     Beacon mode
 275:main.c        ****  
 276:main.c        ****  This routine can read a beacon transmission interval up to 
 277:main.c        ****  9999 seconds and store it in EEPROM (RECORD mode)
 278:main.c        ****  In PLAY mode, when called in the YACKBEAT loop, it plays back
 279:main.c        ****  message 2 in the programmed interval
 280:main.c        ****  
 281:main.c        ****  @param mode RECORD (read and store the beacon interval) or PLAY (beacon)
 282:main.c        **** 
 283:main.c        ****  @see main
 284:main.c        ****  
 285:main.c        **** */
 286:main.c        **** {
 568               	.LM65:
 569               	.LFBB6:
 570 01b2 0F93      		push r16
 571 01b4 1F93      		push r17
 572 01b6 CF93      		push r28
 573               	/* prologue: function */
 574               	/* frame size = 0 */
 575               	/* stack size = 3 */
 576               	.L__stack_usage = 3
 577 01b8 C82F      		mov r28,r24
 287:main.c        **** 
 288:main.c        **** 	static word interval = 65000; // A dummy value that can not be reached
 289:main.c        **** 	static word timer;
 290:main.c        **** 	char c;
 291:main.c        **** 
 292:main.c        **** 	
 293:main.c        **** 	if (interval == 65000) // 
 579               	.LM66:
 580 01ba 8091 0000 		lds r24,interval.1994
 581 01be 9091 0000 		lds r25,interval.1994+1
 582 01c2 883E      		cpi r24,-24
 583 01c4 9D4F      		sbci r25,-3
 584 01c6 01F4      		brne .L55
 294:main.c        **** 		interval = yackuser(READ, 1, 0);	
 586               	.LM67:
 587 01c8 40E0      		ldi r20,0
 588 01ca 50E0      		ldi r21,0
 589 01cc 61E0      		ldi r22,lo8(1)
 590 01ce 81E0      		ldi r24,lo8(1)
 591 01d0 00D0      		rcall yackuser
 592 01d2 9093 0000 		sts interval.1994+1,r25
 593 01d6 8093 0000 		sts interval.1994,r24
 594               	.L55:
 295:main.c        **** 	
 296:main.c        **** 	if (mode == RECORD)
 596               	.LM68:
 597 01da C130      		cpi r28,lo8(1)
 598 01dc 01F0      		breq .+2
 599 01de 00C0      		rjmp .L56
 297:main.c        **** 	{
 298:main.c        **** 		interval = 0; // Reset previous settings
 601               	.LM69:
 602 01e0 1092 0000 		sts interval.1994+1,__zero_reg__
 603 01e4 1092 0000 		sts interval.1994,__zero_reg__
 299:main.c        **** 		timer = YACKSECS(DEFTIMEOUT);
 605               	.LM70:
 606 01e8 88EE      		ldi r24,lo8(-24)
 607 01ea 93E0      		ldi r25,lo8(3)
 608 01ec 9093 0000 		sts timer.1995+1,r25
 609 01f0 8093 0000 		sts timer.1995,r24
 300:main.c        **** 		
 301:main.c        **** 		yackchar('N');
 611               	.LM71:
 612 01f4 8EE4      		ldi r24,lo8(78)
 613 01f6 00D0      		rcall yackchar
 302:main.c        **** 		
 303:main.c        **** 		while(--timer)
 304:main.c        **** 		{	
 305:main.c        **** 			c=yackiambic(FALSE);
 306:main.c        **** 			yackbeat();
 307:main.c        **** 			
 308:main.c        **** 			if (c>='0' && c<='9')
 309:main.c        **** 			{
 310:main.c        **** 				interval *= 10;
 311:main.c        **** 				interval += c - '0';
 312:main.c        **** 				timer = YACKSECS(DEFTIMEOUT);
 615               	.LM72:
 616 01f8 08EE      		ldi r16,lo8(-24)
 617 01fa 13E0      		ldi r17,lo8(3)
 618               	.L58:
 303:main.c        **** 		{	
 620               	.LM73:
 621 01fc 8091 0000 		lds r24,timer.1995
 622 0200 9091 0000 		lds r25,timer.1995+1
 623 0204 0197      		sbiw r24,1
 624 0206 9093 0000 		sts timer.1995+1,r25
 625 020a 8093 0000 		sts timer.1995,r24
 626 020e 892B      		or r24,r25
 627 0210 01F0      		breq .L68
 305:main.c        **** 			yackbeat();
 629               	.LM74:
 630 0212 80E0      		ldi r24,0
 631 0214 00D0      		rcall yackiambic
 632 0216 C82F      		mov r28,r24
 306:main.c        **** 			
 634               	.LM75:
 635 0218 00D0      		rcall yackbeat
 308:main.c        **** 			{
 637               	.LM76:
 638 021a 80ED      		ldi r24,lo8(-48)
 639 021c 8C0F      		add r24,r28
 640 021e 8A30      		cpi r24,lo8(10)
 641 0220 00F4      		brsh .L58
 311:main.c        **** 				timer = YACKSECS(DEFTIMEOUT);
 643               	.LM77:
 644 0222 8091 0000 		lds r24,interval.1994
 645 0226 9091 0000 		lds r25,interval.1994+1
 646 022a 6AE0      		ldi r22,lo8(10)
 647 022c 70E0      		ldi r23,0
 648 022e 00D0      		rcall __mulhi3
 649 0230 C097      		sbiw r24,48
 650 0232 8C0F      		add r24,r28
 651 0234 911D      		adc r25,__zero_reg__
 652 0236 9093 0000 		sts interval.1994+1,r25
 653 023a 8093 0000 		sts interval.1994,r24
 655               	.LM78:
 656 023e 1093 0000 		sts timer.1995+1,r17
 657 0242 0093 0000 		sts timer.1995,r16
 658 0246 00C0      		rjmp .L58
 659               	.L68:
 313:main.c        **** 			}
 314:main.c        **** 		}
 315:main.c        **** 		
 316:main.c        **** 		if (interval >= 0 && interval <= 9999)
 661               	.LM79:
 662 0248 4091 0000 		lds r20,interval.1994
 663 024c 5091 0000 		lds r21,interval.1994+1
 664 0250 4031      		cpi r20,16
 665 0252 87E2      		ldi r24,39
 666 0254 5807      		cpc r21,r24
 667 0256 00F4      		brsh .L60
 317:main.c        **** 		{
 318:main.c        **** 			yackuser(WRITE, 1, interval); // Record interval
 669               	.LM80:
 670 0258 61E0      		ldi r22,lo8(1)
 671 025a 82E0      		ldi r24,lo8(2)
 672 025c 00D0      		rcall yackuser
 319:main.c        **** 			yacknumber(interval); // Playback number
 674               	.LM81:
 675 025e 8091 0000 		lds r24,interval.1994
 676 0262 9091 0000 		lds r25,interval.1994+1
 677               	/* epilogue start */
 320:main.c        **** 		}
 321:main.c        **** 		else 
 322:main.c        **** 		{
 323:main.c        **** 			yackerror();
 324:main.c        **** 		}
 325:main.c        **** 		
 326:main.c        **** 	}
 327:main.c        **** 
 328:main.c        **** 	
 329:main.c        **** 	if ((mode == PLAY) && interval)
 330:main.c        **** 	{
 331:main.c        **** 
 332:main.c        **** #ifdef POWERSAVE
 333:main.c        **** 
 334:main.c        ****         // If we execute this, the interval counter is positive which means we are waiting
 335:main.c        ****         // for a message playback. In this case we must not allow the CPU to enter sleep mode.
 336:main.c        ****         
 337:main.c        ****         yackpower(FALSE); // Inhibit sleep mode
 338:main.c        ****         
 339:main.c        **** #endif
 340:main.c        ****         
 341:main.c        **** 		if (timer) timer--; // Countdown until a second has expired
 342:main.c        **** 		else 
 343:main.c        **** 		{
 344:main.c        **** 			timer = YACKSECS(1); // Reset timer
 345:main.c        **** 			
 346:main.c        **** 			if ((--interval)==0) // Interval was > 0. Did decrement bring it to 0?
 347:main.c        **** 			{
 348:main.c        **** 
 349:main.c        **** 				interval = yackuser(READ, 1, 0); // Reset the interval timer
 350:main.c        **** 				yackmessage(PLAY,4); // And play message 4
 351:main.c        **** 
 352:main.c        **** 				
 353:main.c        **** 			} 
 354:main.c        **** 			
 355:main.c        **** 		}
 356:main.c        **** 				
 357:main.c        **** 	}
 358:main.c        **** 	
 359:main.c        **** }
 679               	.LM82:
 680 0266 CF91      		pop r28
 681 0268 1F91      		pop r17
 682 026a 0F91      		pop r16
 319:main.c        **** 			yacknumber(interval); // Playback number
 684               	.LM83:
 685 026c 00C0      		rjmp yacknumber
 686               	.L60:
 687               	/* epilogue start */
 689               	.LM84:
 690 026e CF91      		pop r28
 691 0270 1F91      		pop r17
 692 0272 0F91      		pop r16
 323:main.c        **** 		}
 694               	.LM85:
 695 0274 00C0      		rjmp yackerror
 696               	.L56:
 329:main.c        **** 	{
 698               	.LM86:
 699 0276 C230      		cpi r28,lo8(2)
 700 0278 01F4      		brne .L54
 329:main.c        **** 	{
 702               	.LM87:
 703 027a 8091 0000 		lds r24,interval.1994
 704 027e 9091 0000 		lds r25,interval.1994+1
 705 0282 892B      		or r24,r25
 706 0284 01F0      		breq .L54
 337:main.c        ****         
 708               	.LM88:
 709 0286 80E0      		ldi r24,0
 710 0288 00D0      		rcall yackpower
 341:main.c        **** 		else 
 712               	.LM89:
 713 028a 8091 0000 		lds r24,timer.1995
 714 028e 9091 0000 		lds r25,timer.1995+1
 715 0292 0097      		sbiw r24,0
 716 0294 01F0      		breq .L62
 341:main.c        **** 		else 
 718               	.LM90:
 719 0296 0197      		sbiw r24,1
 720 0298 9093 0000 		sts timer.1995+1,r25
 721 029c 8093 0000 		sts timer.1995,r24
 722 02a0 00C0      		rjmp .L54
 723               	.L62:
 344:main.c        **** 			
 725               	.LM91:
 726 02a2 88EC      		ldi r24,lo8(-56)
 727 02a4 90E0      		ldi r25,0
 728 02a6 9093 0000 		sts timer.1995+1,r25
 729 02aa 8093 0000 		sts timer.1995,r24
 346:main.c        **** 			{
 731               	.LM92:
 732 02ae 8091 0000 		lds r24,interval.1994
 733 02b2 9091 0000 		lds r25,interval.1994+1
 734 02b6 0197      		sbiw r24,1
 735 02b8 9093 0000 		sts interval.1994+1,r25
 736 02bc 8093 0000 		sts interval.1994,r24
 737 02c0 892B      		or r24,r25
 738 02c2 01F4      		brne .L54
 349:main.c        **** 				yackmessage(PLAY,4); // And play message 4
 740               	.LM93:
 741 02c4 40E0      		ldi r20,0
 742 02c6 50E0      		ldi r21,0
 743 02c8 61E0      		ldi r22,lo8(1)
 744 02ca 81E0      		ldi r24,lo8(1)
 745 02cc 00D0      		rcall yackuser
 746 02ce 9093 0000 		sts interval.1994+1,r25
 747 02d2 8093 0000 		sts interval.1994,r24
 350:main.c        **** 
 749               	.LM94:
 750 02d6 64E0      		ldi r22,lo8(4)
 751 02d8 82E0      		ldi r24,lo8(2)
 752               	/* epilogue start */
 754               	.LM95:
 755 02da CF91      		pop r28
 756 02dc 1F91      		pop r17
 757 02de 0F91      		pop r16
 350:main.c        **** 
 759               	.LM96:
 760 02e0 00C0      		rjmp yackmessage
 761               	.L54:
 762               	/* epilogue start */
 764               	.LM97:
 765 02e2 CF91      		pop r28
 766 02e4 1F91      		pop r17
 767 02e6 0F91      		pop r16
 768 02e8 0895      		ret
 775               	.Lscope6:
 777               	.global	commandmode
 779               	commandmode:
 360:main.c        **** 
 361:main.c        **** 
 362:main.c        **** 
 363:main.c        **** 
 364:main.c        **** void commandmode(void)
 365:main.c        **** /*! 
 366:main.c        ****  @brief     Command mode
 367:main.c        ****  
 368:main.c        ****  This routine implements command mode. Entries are read from the paddle
 369:main.c        ****  and interpreted as commands.
 370:main.c        ****  
 371:main.c        **** */
 372:main.c        **** {
 781               	.LM98:
 782               	.LFBB7:
 783 02ea 0F93      		push r16
 784 02ec 1F93      		push r17
 785 02ee CF93      		push r28
 786               	/* prologue: function */
 787               	/* frame size = 0 */
 788               	/* stack size = 3 */
 789               	.L__stack_usage = 3
 373:main.c        **** 	
 374:main.c        **** 	char 	c;				// Character from Morse key
 375:main.c        ****     word    timer;          // Exit timer
 376:main.c        **** 	
 377:main.c        **** 	yackinhibit(ON); 		// Sidetone = on, Keyer = off
 791               	.LM99:
 792 02f0 81E0      		ldi r24,lo8(1)
 793 02f2 00D0      		rcall yackinhibit
 378:main.c        **** 	
 379:main.c        **** 	//yackchar('?'); 			// Play Greeting (removed, since we have the LED to indicate)
 380:main.c        **** 	
 381:main.c        ****     timer = YACKSECS(DEFTIMEOUT); // Time out after 10 seconds
 795               	.LM100:
 796 02f4 08EE      		ldi r16,lo8(-24)
 797 02f6 13E0      		ldi r17,lo8(3)
 798               	.L70:
 382:main.c        ****     
 383:main.c        ****     while ((yackctrlkey(TRUE)==0) && (timer-- > 0))
 800               	.LM101:
 801 02f8 81E0      		ldi r24,lo8(1)
 802 02fa 00D0      		rcall yackctrlkey
 803 02fc 8111      		cpse r24,__zero_reg__
 804 02fe 00C0      		rjmp .L105
 806               	.LM102:
 807 0300 0115      		cp r16,__zero_reg__
 808 0302 1105      		cpc r17,__zero_reg__
 809 0304 01F4      		brne .+2
 810 0306 00C0      		rjmp .L105
 384:main.c        **** 	{
 385:main.c        **** 		
 386:main.c        **** 		c=yackiambic(OFF);
 812               	.LM103:
 813 0308 80E0      		ldi r24,0
 814 030a 00D0      		rcall yackiambic
 815 030c C82F      		mov r28,r24
 387:main.c        ****         if (c) timer = YACKSECS(DEFTIMEOUT); // Reset timeout if character read
 817               	.LM104:
 818 030e 8111      		cpse r24,__zero_reg__
 819 0310 00C0      		rjmp .L107
 383:main.c        **** 	{
 821               	.LM105:
 822 0312 0150      		subi r16,1
 823 0314 1109      		sbc r17,__zero_reg__
 824 0316 00C0      		rjmp .L71
 825               	.L107:
 827               	.LM106:
 828 0318 08EE      		ldi r16,lo8(-24)
 829 031a 13E0      		ldi r17,lo8(3)
 830               	.L71:
 388:main.c        ****         
 389:main.c        **** 		yackbeat();
 832               	.LM107:
 833 031c 00D0      		rcall yackbeat
 390:main.c        ****         
 391:main.c        ****         lfsr(255);          // Keep seeding the LFSR so we get different callsigns
 835               	.LM108:
 836 031e 8FEF      		ldi r24,lo8(-1)
 837 0320 00D0      		rcall lfsr
 392:main.c        **** 		
 393:main.c        ****         if (!yackflag(CONFLOCK)) // No Configuration lock?
 839               	.LM109:
 840 0322 82E0      		ldi r24,lo8(2)
 841 0324 00D0      		rcall yackflag
 842 0326 8111      		cpse r24,__zero_reg__
 843 0328 00C0      		rjmp .L72
 394:main.c        ****         {    
 395:main.c        ****             switch (c) // These are the lockable configuration commands
 845               	.LM110:
 846 032a 8C2F      		mov r24,r28
 847 032c 90E0      		ldi r25,0
 848 032e FC01      		movw r30,r24
 849 0330 F197      		sbiw r30,49
 850 0332 EA32      		cpi r30,42
 851 0334 F105      		cpc r31,__zero_reg__
 852 0336 00F4      		brsh .L72
 853 0338 E050      		subi r30,lo8(-(gs(.L74)))
 854 033a F040      		sbci r31,hi8(-(gs(.L74)))
 855 033c 0994      		ijmp
 856               		.section	.progmem.gcc_sw_table,"ax",@progbits
 857               		.p2align	1
 858               	.L74:
 859 0000 00C0      		rjmp .L73
 860 0002 00C0      		rjmp .L75
 861 0004 00C0      		rjmp .L76
 862 0006 00C0      		rjmp .L77
 863 0008 00C0      		rjmp .L72
 864 000a 00C0      		rjmp .L72
 865 000c 00C0      		rjmp .L72
 866 000e 00C0      		rjmp .L72
 867 0010 00C0      		rjmp .L72
 868 0012 00C0      		rjmp .L72
 869 0014 00C0      		rjmp .L72
 870 0016 00C0      		rjmp .L72
 871 0018 00C0      		rjmp .L72
 872 001a 00C0      		rjmp .L72
 873 001c 00C0      		rjmp .L72
 874 001e 00C0      		rjmp .L72
 875 0020 00C0      		rjmp .L78
 876 0022 00C0      		rjmp .L79
 877 0024 00C0      		rjmp .L72
 878 0026 00C0      		rjmp .L80
 879 0028 00C0      		rjmp .L72
 880 002a 00C0      		rjmp .L81
 881 002c 00C0      		rjmp .L72
 882 002e 00C0      		rjmp .L72
 883 0030 00C0      		rjmp .L72
 884 0032 00C0      		rjmp .L72
 885 0034 00C0      		rjmp .L82
 886 0036 00C0      		rjmp .L83
 887 0038 00C0      		rjmp .L72
 888 003a 00C0      		rjmp .L84
 889 003c 00C0      		rjmp .L72
 890 003e 00C0      		rjmp .L72
 891 0040 00C0      		rjmp .L72
 892 0042 00C0      		rjmp .L85
 893 0044 00C0      		rjmp .L86
 894 0046 00C0      		rjmp .L72
 895 0048 00C0      		rjmp .L72
 896 004a 00C0      		rjmp .L72
 897 004c 00C0      		rjmp .L72
 898 004e 00C0      		rjmp .L87
 899 0050 00C0      		rjmp .L72
 900 0052 00C0      		rjmp .L88
 901               		.text
 902               	.L85:
 396:main.c        ****             {
 397:main.c        ****                     
 398:main.c        ****                 case	'R': // Reset
 399:main.c        ****                     yackreset();
 904               	.LM111:
 905 033e 00D0      		rcall yackreset
 400:main.c        ****                     c = TRUE;
 401:main.c        ****                     break;
 907               	.LM112:
 908 0340 00C0      		rjmp .L89
 909               	.L78:
 402:main.c        ****                     
 403:main.c        ****                 case	'A': // IAMBIC A
 404:main.c        ****                     yackmode(IAMBICA);
 911               	.LM113:
 912 0342 80E0      		ldi r24,0
 913 0344 00C0      		rjmp .L116
 914               	.L79:
 405:main.c        ****                     c = TRUE;
 406:main.c        ****                     break;
 407:main.c        ****                     
 408:main.c        ****                 case	'B': // IAMBIC B
 409:main.c        ****                     yackmode(IAMBICB);
 916               	.LM114:
 917 0346 84E0      		ldi r24,lo8(4)
 918 0348 00C0      		rjmp .L116
 919               	.L83:
 410:main.c        ****                     c = TRUE;
 411:main.c        ****                     break;
 412:main.c        **** 
 413:main.c        ****                 case	'L': // ULTIMATIC
 414:main.c        ****                     yackmode(ULTIMATIC);
 921               	.LM115:
 922 034a 88E0      		ldi r24,lo8(8)
 923 034c 00C0      		rjmp .L116
 924               	.L80:
 415:main.c        ****                     c = TRUE;
 416:main.c        ****                     break;
 417:main.c        ****                     
 418:main.c        ****                 case    'D': // DAHPRIO
 419:main.c        ****                     yackmode(DAHPRIO);
 926               	.LM116:
 927 034e 8CE0      		ldi r24,lo8(12)
 928               	.L116:
 929 0350 00D0      		rcall yackmode
 420:main.c        ****                     c = TRUE;
 421:main.c        ****                     break;
 931               	.LM117:
 932 0352 00C0      		rjmp .L89
 933               	.L87:
 422:main.c        ****                     
 423:main.c        ****                 case	'X': // Paddle swapping
 424:main.c        ****                     yacktoggle(PDLSWAP);
 935               	.LM118:
 936 0354 80E8      		ldi r24,lo8(-128)
 937 0356 00C0      		rjmp .L115
 938               	.L86:
 425:main.c        ****                     c = TRUE;
 426:main.c        ****                     break;
 427:main.c        ****                     
 428:main.c        ****                 case    'S': // Sidetone toggle
 429:main.c        ****                     yacktoggle(SIDETONE);
 940               	.LM119:
 941 0358 80E1      		ldi r24,lo8(16)
 942 035a 00C0      		rjmp .L115
 943               	.L82:
 430:main.c        ****                     c = TRUE;
 431:main.c        ****                     break;
 432:main.c        ****                     
 433:main.c        ****                 case    'K': // TX keying toggle
 434:main.c        ****                     yacktoggle(TXKEY);
 945               	.LM120:
 946 035c 80E2      		ldi r24,lo8(32)
 947 035e 00C0      		rjmp .L115
 948               	.L88:
 435:main.c        ****                     c = TRUE;
 436:main.c        ****                     break;
 437:main.c        ****                     
 438:main.c        ****                 case    'Z': // Farnsworth pause
 439:main.c        ****                     setfarns();
 950               	.LM121:
 951 0360 00D0      		rcall setfarns
 440:main.c        ****                     c = TRUE;
 441:main.c        ****                     break;
 953               	.LM122:
 954 0362 00C0      		rjmp .L89
 955               	.L81:
 442:main.c        ****                         
 443:main.c        ****                 case    'F': // TX level inverter toggle
 444:main.c        ****                     yacktoggle(TXINV);
 957               	.LM123:
 958 0364 80E4      		ldi r24,lo8(64)
 959 0366 00C0      		rjmp .L115
 960               	.L73:
 445:main.c        ****                     c = TRUE;
 446:main.c        ****                     break;
 447:main.c        ****                     
 448:main.c        ****                 case	'1': // Record Macro 1
 449:main.c        ****                     yackchar('1');
 962               	.LM124:
 963 0368 81E3      		ldi r24,lo8(49)
 964 036a 00D0      		rcall yackchar
 450:main.c        ****                     yackmessage(RECORD,1); 
 966               	.LM125:
 967 036c 61E0      		ldi r22,lo8(1)
 968 036e 00C0      		rjmp .L114
 969               	.L75:
 451:main.c        ****                     c = TRUE;
 452:main.c        ****                     break;
 453:main.c        ****                     
 454:main.c        ****                 case	'2': // Record Macro 2
 455:main.c        ****                     yackchar('2');
 971               	.LM126:
 972 0370 82E3      		ldi r24,lo8(50)
 973 0372 00D0      		rcall yackchar
 456:main.c        ****                     yackmessage(RECORD,2); 
 975               	.LM127:
 976 0374 62E0      		ldi r22,lo8(2)
 977 0376 00C0      		rjmp .L114
 978               	.L76:
 457:main.c        ****                     c = TRUE;
 458:main.c        ****                     break;
 459:main.c        **** 					
 460:main.c        **** 				case	'3': // Record Macro 3
 461:main.c        ****                     yackchar('3');
 980               	.LM128:
 981 0378 83E3      		ldi r24,lo8(51)
 982 037a 00D0      		rcall yackchar
 462:main.c        ****                     yackmessage(RECORD,3); 
 984               	.LM129:
 985 037c 63E0      		ldi r22,lo8(3)
 986 037e 00C0      		rjmp .L114
 987               	.L77:
 463:main.c        ****                     c = TRUE;
 464:main.c        ****                     break;
 465:main.c        **** 
 466:main.c        **** 				case	'4': // Record Macro 4
 467:main.c        ****                     yackchar('4');
 989               	.LM130:
 990 0380 84E3      		ldi r24,lo8(52)
 991 0382 00D0      		rcall yackchar
 468:main.c        ****                     yackmessage(RECORD,4); 
 993               	.LM131:
 994 0384 64E0      		ldi r22,lo8(4)
 995               	.L114:
 996 0386 81E0      		ldi r24,lo8(1)
 997 0388 00D0      		rcall yackmessage
 469:main.c        ****                     c = TRUE;
 470:main.c        ****                     break;	
 999               	.LM132:
 1000 038a 00C0      		rjmp .L89
 1001               	.L84:
 471:main.c        ****                     
 472:main.c        ****                 case	'N': // Automatic Beacon
 473:main.c        ****                     beacon(RECORD);
 1003               	.LM133:
 1004 038c 81E0      		ldi r24,lo8(1)
 1005 038e 00D0      		rcall beacon
 474:main.c        ****                     c = TRUE;
 475:main.c        ****                     break;
 1007               	.LM134:
 1008 0390 00C0      		rjmp .L89
 1009               	.L72:
 476:main.c        ****                     
 477:main.c        ****             }
 478:main.c        ****             
 479:main.c        ****         }
 480:main.c        ****         
 481:main.c        ****         switch (c) // Commands that can be used anytime
 1011               	.LM135:
 1012 0392 CD34      		cpi r28,lo8(77)
 1013 0394 01F0      		breq .L91
 1014 0396 00F4      		brsh .L92
 1015 0398 C334      		cpi r28,lo8(67)
 1016 039a 01F0      		breq .L93
 1017 039c 00F4      		brsh .L94
 1018 039e C033      		cpi r28,lo8(48)
 1019 03a0 01F4      		brne .L90
 482:main.c        ****         {
 483:main.c        ****                 
 484:main.c        ****             case    'V': // Version
 485:main.c        ****                 yackstring(vers);
 486:main.c        ****                 c = TRUE;
 487:main.c        ****                 break;
 488:main.c        ****     
 489:main.c        ****                 
 490:main.c        ****             case	'P': // Pitch
 491:main.c        ****                 pitch();
 492:main.c        ****                 c = TRUE;
 493:main.c        ****                 break;
 494:main.c        ****                 
 495:main.c        ****             case	'U': // Tune
 496:main.c        ****                 yackinhibit(OFF);
 497:main.c        ****                 yacktune();
 498:main.c        ****                 yackinhibit(ON); 
 499:main.c        ****                 c = TRUE;
 500:main.c        ****                 break;
 501:main.c        ****                 
 502:main.c        ****             case	'C': // Callsign training
 503:main.c        ****                 cstrain();
 504:main.c        ****                 c = TRUE;
 505:main.c        ****                 break;
 506:main.c        ****                 
 507:main.c        ****             case    '0': // Lock changes
 508:main.c        ****                 yacktoggle(CONFLOCK);
 1021               	.LM136:
 1022 03a2 82E0      		ldi r24,lo8(2)
 1023 03a4 00C0      		rjmp .L115
 1024               	.L94:
 481:main.c        ****         {
 1026               	.LM137:
 1027 03a6 C534      		cpi r28,lo8(69)
 1028 03a8 01F0      		breq .L96
 1029 03aa C934      		cpi r28,lo8(73)
 1030 03ac 01F4      		brne .L90
 509:main.c        ****                 c = TRUE;
 510:main.c        ****                 break;
 511:main.c        ****                 
 512:main.c        ****             case	'E': // Playback Macro 1
 513:main.c        ****                 yackinhibit(OFF);
 514:main.c        ****                 yackmessage(PLAY,1);
 515:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message
 516:main.c        ****                 c = FALSE;
 517:main.c        ****                 return;
 518:main.c        ****                 
 519:main.c        ****             case	'I': // Playback Macro 2
 520:main.c        ****                 yackinhibit(OFF);
 1032               	.LM138:
 1033 03ae 80E0      		ldi r24,0
 1034 03b0 00D0      		rcall yackinhibit
 521:main.c        ****                 yackmessage(PLAY,2);
 1036               	.LM139:
 1037 03b2 62E0      		ldi r22,lo8(2)
 1038 03b4 00C0      		rjmp .L117
 1039               	.L92:
 481:main.c        ****         {
 1041               	.LM140:
 1042 03b6 C535      		cpi r28,lo8(85)
 1043 03b8 01F0      		breq .L98
 1044 03ba 00F4      		brsh .L99
 1045 03bc C035      		cpi r28,lo8(80)
 1046 03be 01F0      		breq .L100
 1047 03c0 C435      		cpi r28,lo8(84)
 1048 03c2 01F4      		brne .L90
 522:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message;
 523:main.c        ****                 c = FALSE;
 524:main.c        ****                 return;
 525:main.c        **** 				
 526:main.c        **** 			case	'T': // Playback Macro 3
 527:main.c        ****                 yackinhibit(OFF);
 1050               	.LM141:
 1051 03c4 80E0      		ldi r24,0
 1052 03c6 00D0      		rcall yackinhibit
 528:main.c        ****                 yackmessage(PLAY,3);
 1054               	.LM142:
 1055 03c8 63E0      		ldi r22,lo8(3)
 1056 03ca 00C0      		rjmp .L117
 1057               	.L99:
 481:main.c        ****         {
 1059               	.LM143:
 1060 03cc C635      		cpi r28,lo8(86)
 1061 03ce 01F0      		breq .L102
 1062 03d0 C735      		cpi r28,lo8(87)
 1063 03d2 01F4      		brne .L90
 529:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message;
 530:main.c        ****                 c = FALSE;
 531:main.c        ****                 return;
 532:main.c        **** 				
 533:main.c        **** 			case	'M': // Playback Macro 4
 534:main.c        ****                 yackinhibit(OFF);
 535:main.c        ****                 yackmessage(PLAY,4);
 536:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message;
 537:main.c        ****                 c = FALSE;
 538:main.c        ****                 return;
 539:main.c        ****                 
 540:main.c        ****             case    'W': // Query WPM
 541:main.c        ****                 yacknumber(yackwpm());
 1065               	.LM144:
 1066 03d4 00D0      		rcall yackwpm
 1067 03d6 00D0      		rcall yacknumber
 542:main.c        ****                 c = TRUE;
 543:main.c        ****                 break;
 1069               	.LM145:
 1070 03d8 00C0      		rjmp .L89
 1071               	.L102:
 485:main.c        ****                 c = TRUE;
 1073               	.LM146:
 1074 03da 80E0      		ldi r24,lo8(vers)
 1075 03dc 90E0      		ldi r25,hi8(vers)
 1076 03de 00D0      		rcall yackstring
 487:main.c        ****     
 1078               	.LM147:
 1079 03e0 00C0      		rjmp .L89
 1080               	.L100:
 491:main.c        ****                 c = TRUE;
 1082               	.LM148:
 1083 03e2 00D0      		rcall pitch
 493:main.c        ****                 
 1085               	.LM149:
 1086 03e4 00C0      		rjmp .L89
 1087               	.L98:
 496:main.c        ****                 yacktune();
 1089               	.LM150:
 1090 03e6 80E0      		ldi r24,0
 1091 03e8 00D0      		rcall yackinhibit
 497:main.c        ****                 yackinhibit(ON); 
 1093               	.LM151:
 1094 03ea 00D0      		rcall yacktune
 498:main.c        ****                 c = TRUE;
 1096               	.LM152:
 1097 03ec 81E0      		ldi r24,lo8(1)
 1098 03ee 00D0      		rcall yackinhibit
 500:main.c        ****                 
 1100               	.LM153:
 1101 03f0 00C0      		rjmp .L89
 1102               	.L93:
 503:main.c        ****                 c = TRUE;
 1104               	.LM154:
 1105 03f2 00D0      		rcall cstrain
 505:main.c        ****                 
 1107               	.LM155:
 1108 03f4 00C0      		rjmp .L89
 1109               	.L115:
 508:main.c        ****                 c = TRUE;
 1111               	.LM156:
 1112 03f6 00D0      		rcall yacktoggle
 510:main.c        ****                 
 1114               	.LM157:
 1115 03f8 00C0      		rjmp .L89
 1116               	.L96:
 513:main.c        ****                 yackmessage(PLAY,1);
 1118               	.LM158:
 1119 03fa 80E0      		ldi r24,0
 1120 03fc 00D0      		rcall yackinhibit
 514:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message
 1122               	.LM159:
 1123 03fe 61E0      		ldi r22,lo8(1)
 1124 0400 00C0      		rjmp .L117
 1125               	.L91:
 534:main.c        ****                 yackmessage(PLAY,4);
 1127               	.LM160:
 1128 0402 80E0      		ldi r24,0
 1129 0404 00D0      		rcall yackinhibit
 535:main.c        ****                 yackinhibit(OFF); // Go to normal mode after playing saved message;
 1131               	.LM161:
 1132 0406 64E0      		ldi r22,lo8(4)
 1133               	.L117:
 1134 0408 82E0      		ldi r24,lo8(2)
 1135 040a 00D0      		rcall yackmessage
 1136 040c 00C0      		rjmp .L105
 1137               	.L90:
 544:main.c        ****                 
 545:main.c        ****                 
 546:main.c        ****         }
 547:main.c        ****         
 548:main.c        ****         if (c == TRUE) // If c still contains a string, the command was not handled properly
 1139               	.LM162:
 1140 040e C130      		cpi r28,lo8(1)
 1141 0410 01F0      		breq .L89
 549:main.c        **** 		{
 550:main.c        **** 			yacksave(); //Save any non-volatile changes to EEPROM
 551:main.c        **** 			yackdelay(DAHLEN * 3); //Eliminate runon txok on some commands
 552:main.c        ****             yackstring(txok);
 553:main.c        **** 		}
 554:main.c        ****         else if (c)
 1143               	.LM163:
 1144 0412 CC23      		tst r28
 1145 0414 01F4      		brne .+2
 1146 0416 00C0      		rjmp .L70
 555:main.c        ****             yackerror();    
 1148               	.LM164:
 1149 0418 00D0      		rcall yackerror
 1150 041a 00C0      		rjmp .L70
 1151               	.L105:
 556:main.c        ****             
 557:main.c        **** 	}
 558:main.c        ****         
 559:main.c        ****         
 560:main.c        **** 	//yackstring(prgx); 			// Sign off (removed, since we have the LED to indicate)
 561:main.c        **** 
 562:main.c        **** 	yackinhibit(OFF);		// Back to normal mode
 1153               	.LM165:
 1154 041c 80E0      		ldi r24,0
 1155               	/* epilogue start */
 563:main.c        **** 	
 564:main.c        **** }
 1157               	.LM166:
 1158 041e CF91      		pop r28
 1159 0420 1F91      		pop r17
 1160 0422 0F91      		pop r16
 562:main.c        **** 	
 1162               	.LM167:
 1163 0424 00C0      		rjmp yackinhibit
 1164               	.L89:
 550:main.c        **** 			yackdelay(DAHLEN * 3); //Eliminate runon txok on some commands
 1166               	.LM168:
 1167 0426 00D0      		rcall yacksave
 551:main.c        ****             yackstring(txok);
 1169               	.LM169:
 1170 0428 89E0      		ldi r24,lo8(9)
 1171 042a 00D0      		rcall yackdelay
 552:main.c        **** 		}
 1173               	.LM170:
 1174 042c 80E0      		ldi r24,lo8(txok)
 1175 042e 90E0      		ldi r25,hi8(txok)
 1176 0430 00D0      		rcall yackstring
 1177 0432 00C0      		rjmp .L70
 1183               	.Lscope7:
 1184               		.section	.text.startup,"ax",@progbits
 1186               	.global	main
 1188               	main:
 565:main.c        **** 
 566:main.c        **** 
 567:main.c        **** 
 568:main.c        **** int main(void) 
 569:main.c        **** /*! 
 570:main.c        ****  @brief     Trivial main routine
 571:main.c        ****  
 572:main.c        ****  Yack library is initialized, command mode is entered on request and both 
 573:main.c        ****  beacon and keyer routines are called in 10 ms intervals.
 574:main.c        ****  
 575:main.c        ****  @return Not relevant
 576:main.c        **** */
 577:main.c        **** {
 1190               	.LM171:
 1191               	.LFBB8:
 1192               	/* prologue: function */
 1193               	/* frame size = 0 */
 1194               	/* stack size = 0 */
 1195               	.L__stack_usage = 0
 578:main.c        **** 	
 579:main.c        **** 	yackinit(); 					// Initialize YACK hardware
 1197               	.LM172:
 1198 0000 00D0      		rcall yackinit
 580:main.c        **** 	
 581:main.c        **** 	yackinhibit(ON);  //side tone greeting to confirm the unit is alive and kicking
 1200               	.LM173:
 1201 0002 81E0      		ldi r24,lo8(1)
 1202 0004 00D0      		rcall yackinhibit
 582:main.c        **** 	yackstring(imok);
 1204               	.LM174:
 1205 0006 80E0      		ldi r24,lo8(imok)
 1206 0008 90E0      		ldi r25,hi8(imok)
 1207 000a 00D0      		rcall yackstring
 583:main.c        **** 	yackinhibit(OFF);
 1209               	.LM175:
 1210 000c 80E0      		ldi r24,0
 1211 000e 00D0      		rcall yackinhibit
 1212               	.L120:
 584:main.c        **** 	
 585:main.c        **** 	while(1) // Endless core loop of the keyer app
 586:main.c        **** 	{
 587:main.c        **** 		
 588:main.c        **** 		if (yackctrlkey(TRUE)) // If command key pressed, go to command mode
 1214               	.LM176:
 1215 0010 81E0      		ldi r24,lo8(1)
 1216 0012 00D0      		rcall yackctrlkey
 1217 0014 8111      		cpse r24,__zero_reg__
 589:main.c        **** 			commandmode();
 1219               	.LM177:
 1220 0016 00D0      		rcall commandmode
 1221               	.L119:
 590:main.c        **** 		
 591:main.c        ****        	yackbeat();
 1223               	.LM178:
 1224 0018 00D0      		rcall yackbeat
 592:main.c        **** 		beacon(PLAY); // Play beacon if requested
 1226               	.LM179:
 1227 001a 82E0      		ldi r24,lo8(2)
 1228 001c 00D0      		rcall beacon
 593:main.c        ****        	yackiambic(OFF);
 1230               	.LM180:
 1231 001e 80E0      		ldi r24,0
 1232 0020 00D0      		rcall yackiambic
 594:main.c        ****         
 595:main.c        **** 	}
 1234               	.LM181:
 1235 0022 00C0      		rjmp .L120
 1237               	.Lscope8:
 1238               		.local	timer.1995
 1239               		.comm	timer.1995,2,1
 1240               		.data
 1243               	interval.1994:
 1244 0000 E8FD      		.word	-536
 1247               	lfsr.1962:
 1248 0002 E1AC      		.word	-21279
 1249               	.global	imok
 1250               		.section	.progmem.data,"a",@progbits
 1253               	imok:
 1254 0000 3733 00   		.string	"73"
 1255               	.global	prgx
 1258               	prgx:
 1259 0003 2300      		.string	"#"
 1260               	.global	vers
 1263               	vers:
 1264 0005 5630 2E38 		.string	"V0.87"
 1264      3700 
 1265               	.global	txok
 1268               	txok:
 1269 000b 5200      		.string	"R"
 1274               		.text
 1276               	.Letext0:
 1277               		.ident	"GCC: (GNU) 5.4.0"
 1278               	.global __do_copy_data
 1279               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccfSUqM4.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccfSUqM4.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccfSUqM4.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccfSUqM4.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccfSUqM4.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccfSUqM4.s:115    .text:0000000000000000 pitch
     /tmp/ccfSUqM4.s:188    .text:0000000000000038 setfarns
     /tmp/ccfSUqM4.s:270    .text:0000000000000078 lfsr
     /tmp/ccfSUqM4.s:1247   .data:0000000000000002 lfsr.1962
     /tmp/ccfSUqM4.s:324    .text:00000000000000b0 rndcall
     /tmp/ccfSUqM4.s:388    .text:00000000000000f0 cstrain
     /tmp/ccfSUqM4.s:566    .text:00000000000001b2 beacon
     /tmp/ccfSUqM4.s:1243   .data:0000000000000000 interval.1994
                             .bss:0000000000000000 timer.1995
     /tmp/ccfSUqM4.s:779    .text:00000000000002ea commandmode
     /tmp/ccfSUqM4.s:1263   .progmem.data:0000000000000005 vers
     /tmp/ccfSUqM4.s:1268   .progmem.data:000000000000000b txok
     /tmp/ccfSUqM4.s:1188   .text.startup:0000000000000000 main
     /tmp/ccfSUqM4.s:1253   .progmem.data:0000000000000000 imok
     /tmp/ccfSUqM4.s:1258   .progmem.data:0000000000000003 prgx

UNDEFINED SYMBOLS
yackchar
yackctrlkey
yackpitch
yackplay
yackdelay
yackfarns
yackspeed
yackiambic
yackbeat
yackerror
yackuser
__mulhi3
yacknumber
yackpower
yackmessage
yackinhibit
yackflag
yackreset
yackmode
yackwpm
yackstring
yacktune
yacktoggle
yacksave
yackinit
__do_copy_data
__do_clear_bss
